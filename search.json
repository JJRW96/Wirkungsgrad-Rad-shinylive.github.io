[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\nCode\n1 + 1\n\n\n[1] 2"
  },
  {
    "objectID": "VO2.html",
    "href": "VO2.html",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nProzess:\n\nBestimmung des V̇O2_Start-Wertes:\n\nFinden des nächstgelegenen Zeitpunkts zu t_delay in den Daten\nSetzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses Punktes\n\nDatenauswahl:\n\nVerwendung der Daten zwischen t_delay und nlsLM_end\n\nStartwertebestimmung:\n\nVerwendung der aktuellen Slider-Werte für V̇O2 und Tau\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung des Levenberg-Marquardt-Algorithmus\nMaximale Iterationen: 1024\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n2 Bi-exponentiale Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten\nt_data &lt;- c(0.0, 2.7, 5.3, 8.3, 11.5, 13.6, 15.4, 17.1, 19.8, 21.1, 22.3, 23.5, 24.9, 27.5, 30.9, 32.4, 35.0, 38.3, 39.7, 41.6, 43.7, 45.3, 46.8, 49.8, 52.0, 53.6, 55.5, 57.5, 59.0, 60.7, 62.4, 64.4, 66.6, 68.1, 69.8, 71.4, 73.3, 75.0, 76.7, 78.4, 80.0, 82.2, 83.9, 85.4, 87.3, 88.8, 90.6, 92.0, 93.6, 94.8, 96.3, 97.9, 99.5, 101.1, 102.7, 104.3, 106.0, 107.7, 109.3, 110.9, 112.5, 114.8, 116.4, 118.1, 119.7, 121.3, 122.8, 124.3, 125.9, 127.4, 128.9, 130.6, 132.1, 133.6, 135.6, 137.1, 138.6, 140.1, 141.6, 143.1, 144.4, 145.8, 147.2, 148.4, 149.9, 151.6, 153.1, 154.7, 156.1, 157.4, 158.7, 160.5, 161.9, 163.3, 164.7, 166.2, 167.6, 169.1, 172.6, 173.9, 175.4, 176.7, 178.1, 179.6, 181.0, 182.4, 183.8, 185.3, 186.7, 188.2, 189.6, 191.0, 192.4, 193.8, 195.2, 196.6, 198.0, 199.3, 200.7, 202.0, 203.3, 204.7, 206.1, 207.5, 208.8, 210.2, 211.6, 213.0, 214.3, 215.7, 217.1, 218.4, 219.8, 221.1, 222.4, 223.7, 225.0, 226.3, 227.7, 229.0, 230.5, 231.9, 233.1, 234.4)\nVO2_data &lt;- c(0.823, 0.898, 0.966, 1.122, 1.281, 1.313, 1.463, 1.537, 1.602, 1.595, 1.598, 1.674, 1.923, 2.168, 2.439, 2.670, 2.797, 2.712, 2.688, 2.968, 3.228, 3.371, 3.673, 3.938, 4.076, 3.959, 3.886, 3.880, 3.928, 3.962, 4.173, 4.381, 4.268, 4.208, 4.234, 4.132, 4.109, 4.192, 4.304, 4.493, 4.352, 4.349, 4.332, 4.346, 4.345, 4.373, 4.320, 4.286, 4.353, 4.346, 4.287, 4.322, 4.250, 4.332, 4.257, 4.161, 4.120, 4.144, 4.115, 4.158, 4.186, 4.206, 4.220, 4.259, 4.291, 4.279, 4.295, 4.339, 4.371, 4.425, 4.448, 4.474, 4.517, 4.536, 4.544, 4.528, 4.432, 4.371, 4.367, 4.430, 4.492, 4.535, 4.510, 4.433, 4.399, 4.305, 4.308, 4.304, 4.366, 4.434, 4.501, 4.535, 4.512, 4.463, 4.509, 4.529, 4.586, 4.624, 4.740, 4.769, 4.788, 4.794, 4.824, 4.830, 4.888, 4.887, 4.915, 4.924, 4.955, 4.965, 4.982, 4.992, 5.016, 5.024, 5.033, 5.066, 5.081, 5.053, 5.035, 4.997, 5.018, 5.038, 5.035, 5.039, 4.970, 4.970, 4.973, 4.964, 4.945, 4.953, 4.974, 4.984, 4.997, 4.995, 4.946, 4.997, 5.014, 5.092, 5.072, 5.111, 5.088, 5.065, 5.061, 5.038)\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  titlePanel(\"Biexponentielle V̇O2-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"VO2\", \"V̇O2_fast\", min = 0.0, max = 7.0, value = 3.7, step = 0.01),\n           sliderInput(\"tau_fast\", \"Tau_fast\", min = 10, max = 120, value = 45, step = 0.1),\n           sliderInput(\"VO2_Start\", \"V̇O2_Start\", min = 0.0, max = 4.0, value = 0.8, step = 0.01),\n           sliderInput(\"VO2_Ruhe\", \"V̇O2_Ruhe\", min = 0, max = 1, value = 0.4, step = 0.1),\n           sliderInput(\"time_delay\", \"Zeitverzögerung_fast\", min = 0, max = 600, value = 0, step = 1),\n           sliderInput(\"VO2_slow\", \"V̇O2_slow\", min = 0.0, max = 1.0, value = 0.3, step = 0.01),\n           sliderInput(\"tau_slow\", \"Tau_slow\", min = 90, max = 600, value = 110, step = 0.1),\n           sliderInput(\"time_delay_slow\", \"Zeitverzögerung_slow\", min = 0, max = 1200, value = 160, step = 1),\n           conditionalPanel(\n             condition = \"output.showFitSlider\",\n             sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = 300, value = 300, step = 1)\n           ),\n           actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modellanpassung:\")),\n           actionButton(\"fit_fast\", \"1. Fit: Schnelle Komponente\"),br(),\n           actionButton(\"fit_slow\", \"2. Fit: Langsame Komponente & Verfeinerung\"),br(),\n           actionButton(\"fit_optimize\", \"3. Fit: Optimierung\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  current_data &lt;- reactiveVal(NULL)\n  current_r_squared &lt;- reactiveVal(NA)\n  \n  calculate_r_squared &lt;- function(observed, predicted) {\n    ss_res &lt;- sum((observed - predicted)^2, na.rm = TRUE)\n    ss_tot &lt;- sum((observed - mean(observed, na.rm = TRUE))^2, na.rm = TRUE)\n    return(1 - (ss_res / ss_tot))\n  }\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    if (show_data()) {\n      current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n    } else {\n      current_data(NULL)\n    }\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observe({\n    req(input$VO2_Start, input$VO2_Ruhe)\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  # Hilfsfunktion zur Bestimmung des nächstgelegenen VO2-Wertes\n  find_nearest_VO2 &lt;- function(data, t_delay) {\n    req(data, t_delay)\n    if (nrow(data) == 0) return(NA)\n    \n    index &lt;- which.min(abs(data$t_s - t_delay))\n    return(data$VO2_t[index])\n  }\n  \n  \n  observeEvent(input$fit_fast, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    t_delay &lt;- isolate(input$time_delay)\n    \n    # Bestimme den nächstgelegenen VO2-Wert als VO2_Start\n    VO2_Start &lt;- find_nearest_VO2(Beispieldaten, t_delay)\n    \n    # Aktualisiere den VO2_Start Slider\n    updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte innerhalb der Slider-Grenzen\n        VO2_start &lt;- runif(1, 0.5, 7.0)\n        tau_fast_start &lt;- runif(1, 10, 120)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = 0.5, tau_fast = 10),\n                         upper = c(VO2 = 7.0, tau_fast = 120),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"VO2\", value = params$VO2)\n      updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = 0)\n      updateSliderInput(session, \"tau_slow\", value = 0)\n      \n      predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 1 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    \n    # Setze VO2_slow und tau_slow auf die initialen Werte\n    VO2_slow &lt;- 0.4\n    tau_slow &lt;- 160\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Berechne die obere Grenze für t_delay_slow\n    t_delay_slow_upper &lt;- max(Beispieldaten$t_s)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    best_t_delay_slow &lt;- NULL\n    best_VO2_fast &lt;- VO2\n    best_tau_fast &lt;- tau_fast\n    best_VO2_slow &lt;- VO2_slow\n    best_tau_slow &lt;- tau_slow\n    \n    # Berechne die Anzahl der Iterationen für t_delay_slow\n    num_iterations &lt;- floor(t_delay_slow_upper - (tau_fast + t_delay)) + 1\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:num_iterations) {\n        t_delay_slow &lt;- tau_fast + t_delay + i - 1\n        \n        # Fit VO2_fast und tau_fast nach unten\n        current_VO2_fast &lt;- best_VO2_fast\n        current_tau_fast &lt;- best_tau_fast\n        current_VO2_slow &lt;- best_VO2_slow\n        current_tau_slow &lt;- best_tau_slow\n        \n        model &lt;- function(VO2_fast, tau_fast, VO2_slow, tau_slow, t_delay_slow) {\n          VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast)) + \n            VO2_slow * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow, 0)) / tau_slow)) + \n            VO2_Start\n        }\n        \n        current_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n        \n        # Optimiere VO2_fast und tau_fast\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_fast zu reduzieren\n          if (current_VO2_fast &gt; 0.1) {\n            new_VO2_fast &lt;- max(0.1, current_VO2_fast - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(new_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_fast &lt;- new_VO2_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_fast zu reduzieren\n          if (current_tau_fast &gt; 10) {\n            new_tau_fast &lt;- max(10, current_tau_fast - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, new_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_fast &lt;- new_tau_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Optimiere VO2_slow und tau_slow\n        # Zuerst nach unten\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu reduzieren\n          if (current_VO2_slow &gt; 0.05) {\n            new_VO2_slow &lt;- max(0.05, current_VO2_slow - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu reduzieren\n          if (current_tau_slow &gt; 90) {\n            new_tau_slow &lt;- max(90, current_tau_slow - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_slow &lt;- new_tau_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Dann nach oben\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu erhöhen\n          if (current_VO2_slow &lt; 1.0) {  # Angenommen, 1.0 ist die obere Grenze für VO2_slow\n            new_VO2_slow &lt;- min(1.0, current_VO2_slow + 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu erhöhen\n          new_tau_slow &lt;- current_tau_slow + 0.1\n          new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n          if (new_rss &lt; current_rss) {\n            current_tau_slow &lt;- new_tau_slow\n            current_rss &lt;- new_rss\n            improved &lt;- TRUE\n          }\n          \n          if (!improved) break\n        }\n        \n        if (current_rss &lt; best_rss) {\n          best_rss &lt;- current_rss\n          best_t_delay_slow &lt;- t_delay_slow\n          best_VO2_fast &lt;- current_VO2_fast\n          best_tau_fast &lt;- current_tau_fast\n          best_VO2_slow &lt;- current_VO2_slow\n          best_tau_slow &lt;- current_tau_slow\n        }\n        \n        incProgress(1 / num_iterations, detail = paste(\"Iteration\", i, \"von\", num_iterations))\n      }\n    })\n    \n    if (!is.null(best_t_delay_slow)) {\n      updateSliderInput(session, \"time_delay_slow\", value = best_t_delay_slow)\n      updateSliderInput(session, \"VO2\", value = best_VO2_fast)\n      updateSliderInput(session, \"tau_fast\", value = best_tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = best_VO2_slow)\n      updateSliderInput(session, \"tau_slow\", value = best_tau_slow)\n      \n      predicted &lt;- VO2_Start + best_VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / best_tau_fast)) +\n        best_VO2_slow * (1 - exp(-(pmax(data_subset$t_s - best_t_delay_slow, 0)) / best_tau_slow))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 2 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"Fit fehlgeschlagen\",\n        \"Die Anpassung für die langsame Komponente konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_optimize, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$time_delay_slow)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Werte aus Schritt 2\n    VO2_step2 &lt;- input$VO2\n    tau_fast_step2 &lt;- input$tau_fast\n    VO2_slow_step2 &lt;- input$VO2_slow\n    tau_slow_step2 &lt;- input$tau_slow\n    t_delay_slow_step2 &lt;- input$time_delay_slow\n    \n    # Berechne R² für Schritt 2\n    step2_predicted &lt;- VO2_Start + VO2_step2 * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast_step2)) +\n      VO2_slow_step2 * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow_step2, 0)) / tau_slow_step2))\n    step2_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step2_predicted)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Optimierung läuft', value = 0, {\n      for (i in 1:1000) {\n        # Randomisierte Startwerte innerhalb der festgelegten Grenzen\n        VO2_start &lt;- runif(1, VO2_step2 * 0.98, VO2_step2 * 1.02)\n        tau_fast_start &lt;- runif(1, max(10, tau_fast_step2 - 3), tau_fast_step2 + 3)\n        VO2_slow_start &lt;- runif(1, VO2_slow_step2 * 0.98, VO2_slow_step2 * 1.02)\n        tau_slow_start &lt;- runif(1, max(90, tau_slow_step2 - 3), tau_slow_step2 + 3)\n        t_delay_slow_start &lt;- runif(1, max(0, t_delay_slow_step2 - 5), t_delay_slow_step2 + 5)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start,\n          VO2_slow = VO2_slow_start,\n          tau_slow = tau_slow_start,\n          t_delay_slow = t_delay_slow_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + \n                           VO2_slow * (1 - exp(-(t_s - t_delay_slow) / tau_slow)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = VO2_step2 * 0.98, \n                                   tau_fast = max(10, tau_fast_step2 - 3), \n                                   VO2_slow = VO2_slow_step2 * 0.98, \n                                   tau_slow = max(90, tau_slow_step2 - 3), \n                                   t_delay_slow = max(0, t_delay_slow_step2 - 5)),\n                         upper = c(VO2 = VO2_step2 * 1.02, \n                                   tau_fast = tau_fast_step2 + 3, \n                                   VO2_slow = VO2_slow_step2 * 1.02, \n                                   tau_slow = tau_slow_step2 + 3, \n                                   t_delay_slow = t_delay_slow_step2 + 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/1000, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      step3_predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast)) +\n        params$VO2_slow * (1 - exp(-(pmax(data_subset$t_s - params$t_delay_slow, 0)) / params$tau_slow))\n      step3_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step3_predicted)\n      \n      if (step3_r_squared &gt; step2_r_squared) {\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n        updateSliderInput(session, \"VO2_slow\", value = params$VO2_slow)\n        updateSliderInput(session, \"tau_slow\", value = params$tau_slow)\n        updateSliderInput(session, \"time_delay_slow\", value = params$t_delay_slow)\n        \n        current_r_squared(step3_r_squared)\n        showNotification(sprintf(\"Optimierung erfolgreich. Neues R²: %.3f\", step3_r_squared), type = \"message\")\n      } else {\n        current_r_squared(step2_r_squared)\n        showNotification(sprintf(\"Kein besserer Fit gefunden. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n      }\n    } else {\n      current_r_squared(step2_r_squared)\n      showNotification(sprintf(\"Optimierung fehlgeschlagen. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    req(input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$VO2_Start, input$time_delay, input$time_delay_slow, input$VO2_Ruhe)\n    \n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    VO2_slow &lt;- input$VO2_slow\n    tau_slow &lt;- input$tau_slow\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    t_delay_slow &lt;- input$time_delay_slow\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    \n    model_function &lt;- function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast)) + \n        pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0) + \n        VO2_Start\n    }\n    \n    model_fast &lt;- function(t_s, VO2, tau_fast, t_delay) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast))\n    }\n    \n    model_slow &lt;- function(t_s, VO2_slow, tau_slow, t_delay_slow) {\n      pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0)\n    }\n    \n    Beispieldaten &lt;- current_data()\n    \n    max_t &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$t_s, na.rm = TRUE) else 300\n    max_x &lt;- max_t * 1.20\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    \n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow), NA)\n    fast_values &lt;- ifelse(t_s &gt;= t_delay, model_fast(t_s, VO2, tau_fast, t_delay), NA)\n    slow_values &lt;- ifelse(t_s &gt;= t_delay_slow, model_slow(t_s, VO2_slow, tau_slow, t_delay_slow), NA)\n    \n    max_y &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05 else max(model_values, na.rm = TRUE) * 1.05\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * (1 - e&lt;sup&gt;-(t - %.0f) / %.1f&lt;/sup&gt;) + %.2f * (1 - e&lt;sup&gt;-(t - %.1f) / %.0f&lt;/sup&gt;) + %.2f\",\n                       VO2, t_delay, tau_fast, VO2_slow, t_delay_slow, tau_slow, VO2_Start)\n    t_halb &lt;- tau_fast * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = t_delay_slow, x1 = t_delay_slow, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'V̇O2-Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~fast_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~slow_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      layout(title = \"Biexponentielle V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".1f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.3,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.2,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = t_delay_slow, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay_slow&lt;/sub&gt;: %.1f\", t_delay_slow), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               )\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data() && !is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) {\n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n      \n      model_values_at_data &lt;- model_function(data_subset$t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow)\n      \n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, model_values_at_data)\n      current_r_squared(r_squared)\n      \n      current_r_squared(r_squared)  # Aktualisieren Sie die reaktive Variable\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n      \n      p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                  list(\n                                    list(\n                                      x = max_x * 0.35,\n                                      y = max_y * 0.10,\n                                      text = sprintf(\"R²: %.3f\", current_r_squared()),\n                                      showarrow = FALSE,\n                                      xanchor = 'left',\n                                      yanchor = 'bottom',\n                                      font = list(\n                                        family = \"Arial, sans-serif\",\n                                        size = 10,\n                                        color = \"black\"\n                                      )\n                                    )\n                                  ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n    &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n    &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n      &lt;li&gt;Beispiel-VO2-Daten (mit oder ohne Nachbelastung) einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n      &lt;li&gt;Ruhesauerstoffaufnahme (VO2 Ruhe) manuell eingeben oder anhand der Parameter (Geschlecht, Körpermasse, Alter, RQ) berechnen lassen.&lt;/li&gt;\n      &lt;li&gt;Bei Daten ohne Nachbelastung 'Mit VO2 Ruhe' wählen, bei Daten mit Nachbelastung 'VO2 Referenz' wählen und den entsprechenden Referenzwert festlegen.&lt;/li&gt;\n      &lt;li&gt;O2-Speicher festlegen oder auf 0 setzen, falls dieser in der Berechnung nicht berücksichtigt werden soll.&lt;/li&gt;\n      &lt;li&gt;Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n      &lt;li&gt;Wählen Sie zwischen 3-Schritt- oder 1-Schritt-Modellanpassung. Bei 3-Schritt-Anpassung den Zeitraum für simulierte Ruhe- bzw. Referenzwerte mit dem Slider einstellen.&lt;/li&gt;\n      &lt;li&gt;Modellanpassung durchführen:&lt;/li&gt;\n      &lt;ul&gt;\n        &lt;li&gt;'Fit: nlsLM' für komplette Anpassung oder&lt;/li&gt;\n        &lt;li&gt;Schrittweise: '1. Fit: Tau', '2. Fit: EPOC Slow', '3. Fit: EPOC Fast'&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;li&gt;Mit 'Ruhe_sim anzeigen' können simulierte Ruhewerte in der Abbildung ein- oder ausgeblendet werden.&lt;/li&gt;\n      &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n    &lt;/ol&gt;\n    &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n    &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n    &lt;/pre&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Schnelle Komponente (1. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast\nGrenzen:\n\nV̇O2_fast: 0.5 bis 7.0 l/min\ntau_fast: 10 bis 120 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n2. Langsame Komponente & Verfeinerung (2. Fit):\n\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nInitiale Werte (basierend auf Ozyener et al., 2001):\n\nV̇O2_slow: 0.4 l/min\ntau_slow: 160 s\n\nGrenzen:\n\nV̇O2_slow: 0.05 bis 1.0 l/min\ntau_slow: 90 bis Unendlich s\nt_delay_slow: tau_fast + t_delay bis max(t_s)\n\nProzess für t_delay_slow:\n\nBerechnung des Suchbereichs: von (tau_fast + t_delay) bis zum maximalen Zeitpunkt der Daten\nIteration durch jeden möglichen Wert in diesem Bereich (1-Sekunden-Schritte)\nFür jeden t_delay_slow-Wert:\n\nBerechnung der RSS mit festen Werten für V̇O2_slow (0.4 l/min) und tau_slow (160 s)\n\nAuswahl des t_delay_slow-Wertes mit der niedrigsten RSS\n\nOptimierung von V̇O2_fast und tau_fast:\n\nSchrittweise Reduzierung von V̇O2_fast (0.01 l/min) und tau_fast (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung bis keine Verbesserung mehr möglich\n\nOptimierung von V̇O2_slow und tau_slow:\n\nZunächst Reduzierung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nDann Erhöhung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung jeder Richtung bis keine Verbesserung mehr möglich\n\n\n3. Optimierung (3. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nGrenzen: Basierend auf den Ergebnissen von Schritt 2\n\nV̇O2_fast: ±2% des Wertes aus Schritt 2\ntau_fast: ±3 s des Wertes aus Schritt 2 (Minimum 10 s)\nV̇O2_slow: ±2% des Wertes aus Schritt 2\ntau_slow: ±3 s des Wertes aus Schritt 2 (Minimum 90 s)\nt_delay_slow: ±5 s des Wertes aus Schritt 2 (Minimum 0 s)\n\nProzess: 1000 Iterationen mit zufälligen Startwerten innerhalb der Grenzen\nOptimierung: Minimierung der RSS\n\n\n\n\n\n\n3 Anpassbarer und ausführbarer R-Code mit webR eines des Sauerstoffvolumenstrom-Verlaufs in Abhängigkeit von der Zeit während der Belastung\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "EPOC.html",
    "href": "EPOC.html",
    "title": "EPOC-Modellfunktion",
    "section": "",
    "text": "1 Modellfunktion des EPOC in Abhängigkeit von der Zeit während der Belastung\n#| standalone: true\n#| viewerHeight: 1200\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten ohne Nachbelastung \nt_data &lt;- c(3505.1, 3506.8, 3508.3, 3509.8, 3511.4, 3513.2, 3514.7, 3516.2, 3517.5, 3518.9, 3520.3, 3521.6, 3523.0, 3524.7, 3526.0, 3527.2, 3528.7, 3530.0, 3531.4, 3532.8, 3534.3, 3535.7, 3537.0, 3538.4, 3539.9, 3541.2, 3542.8, 3544.3, 3545.6, 3547.0, 3548.4, 3550.1, 3551.7, 3553.2, 3554.6, 3556.1, 3557.5, 3560.2, 3561.8, 3564.3, 3566.0, 3567.8, 3569.6, 3571.5, 3573.3, 3575.3, 3577.1, 3579.1, 3581.0, 3582.7, 3584.2, 3585.7, 3587.1, 3588.5, 3589.9, 3591.4, 3593.3, 3594.7, 3596.2, 3597.8, 3599.5, 3601.0, 3602.4, 3603.9, 3605.6, 3607.1, 3608.6, 3610.4, 3612.0, 3613.4, 3616.4, 3618.5, 3620.2, 3621.8, 3623.8, 3626.1, 3628.4, 3630.5, 3632.5, 3635.1, 3637.2, 3639.6, 3641.7, 3643.7, 3648.5, 3652.4, 3654.4, 3656.7, 3658.9, 3660.1, 3662.3, 3664.6, 3667.2, 3669.5, 3671.4, 3673.6, 3675.5, 3677.1, 3679.0, 3681.0, 3683.0, 3685.0, 3687.1, 3689.0, 3691.1, 3692.9, 3695.6, 3697.2, 3699.4, 3701.8, 3704.0, 3706.0, 3708.1, 3709.9, 3711.8, 3715.0, 3717.5, 3719.6, 3721.7, 3724.0, 3726.2, 3728.2, 3730.1, 3732.0, 3734.3, 3736.0, 3738.4, 3739.2, 3741.1, 3743.1, 3745.4, 3746.5, 3748.7, 3750.9, 3753.1, 3755.3, 3757.6, 3762.7, 3765.6, 3768.1, 3770.2, 3772.4, 3774.8, 3777.5, 3779.9, 3782.3, 3785.3, 3787.7, 3789.8, 3792.2, 3794.9, 3796.5, 3798.2, 3800.6, 3802.4, 3805.3, 3808.0, 3810.9, 3813.0, 3815.1, 3818.0, 3820.4, 3822.3, 3824.5, 3826.6, 3829.8, 3833.1, 3835.3, 3838.1, 3840.1, 3844.9, 3847.1, 3848.5, 3850.0, 3855.3, 3859.2, 3861.9, 3863.6, 3865.6, 3867.8, 3869.8, 3872.0, 3874.4, 3876.1, 3878.4, 3881.1, 3882.9, 3884.9, 3886.3, 3888.9, 3890.6, 3892.8, 3895.1, 3897.1, 3898.8, 3900.7, 3903.3, 3905.3, 3907.7, 3910.3, 3913.8, 3916.9, 3919.2, 3921.5, 3923.6, 3926.4, 3928.3, 3930.3, 3932.2, 3934.5, 3936.9, 3940.6, 3942.8, 3944.4, 3946.6, 3948.7, 3950.6, 3954.0, 3956.5, 3960.8, 3962.3, 3964.1, 3966.5, 3969.3, 3971.7, 3975.9, 3977.9, 3982.9, 3985.3, 3987.5, 3990.2, 3992.7, 3995.5, 3997.9, 4000.1, 4004.3, 4006.5, 4009.6, 4012.7, 4015.5, 4017.9, 4020.0, 4024.2, 4026.1, 4028.8, 4031.2, 4033.7, 4035.6, 4037.6, 4041.3, 4044.9, 4047.2, 4049.9, 4054.3, 4057.3, 4060.2, 4062.4, 4065.5, 4068.0, 4070.5, 4072.6, 4074.5, 4076.4, 4078.1, 4080.3, 4082.8, 4084.9)\nVO2_data &lt;- c(4.3916, 4.33868, 4.29972, 4.26048, 4.25328, 4.22856, 4.18768, 4.16656, 4.118, 4.06268, 4.00452, 3.9486, 3.85204, 3.81448, 3.74268, 3.67572, 3.61052, 3.5468, 3.47268, 3.37056, 3.25912, 3.20024, 3.17932, 3.13008, 3.08712, 2.97636, 2.95052, 2.891, 2.82488, 2.72496, 2.6324, 2.55344, 2.45564, 2.38944, 2.32268, 2.2388, 2.16588, 2.09852, 1.99972, 1.9584, 1.87604, 1.81076, 1.74984, 1.70644, 1.66456, 1.64564, 1.59204, 1.53048, 1.47084, 1.4078, 1.40632, 1.34116, 1.29948, 1.26596, 1.23048, 1.22116, 1.19188, 1.19668, 1.16332, 1.153, 1.15444, 1.14004, 1.14976, 1.15704, 1.15192, 1.15128, 1.14088, 1.1228, 1.11288, 1.10284, 1.07976, 1.07524, 1.0516, 1.0596, 1.0478, 1.03064, 1.03404, 1.01436, 1.01996, 1.02592, 0.99788, 1.00092, 0.96684, 0.98036, 0.96396, 0.96056, 0.94256, 0.93244, 0.92228, 0.9068, 0.90336, 0.88984, 0.87968, 0.88288, 0.85096, 0.84, 0.83584, 0.83428, 0.82228, 0.82996, 0.8382, 0.831, 0.86264, 0.83748, 0.83664, 0.8596, 0.8622, 0.86216, 0.85472, 0.85588, 0.8374, 0.84796, 0.84512, 0.85952, 0.84476, 0.8158, 0.8146, 0.80048, 0.77164, 0.7736, 0.76624, 0.77088, 0.77992, 0.80724, 0.80412, 0.80112, 0.8068, 0.78476, 0.79444, 0.79072, 0.78772, 0.79112, 0.79316, 0.79112, 0.78536, 0.7758, 0.76944, 0.77496, 0.76204, 0.7836, 0.79964, 0.81584, 0.85324, 0.85488, 0.89108, 0.904, 0.89116, 0.87828, 0.86268, 0.8416, 0.84192, 0.83324, 0.8332, 0.83228, 0.83992, 0.8094, 0.79928, 0.80512, 0.811, 0.82524, 0.82652, 0.8246, 0.80908, 0.80036, 0.80152, 0.81324, 0.79372, 0.76376, 0.78108, 0.76332, 0.75032, 0.78964, 0.78632, 0.78452, 0.78252, 0.77932, 0.78952, 0.78984, 0.7888, 0.77604, 0.79476, 0.8106, 0.79136, 0.76844, 0.73712, 0.7374, 0.74148, 0.75156, 0.74932, 0.7288, 0.72612, 0.75984, 0.76316, 0.76744, 0.76004, 0.75084, 0.70948, 0.70316, 0.68816, 0.70184, 0.6916, 0.681, 0.67276, 0.66776, 0.66792, 0.65952, 0.64368, 0.67064, 0.67144, 0.68348, 0.67592, 0.65776, 0.63996, 0.64432, 0.6382, 0.62112, 0.58896, 0.6054, 0.57796, 0.58432, 0.59236, 0.60632, 0.62372, 0.63128, 0.63308, 0.6444, 0.6382, 0.64336, 0.64684, 0.65508, 0.66076, 0.63596, 0.60768, 0.62748, 0.62472, 0.6284, 0.64236, 0.66068, 0.65004, 0.67312, 0.67836, 0.69416, 0.66368, 0.65028, 0.629, 0.62796, 0.60816, 0.61548, 0.61224, 0.62336, 0.61552, 0.62804, 0.63852, 0.64872, 0.641, 0.633, 0.64456, 0.66328, 0.6502, 0.65676, 0.66388, 0.6542, 0.63828, 0.64624, 0.63272, 0.65072, 0.64964)\n\n# Beispieldaten mit 50 Watt Nachbelastung \nt_data_50W &lt;- c(2552.6, 2554.0, 2555.6, 2557.1, 2558.7, 2560.3, 2562.0, 2563.7, 2565.4, 2567.0, 2568.6, 2570.0, 2571.5, 2572.8, 2574.6, 2576.1, 2577.5, 2579.0, 2580.5, 2582.7, 2584.2, 2586.3, 2587.7, 2589.0, 2590.8, 2592.2, 2594.2, 2595.8, 2597.4, 2599.1, 2600.6, 2602.1, 2603.6, 2605.3, 2606.9, 2608.5, 2610.3, 2612.6, 2613.9, 2615.6, 2617.2, 2618.8, 2621.5, 2623.0, 2625.5, 2627.3, 2628.9, 2630.3, 2631.9, 2633.3, 2635.0, 2636.5, 2638.2, 2639.9, 2641.5, 2643.0, 2644.9, 2646.6, 2648.3, 2649.8, 2651.3, 2652.9, 2654.5, 2656.3, 2658.2, 2660.1, 2661.9, 2663.7, 2665.4, 2667.0, 2669.1, 2670.9, 2672.6, 2674.4, 2676.1, 2678.0, 2679.9, 2681.6, 2683.1, 2684.7, 2685.7, 2687.1, 2690.9, 2692.6, 2695.9, 2697.7, 2698.9, 2701.2, 2703.0, 2705.0, 2706.7, 2708.5, 2710.3, 2711.8, 2713.4, 2715.1, 2716.7, 2718.2, 2719.8, 2721.3, 2723.2, 2725.4, 2727.1, 2729.0, 2730.8, 2732.4, 2733.9, 2735.4, 2737.4, 2739.1, 2741.2, 2743.1, 2746.2, 2747.8, 2749.5, 2751.3, 2753.0, 2755.0, 2757.3, 2759.5, 2761.7, 2763.6, 2765.7, 2767.8, 2769.3, 2770.8, 2772.2, 2774.3, 2776.1, 2777.7, 2779.3, 2781.1, 2783.0, 2786.2, 2787.9, 2789.5, 2791.4, 2793.2, 2795.0, 2796.8, 2798.5, 2800.4, 2802.0, 2804.0, 2805.9, 2807.8, 2809.5, 2812.5, 2814.2, 2816.4, 2818.5, 2821.0, 2822.8, 2824.7, 2826.5, 2828.5, 2830.5, 2831.9, 2833.4, 2835.0, 2836.6, 2838.8, 2840.5, 2842.4, 2844.1, 2846.2, 2848.4, 2851.5, 2853.3, 2855.3, 2858.8, 2861.1, 2863.4, 2865.8, 2868.2, 2870.2, 2872.7, 2875.1, 2877.3, 2879.4, 2883.0, 2884.8, 2887.1, 2888.6, 2891.0, 2893.1, 2895.0, 2896.8, 2898.9, 2900.8, 2903.5, 2905.3, 2907.2, 2909.2, 2911.5, 2913.4, 2915.6, 2917.4, 2919.2, 2921.4, 2923.8, 2925.5, 2927.5, 2929.7, 2932.9, 2935.1, 2937.1, 2939.6, 2941.4, 2943.8, 2945.9, 2948.6, 2950.7, 2952.7, 2956.5, 2958.8, 2961.0, 2962.6, 2964.9, 2966.5, 2967.7, 2969.9, 2971.3, 2973.1, 2975.5, 2977.4, 2979.5, 2981.4, 2983.5, 2985.5, 2988.0, 2990.2, 2992.4, 2994.5, 2998.4, 3000.1, 3002.2, 3004.5, 3007.0, 3008.6, 3010.9, 3013.3, 3015.8, 3017.5, 3019.1, 3021.1, 3023.5, 3025.5, 3027.8, 3029.6, 3030.7, 3033.6, 3035.9, 3038.1, 3040.4, 3042.4, 3046.1, 3048.6, 3050.9, 3053.4, 3055.2, 3057.3, 3059.2, 3061.3, 3063.1, 3065.5, 3067.7, 3069.6, 3071.9, 3074.3, 3076.4, 3078.2, 3080.2, 3082.2, 3084.0, 3086.9, 3089.5, 3092.9, 3095.6, 3098.2, 3100.8, 3103.1, 3106.6, 3108.5, 3110.5, 3113.1, 3115.6, 3121.1, 3124.1, 3127.0, 3129.7, 3132.6, 3134.2, 3136.4, 3138.8, 3141.6, 3144.1, 3146.2, 3149.5, 3152.2, 3154.6, 3157.2, 3159.6)\nVO2_data_50W &lt;- c(4.4001, 4.3817, 4.3121, 4.3409, 4.3439, 4.3299, 4.2480, 4.1318, 4.1017, 4.0326, 3.9826, 3.9325, 3.8651, 3.8096, 3.7446, 3.6772, 3.6132, 3.5336, 3.4854, 3.4446, 3.3776, 3.3045, 3.2331, 3.1704, 3.0984, 3.0216, 2.9686, 2.9386, 2.8810, 2.8061, 2.7353, 2.7127, 2.7239, 2.6456, 2.6377, 2.5957, 2.5540, 2.5138, 2.4619, 2.4145, 2.4251, 2.3901, 2.3788, 2.3462, 2.2943, 2.2786, 2.2648, 2.2418, 2.2427, 2.2392, 2.2386, 2.1912, 2.1595, 2.1360, 2.1111, 2.1224, 2.0777, 2.0514, 2.0310, 1.9780, 1.9727, 1.9440, 1.9551, 1.9516, 1.9462, 1.9169, 1.8937, 1.8818, 1.8560, 1.8333, 1.8018, 1.8064, 1.8136, 1.7820, 1.7528, 1.7488, 1.7494, 1.7520, 1.7599, 1.7941, 1.7951, 1.8142, 1.8182, 1.8387, 1.8880, 1.8747, 1.8848, 1.8750, 1.8730, 1.8576, 1.8532, 1.8552, 1.8566, 1.8779, 1.9174, 1.9636, 1.9640, 1.9728, 1.9767, 2.0114, 1.9866, 2.0298, 2.0401, 2.0414, 2.0417, 2.0099, 2.0261, 1.9837, 1.9544, 1.9402, 1.9313, 1.9273, 1.9265, 1.9295, 1.9441, 1.9727, 1.9943, 2.0044, 1.9720, 1.9654, 1.9225, 1.9068, 1.8688, 1.8623, 1.8394, 1.8563, 1.8187, 1.7995, 1.7750, 1.7498, 1.7746, 1.7715, 1.8122, 1.8389, 1.8352, 1.8090, 1.8296, 1.8238, 1.8328, 1.8290, 1.8123, 1.7960, 1.7923, 1.7896, 1.7622, 1.7592, 1.7674, 1.7858, 1.7950, 1.8137, 1.8496, 1.8495, 1.8664, 1.8851, 1.8865, 1.8747, 1.8502, 1.8631, 1.8322, 1.8341, 1.8650, 1.8490, 1.8762, 1.8531, 1.8437, 1.8368, 1.8438, 1.8350, 1.8540, 1.8645, 1.8486, 1.8179, 1.8006, 1.7843, 1.7765, 1.7372, 1.7319, 1.7322, 1.7202, 1.7160, 1.7033, 1.6818, 1.6498, 1.6551, 1.6361, 1.6277, 1.6271, 1.6044, 1.6204, 1.6176, 1.5965, 1.6116, 1.5948, 1.5813, 1.6099, 1.6333, 1.6588, 1.6799, 1.6902, 1.6858, 1.6819, 1.6689, 1.6550, 1.6356, 1.6488, 1.6722, 1.6864, 1.6533, 1.6580, 1.6782, 1.6916, 1.6921, 1.6927, 1.6946, 1.7046, 1.7356, 1.6985, 1.7132, 1.7104, 1.6868, 1.6894, 1.6880, 1.6834, 1.6632, 1.6246, 1.6189, 1.6194, 1.6530, 1.6906, 1.6982, 1.6821, 1.6484, 1.7026, 1.7012, 1.6998, 1.6902, 1.6894, 1.6715, 1.5961, 1.6080, 1.5906, 1.5955, 1.5864, 1.6033, 1.5882, 1.5746, 1.5551, 1.5417, 1.5668, 1.6209, 1.6475, 1.6627, 1.6290, 1.6070, 1.5852, 1.5877, 1.6354, 1.5954, 1.5910, 1.5767, 1.5835, 1.6019, 1.6368, 1.6969, 1.6874, 1.6751, 1.6753, 1.6987, 1.6867, 1.6964, 1.7220, 1.7142, 1.7196, 1.7078, 1.6907, 1.6628, 1.6343, 1.6318, 1.6129, 1.6256, 1.6123, 1.6096, 1.6335, 1.6262, 1.6195, 1.6204, 1.5709, 1.5486, 1.5559, 1.5600, 1.5710, 1.5819, 1.5609, 1.5808, 1.5985, 1.5951, 1.6267, 1.6258, 1.5771, 1.5974, 1.6163, 1.6230, 1.6052)\n\n# Normalisierung der t_data Werte auf 0\nt_data &lt;- t_data - t_data[1]\nt_data_50W &lt;- t_data_50W - t_data_50W[1]\n\n# Modellfunktion\nmodel_function &lt;- function(t_s, A, TauA, B, TauB, C, t_delay) {\n  A * exp(-(t_s - t_delay) / TauA) + B * exp(-(t_s - t_delay) / TauB) + C\n}\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  tags$head(\n    tags$style(HTML(\"\n      .reduced-margin { margin-bottom: 5px !important; }\n      .radio-buttons-compact { margin-top: -20px; }\n    \"))\n  ),\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"A\", \"A\", min = 0.0, max = 6, value = 2.2, step = 0.01),\n           sliderInput(\"TauA\", \"TauA\", min = 5, max = 90, value = 35, step = 0.10),\n           sliderInput(\"B\", \"B\", min = 0.0, max = 5, value = 0.8, step = 0.01),\n           sliderInput(\"TauB\", \"TauB\", min = 0.0, max = 1800, value = 180, step = 0.10),\n           sliderInput(\"C\", \"C\", min = 0.0, max = 3.0, value = 0.30, step = 0.01),\n           sliderInput(\"O2_Store\", \"O2-Speicher [l]\", min = 0, max = 1, value = 0.4, step = 0.01),\n           sliderInput(\"t_delay\", \"Zeitverzögerung [s]\", min = 0, max = 300, value = 0, step = 1),\n           sliderInput(\"VO2_Ruhe\", \"VO2 Ruhe [l · min^-1]\", min = 0.0, max = 1.0, value = 0.3, step = 0.001),\n           sliderInput(\"VO2_Referenz\", \"VO2 Referenz (50 Watt) [l · min^-1]\", min = 0.0, max = 2.0, value = 1.0, step = 0.001),\n           br(), \n           tags$h4(tags$strong(\"Beispieldaten einfügen:\")),\n           actionButton(\"show_data_ohne\", \"ohne Nachbelastung\"),\n           br(), \n           actionButton(\"show_data_50W\", \"50 Watt Nachbelastung\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modelanpassung:\")),\n           actionButton(\"fit_all\", \"nlsLM - Fit\"),\n           tags$h4(class = \"reduced-margin\", \"Optionen:\"),\n           div(class = \"radio-buttons-compact\",\n               radioButtons(\"fit_mit\", \"\", \n                            choices = c(\"mit VO2 Ruhe\" = \"ruhe\", \"mit VO2 Referenz\" = \"referenz\"),\n                            selected = \"referenz\")\n           ),\n           div(class = \"radio-buttons-compact\",\n               radioButtons(\"fit_steps\", \"\", \n                            choices = c(\"3 Schritte\" = \"three_steps\", \"1 Schritt\" = \"one_step\"),\n                            selected = \"three_steps\")\n           ),\n           h4(\"Schrittweise:\"),\n           actionButton(\"fit_tau\", \"1. Fit: Tau\"), br(),\n           actionButton(\"fit_slow\", \"2. Fit: EPOC Slow\"), br(),\n           actionButton(\"fit_full\", \"3. Fit: EPOC Fast\"),\n           br(), br(),\n           sliderInput(\"ruhe_sim_range\", \"Zeitraum der simulierten Ruhewerte [s]:\",\n                       min = 1200, max = 7200, value = c(3600, 4200), step = 100),\n           actionButton(\"toggle_view\", \"Ruhe_sim anzeigen\"),\n           br(), br(),\n           tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n           radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n           sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 90),\n           sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 193),\n           sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 27),\n           sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n           actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    column(8,\n           fluidRow(\n             column(12, plotlyOutput(\"plot\"))\n           ),\n           fluidRow(\n             column(12, htmlOutput(\"instructions\"))\n           )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  current_data &lt;- reactiveVal(NULL)\n  uploaded_data &lt;- reactiveVal(NULL)\n  tau_estimate &lt;- reactiveVal(NULL)\n  slow_estimates &lt;- reactiveVal(NULL)\n  show_full_view &lt;- reactiveVal(FALSE)\n  max_ruhe_t_s &lt;- reactiveVal(NULL)\n  ruhe_sim &lt;- reactiveVal(NULL)\n  fit_mode &lt;- reactive({\n    input$fit_steps\n  })\n  \n  observeEvent(input$show_data_ohne, {\n    show_data(TRUE)\n    current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n  })\n  \n  observeEvent(input$show_data_50W, {\n    show_data(TRUE)\n    current_data(data.frame(t_s = t_data_50W, VO2_t = VO2_data_50W))\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      if (df$t_s[1] != 0.0) {\n        df$t_s &lt;- df$t_s - df$t_s[1]\n      }\n      \n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die CSV-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Funktion zur Berechnung des Grundumsatzes\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  # Funktion zur Berechnung des RMR\n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2,Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  observeEvent(input$fit_tau, {\n    if (fit_mode() == \"three_steps\" && show_data()) {\n      Beispieldaten &lt;- current_data()\n      if (is.null(Beispieldaten)) return(p)\n      \n      t_delay &lt;- isolate(input$t_delay)\n      C &lt;- isolate(input$VO2_Ruhe)\n      \n      # Datenfilterung und Zeitverschiebung\n      filtered_data &lt;- Beispieldaten %&gt;%\n        filter(t_s &gt;= t_delay) %&gt;%\n        mutate(t_s = t_s - t_delay)\n      \n      model_tau &lt;- nlsLM(VO2_t ~ x * exp(-t_s/Tau) + C, \n                         data = filtered_data,\n                         start = list(x = max(filtered_data$VO2_t), Tau = 45, C = C),\n                         lower = c(x = 0, Tau = 10, C = 0),\n                         upper = c(x = Inf, Tau = 600, C = Inf),\n                         control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n      \n      tau_estimate(round(as.list(coef(model_tau))$Tau, 1))\n      \n      updateSliderInput(session, \"TauA\", value = tau_estimate())\n      updateSliderInput(session, \"A\", value = as.list(coef(model_tau))$x)\n      updateSliderInput(session, \"C\", value = as.list(coef(model_tau))$C)\n      \n      # Set B and TauB sliders to 0\n      updateSliderInput(session, \"B\", value = 0)\n      updateSliderInput(session, \"TauB\", value = 0)\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    if (fit_mode() == \"three_steps\") {\n      req(tau_estimate())\n      if (show_data()) {\n        Beispieldaten &lt;- current_data()\n        \n        VO2_Basis &lt;- if(input$fit_mit == \"ruhe\") input$VO2_Ruhe else input$VO2_Referenz\n        t_delay &lt;- isolate(input$t_delay)\n        max_VO2 &lt;- max(Beispieldaten$VO2_t) * 1.1\n        \n        tau2 &lt;- 2 * tau_estimate()\n        tau8 &lt;- 8 * tau_estimate()\n        last_data_point &lt;- max(Beispieldaten$t_s)\n        \n        actual_data_count &lt;- sum(Beispieldaten$t_s &gt;= tau2)\n        \n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        ruhe_sim_end &lt;- input$ruhe_sim_range[2]\n        \n        simulated_time_points &lt;- seq(ruhe_sim_start, ruhe_sim_end, length.out = actual_data_count)\n        \n        ruhe_sim_data &lt;- data.frame(\n          t_s = simulated_time_points,\n          VO2_t = rep(VO2_Basis, actual_data_count)  # Hier VO2_Basis statt VO2_Ruhe verwenden\n        )\n        \n        ruhe_sim(ruhe_sim_data)\n        max_ruhe_t_s(max(ruhe_sim_data$t_s))\n        \n        Beispieldaten_extended &lt;- rbind(Beispieldaten, ruhe_sim_data)\n        \n        filtered_data &lt;- Beispieldaten_extended %&gt;% \n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &gt;= tau2)\n        \n        model_slow &lt;- nlsLM(VO2_t ~ B * exp(-t_s/TauB) + VO2_Basis,\n                            data = filtered_data,\n                            start = list(B = 0.5, TauB = 540),\n                            lower = c(B = 0.1, TauB = 90),\n                            upper = c(B = (max_VO2 * 0.5), TauB = 3600),\n                            control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n        \n        slow_estimates_list &lt;- list(\n          B = as.numeric(coef(model_slow)[\"B\"]),\n          TauB = round(as.numeric(coef(model_slow)[\"TauB\"]), 1),\n          C = VO2_Basis\n        )\n        \n        slow_estimates(slow_estimates_list)\n        \n        updateSliderInput(session, \"B\", value = slow_estimates_list$B)\n        updateSliderInput(session, \"TauB\", value = slow_estimates_list$TauB)\n        updateSliderInput(session, \"C\", value = VO2_Basis)  # Hier VO2_Basis statt VO2_Ruhe verwenden\n      }\n    }\n  })\n  \n  observeEvent(input$fit_full, {\n    if (fit_mode() == \"three_steps\") {\n      req(tau_estimate(), slow_estimates())\n      if (show_data()) {\n        Beispieldaten &lt;- current_data()\n        \n        slow_est &lt;- slow_estimates()\n        t_delay &lt;- isolate(input$t_delay)\n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        \n        if (is.null(tau_estimate()) || is.null(slow_est)) {\n          showNotification(\"Einige Schätzwerte fehlen. Bitte führen Sie Schritt 1 und 2 erneut aus.\", type = \"error\")\n          return()\n        }\n        \n        start_params &lt;- list(\n          A = isolate(input$A),\n          TauA = tau_estimate()\n        )\n        \n        # Definiere eine Funktion mit festen Werten für B, TauB und C\n        model_func &lt;- function(t_s, A, TauA) {\n          A * exp(-t_s/TauA) + slow_est$B * exp(-t_s/slow_est$TauB) + slow_est$C\n        }\n        \n        # Berechne 2tau\n        tau2 &lt;- 2 * tau_estimate()\n        \n        # Datenfilterung und Zeitverschiebung\n        Beispieldaten_gefiltert &lt;- Beispieldaten %&gt;%\n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &lt; (ruhe_sim_start - t_delay))  # Entferne simulierte Ruhewerte\n        \n        # Erstelle Gewichte basierend auf t_s\n        weights &lt;- ifelse(Beispieldaten_gefiltert$t_s &lt;= tau2, 1, 1)\n        \n        tryCatch({\n          model_full &lt;- nlsLM(VO2_t ~ model_func(t_s, A, TauA),\n                              data = Beispieldaten_gefiltert,\n                              start = list(A = 2.5, TauA = 42),\n                              lower = c(A = 1.0, TauA = 15),\n                              upper = c(A = 4.0, TauA = 90),\n                              weights = weights,\n                              control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n          \n          full_estimates &lt;- list(\n            A = as.numeric(coef(model_full)[\"A\"]),\n            TauA = round(as.numeric(coef(model_full)[\"TauA\"]), 1)\n          )\n          \n          updateSliderInput(session, \"A\", value = full_estimates$A)\n          updateSliderInput(session, \"TauA\", value = full_estimates$TauA)\n          \n          showNotification(\"Fitting erfolgreich abgeschlossen\", type = \"message\")\n        }, error = function(e) {\n          showNotification(paste(\"Fehler beim Fitting:\", e$message), type = \"error\")\n        })\n      }\n    }\n  })\n  \n  observeEvent(input$toggle_view, {\n    show_full_view(!show_full_view())\n  })\n  \n  observeEvent(input$fit_all, {\n    if (show_data()) {\n      if (fit_mode() == \"three_steps\") {\n        # Trigger fit_tau\n        shinyjs::click(\"fit_tau\")\n        \n        # Warte kurz, bevor der nächste Fit ausgeführt wird\n        Sys.sleep(0.5)\n        \n        # Trigger fit_slow\n        shinyjs::click(\"fit_slow\")\n        \n        # Warte kurz, bevor der nächste Fit ausgeführt wird\n        Sys.sleep(0.5)\n        \n        # Trigger fit_full\n        shinyjs::click(\"fit_full\")\n        \n        showNotification(\"Alle Fits wurden nacheinander durchgeführt.\", type = \"message\")\n      } else if (fit_mode() == \"one_step\") {\n        Beispieldaten &lt;- current_data()\n        \n        t_delay &lt;- isolate(input$t_delay)\n        C &lt;- if(input$fit_mit == \"ruhe\") isolate(input$VO2_Ruhe) else isolate(input$VO2_Referenz)\n        \n        best_fit &lt;- NULL\n        best_rss &lt;- Inf\n        \n        withProgress(message = 'Fitting in progress', value = 0, {\n          for (i in 1:100) {\n            # Randomisierte Startwerte\n            A_start &lt;- runif(1, 1.5, 6)\n            TauA_start &lt;- runif(1, 20, 90)\n            B_start &lt;- runif(1, 0.3, 1.0)\n            TauB_start &lt;- runif(1, 300, 900)\n            \n            start_values &lt;- list(A = A_start, TauA = TauA_start, B = B_start, TauB = TauB_start)\n            \n            model_equation &lt;- VO2_t ~ A * exp(-(t_s - t_delay) / TauA) + B * exp(-(t_s - t_delay) / TauB) + C\n            \n            fit &lt;- try(nlsLM(model_equation,\n                             data = Beispieldaten,\n                             start = start_values,\n                             lower = c(A = 1.5, TauA = 20, B = 0.3, TauB = 90),\n                             upper = c(A = 6, TauA = 90, B = 3.0, TauB = 900),\n                             control = nls.control(maxiter = 1024)), silent = TRUE)\n            \n            if (!inherits(fit, \"try-error\")) {\n              rss &lt;- sum(residuals(fit)^2)\n              if (rss &lt; best_rss) {\n                best_rss &lt;- rss\n                best_fit &lt;- fit\n              }\n            }\n            \n            incProgress(1/100, detail = paste(\"Iteration\", i))\n          }\n        })\n        \n        if (!is.null(best_fit)) {\n          params &lt;- as.list(coef(best_fit))\n          updateSliderInput(session, \"A\", value = params$A)\n          updateSliderInput(session, \"TauA\", value = params$TauA)\n          updateSliderInput(session, \"B\", value = params$B)\n          updateSliderInput(session, \"TauB\", value = params$TauB)\n          \n          showNotification(\"Fitting completed successfully!\", type = \"message\")\n        } else {\n          showModal(modalDialog(\n            title = \"nlsLM fehlgeschlagen\",\n            \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n            easyClose = TRUE,\n            footer = NULL\n          ))\n        }\n      }\n    } else {\n      showNotification(\"Bitte fügen Sie zuerst Daten ein.\", type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A &lt;- input$A\n    TauA &lt;- input$TauA\n    B &lt;- input$B\n    TauB &lt;- input$TauB\n    C &lt;- if(input$fit_mit == \"ruhe\") input$VO2_Ruhe else input$VO2_Referenz\n    O2_Store &lt;- input$O2_Store\n    t_delay &lt;- input$t_delay\n    VO2_Basis &lt;- if(input$fit_mit == \"ruhe\") input$VO2_Ruhe else input$VO2_Referenz\n    \n    # Bestimmen des x-Achsen-Bereichs\n    x_range &lt;- if (show_full_view()) {\n      c(0, max_ruhe_t_s())\n    } else {\n      max_x_value &lt;- max(600, if (!is.null(current_data())) max(current_data()$t_s) else 600)\n      c(0, max_x_value * 1.1)  # Erhöhung um 10%\n    }\n    \n    max_x &lt;- max(max_ruhe_t_s(), 600 + 0.5 * TauB, max(t_data))\n    \n    Beispieldaten &lt;- current_data()\n    \n    if (!is.null(current_data())) {\n      max_y &lt;- max((A + B + C) * 1.1, max(current_data()$VO2_t) * 1.1)\n    } else {\n      max_y &lt;- (A + B + C) * 1.1\n    }\n    \n    t_s &lt;- seq(0, max_x, by = 1)\n    \n    model_values &lt;- A * exp(-t_s / TauA) + B * exp(-t_s / TauB) + C\n    model_fast &lt;- A * exp(-t_s / TauA)\n    model_slow &lt;- B * exp(-t_s / TauB)\n    model_ruhe &lt;- rep(C, length(t_s))\n    \n    model_fast_func &lt;- function(t_s) A * exp(-t_s / TauA)\n    integrated_model_fast &lt;- integrate(model_fast_func, lower = 0, upper = max(t_s))\n    \n    VO2_fast &lt;- integrated_model_fast$value / 60\n    CE_max &lt;- 21.1307796\n    WPCR &lt;- VO2_fast * CE_max\n    WPCR_corrected &lt;- ifelse(VO2_fast &lt; O2_Store, 0, (VO2_fast * CE_max) - (O2_Store * CE_max))\n    \n    cumulative_area &lt;- cumsum(A * exp(-t_s / TauA)) * diff(t_s)[1]\n    O2_Store_index &lt;- which.min(abs(cumulative_area - O2_Store * 60))\n    O2_Store_x &lt;- t_s[O2_Store_index]\n    \n    last_data_point &lt;- if (!is.null(current_data())) max(current_data()$t_s) else 0\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * e&lt;sup&gt;-t / %.1f&lt;/sup&gt; + %.2f * e&lt;sup&gt;-t / %.1f&lt;/sup&gt; + %.2f\", \n                       A, TauA, B, TauB, C)\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_fast, type = 'scatter', mode = 'lines', \n                name = 'EPOC&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_slow, type = 'scatter', mode = 'lines', \n                name = 'EPOC&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_ruhe, type = 'scatter', mode = 'lines', \n                name = 'C', line = list(color = '#1CADE4')) %&gt;%\n      add_ribbons(x = ~t_s, ymin = 0, ymax = ~model_fast, \n                  name = 'EPOC&lt;sub&gt;fast,Integriert&lt;/sub&gt;', fillcolor = 'rgba(66,186,151,0.5)', \n                  line = list(color = \"rgba(0,0,0,0)\")) %&gt;%\n      add_ribbons(x = ~t_s, ymin = 0, ymax = ~model_fast, \n                  data = data.frame(t_s = t_s[1:O2_Store_index], model_fast = model_fast[1:O2_Store_index]),\n                  fillcolor = 'rgba(0,131,143,0.3)', line = list(color = \"rgba(0,0,0,0)\", dash = \"dash\"), \n                  name = 'O&lt;sub&gt;2&lt;/sub&gt;-Speicher') %&gt;%\n      add_trace(x = c(O2_Store_x, O2_Store_x), y = c(0, max(model_fast[O2_Store_index])),\n                type = 'scatter', mode = 'lines', \n                line = list(color = \"#00838F\", width = 1, dash = \"dash\"),\n                name = 'O2 Store Linie', showlegend = FALSE) %&gt;%\n      add_segments(x = 2 * TauA, xend = 2 * TauA, y = 0, yend = max_y,\n                   line = list(color = \"gray\", width = 0.5, dash = \"dash\"),\n                   showlegend = FALSE) %&gt;%\n      layout(title = \"EPOC-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [s]\", range = x_range, autorange = FALSE),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = 2 * TauA, y = max_y * 0.75, text = sprintf(\"2tau: %.1f\", 2 * TauA), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11, color = \"darkgrey\")\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.85,\n                 text = paste(\"W&lt;sub&gt;PCR&lt;/sub&gt;:\", round(WPCR, 2), \"kJ\"),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.75,\n                 text = paste(\"W&lt;sub&gt;PCR, korrigiert&lt;/sub&gt;:\", round(WPCR_corrected, 2), \"kJ\"),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    if (show_data()) {\n      Beispieldaten &lt;- current_data()\n      if (!is.null(Beispieldaten)) {\n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        \n        # Datenfilterung und Zeitverschiebung\n        Beispieldaten &lt;- Beispieldaten %&gt;%\n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &lt; (ruhe_sim_start - t_delay))  # Entferne simulierte Ruhewerte\n        \n        last_data_point &lt;- max(Beispieldaten$t_s)\n        \n        # Füge last_data_point Linie und Annotation hinzu\n        p &lt;- p %&gt;% add_segments(x = last_data_point, xend = last_data_point, y = 0, yend = max_y,\n                                line = list(color = \"gray\", width = 0.5, dash = \"dash\"),\n                                showlegend = FALSE)\n        \n        p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                    list(\n                                      list(\n                                        x = last_data_point, y = max_y * 0.75, text = sprintf(\"t&lt;sub&gt;data_last&lt;/sub&gt;: %.1f\", last_data_point), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                                        textangle = -90, font = list(size = 11, color = \"darkgrey\")\n                                      )\n                                    ))\n        \n        model_values_at_data &lt;- A * exp(-Beispieldaten$t_s / TauA) + B * exp(-Beispieldaten$t_s / TauB) + C\n        \n        data_subset &lt;- Beispieldaten\n        \n        ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data)^2, na.rm = TRUE)\n        ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n        r_squared &lt;- 1 - (ss_res / ss_tot)\n        \n        p &lt;- p %&gt;%\n          add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                    name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                    marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                    line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n        \n        if (show_full_view()) {\n          ruhe_sim &lt;- data.frame(\n            t_s = seq(input$ruhe_sim_range[1], input$ruhe_sim_range[2], by = 1),\n            VO2_t = rep(VO2_Basis, input$ruhe_sim_range[2] - input$ruhe_sim_range[1] + 1)\n          )\n          \n          p &lt;- p %&gt;%\n            add_trace(data = ruhe_sim, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                      name = 'Sim. Ruhewerte', \n                      marker = list(color = '#1CADE4', size = 3.0),\n                      line = list(color = '#1CADE4', width = 0.5, dash = '4 4'))\n        }\n        \n        p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                    list(\n                                      list(\n                                        x = max_x * 0.10,\n                                        y = max_y * 0.65,\n                                        text = sprintf(\"R²: %.3f\", r_squared),\n                                        showarrow = FALSE,\n                                        xanchor = 'left',\n                                        yanchor = 'bottom',\n                                        font = list(\n                                          family = \"Arial, sans-serif\",\n                                          size = 12,\n                                          color = \"black\"\n                                        )\n                                      )\n                                    ))\n      }\n    }\n    \n    p\n  })\n  \n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px;'&gt;\n    &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n    &lt;ol style='color: #555;'&gt;\n      &lt;li&gt;Beispiel-VO2-Daten (mit oder ohne Nachbelastung) einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n      &lt;li&gt;Ruhesauerstoffaufnahme (VO2 Ruhe) manuell eingeben oder anhand der Parameter (Geschlecht, Körpermasse, Alter, RQ) berechnen lassen.&lt;/li&gt;\n      &lt;li&gt;Bei Daten ohne Nachbelastung 'Mit VO2 Ruhe' wählen, bei Daten mit Nachbelastung 'VO2 Referenz' wählen und den entsprechenden Referenzwert festlegen.&lt;/li&gt;\n      &lt;li&gt;O2-Speicher festlegen oder auf 0 setzen, falls dieser in der Berechnung nicht berücksichtigt werden soll.&lt;/li&gt;\n      &lt;li&gt;Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n      &lt;li&gt;Wählen Sie zwischen 3-Schritt- oder 1-Schritt-Modellanpassung. Bei 3-Schritt-Anpassung den Zeitraum für simulierte Ruhe- bzw. Referenzwerte mit dem Slider einstellen.&lt;/li&gt;\n      &lt;li&gt;Modellanpassung durchführen:&lt;/li&gt;\n      &lt;ul&gt;\n        &lt;li&gt;'Fit: nlsLM' für komplette Anpassung oder&lt;/li&gt;\n        &lt;li&gt;Schrittweise: '1. Fit: Tau', '2. Fit: EPOC Slow', '3. Fit: EPOC Fast'&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;li&gt;Mit 'Ruhe_sim anzeigen' können simulierte Ruhewerte in der Abbildung ein- oder ausgeblendet werden.&lt;/li&gt;\n      &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n    &lt;/ol&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nA. Dreischritt-Modellanpassung:\n\nSchnelle Komponente (1. Fit: Tau):\n\nVerwendete Funktion: nlsLM\nParameter: x (entspricht A), Tau (entspricht TauA)\nModell: VO2_t ~ x · exp(-t_s/Tau) + C\nGrenzen:\n\nx: 0 bis Inf\nTau: 10 bis 600 s\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\nLangsame Komponente (2. Fit: EPOC Slow):\n\nVerwendete Funktion: nlsLM\nParameter: B, TauB\nModell: VO2_t ~ B · exp(-t_s/TauB) + VO2_Basis\nGrenzen:\n\nB: 0.1 bis (VO2_max · 0.5) l/min\nTauB: 90 bis 3600 s\n\nProzess:\n\nDatenauswahl: Verwendung der Daten ab 2 · Tau\nErweiterung der Daten mit simulierten Ruhe- oder Referenzwerten:\n\nZeitraum: Festgelegter Bereich der simulierten Werte (Standard: 3600-4200s)\nAnzahl der simulierten Werte: Gleiche Anzahl wie reale Datenpunkte ab dem Zeitpunkt 2 · Tau bis zum Start der simulierten Werte\nWert: Konstant auf VO2_Ruhe oder VO2_Referenz (je nach Auswahl)\n\n\nOptimierung: Minimierung der RSS\n\nVollständige Anpassung (3. Fit: EPOC Fast):\n\nVerwendete Funktion: nlsLM\nParameter: A, TauA\nModell: VO2_t ~ A · exp(-t_s/TauA) + B · exp(-t_s/TauB) + C (B, TauB und C aus vorherigen Modellanpassungen)\nGrenzen:\n\nA: 1.0 bis 4.0 l/min\nTauA: 15 bis 90 s\n\nProzess:\n\nDatenauswahl: Verwendung der Daten bis zum Beginn der simulierten Ruhe- oder Referenzwerte\n\nOptimierung: Minimierung der RSS\n\n\nB. Einschritt-Modellanpassung:\n\nVerwendete Funktion: nlsLM\nParameter: A, TauA, B, TauB\nModell: VO2_t ~ A · exp(-(t_s - t_delay) / TauA) + B · exp(-(t_s - t_delay) / TauB) + C\nGrenzen:\n\nA: 1.5 bis 6.0 l/min\nTauA: 20 bis 90 s\nB: 0.3 bis 3.0 l/min\nTauB: 90 bis 900 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der RSS\nKeine Verwendung von simulierten Ruhe- oder Referenzwerten",
    "crumbs": [
      "EPOC-Modellfunktion"
    ]
  },
  {
    "objectID": "Laktat.html",
    "href": "Laktat.html",
    "title": "Laktat-Modellfunktionen",
    "section": "",
    "text": "1 Blutlaktat-Modellfunktion: Exponentieller Abfall nach dem Belastungsende\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Define data\nt_s &lt;- c(23, 127, 261, 422.5, 549.8, 664.5, 795.8, 1254.9)\nBLC_t &lt;- c(10.04, 7.49, 5.18, 3.9, 2.67, 2.18, 1.64, 0.98)\n\n# New model function: A * exp(-k * (t - delay)) + BLC0\nlaktat_model_function &lt;- function(t, A, k, BLC0, delay) {\n  A * exp(-k * (t - delay)) + BLC0\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"A\", \"A [mmol/l]\", min = 0.0, max = 15.0, value = 8.0, step = 0.1),\n      sliderInput(\"k\", \"k [s^-1]\", min = 0.0001, max = 0.02, value = 0.005, step = 0.0001),\n      sliderInput(\"BLC0\", \"BLC0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      sliderInput(\"delay\", \"Delay [s]\", min = 0, max = 3600, value = 0, step = 0.1),\n      actionButton(\"set_delay\", \"Delay auf BLC_1\"),\n      br(), br(),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server logic\nserver &lt;- function(input, output, session) {\n  # Reactive value for uploaded data\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Observer for CSV upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_s\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_s' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Observer for setting delay to first time point\n  observeEvent(input$set_delay, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    updateSliderInput(session, \"delay\", value = min(data$t_s))\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    delay &lt;- input$delay\n    \n    # Filter data points after the delay\n    data_filtered &lt;- data[data$t_s &gt; delay, ]\n    \n    if (nrow(data_filtered) &lt; 3) {\n      showNotification(\"Nicht genügend Datenpunkte nach dem Delay für den Fitting-Prozess.\", type = \"error\")\n      return()\n    }\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomized starting values\n        A_start &lt;- runif(1, 0, 15)\n        k_start &lt;- runif(1, 0.0001, 0.02)\n        BLC0_start &lt;- runif(1, 0, 5)\n        \n        start_values &lt;- list(A = A_start, k = k_start, BLC0 = BLC0_start)\n        \n        model_equation &lt;- BLC_t ~ A * exp(-k * (t_s - delay)) + BLC0\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data_filtered,\n                         start = start_values,\n                         lower = c(A = 0, k = 0.0001, BLC0 = 0),\n                         upper = c(A = 15, k = 0.02, BLC0 = 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"A\", value = params$A)\n      updateSliderInput(session, \"k\", value = params$k)\n      updateSliderInput(session, \"BLC0\", value = params$BLC0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A &lt;- input$A\n    k &lt;- input$k\n    BLC0 &lt;- input$BLC0\n    delay &lt;- input$delay\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_s) * 1.66\n    min_x &lt;- max(delay - 360, 0)\n    \n    t_s_modell &lt;- seq(min_x, max_x, length.out = 1000)\n    BLC_t_modell &lt;- laktat_model_function(t_s_modell, A, k, BLC0, delay)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.1, max(data$BLC_t) * 1.1)\n    \n    # Create equation text\n    eq_text &lt;- sprintf(\"BLC(t) = %.2f * e&lt;sup&gt;-%.4f*(t-%.2f)&lt;/sup&gt; + %.3f\", A, k, delay, BLC0)\n    \n    # Calculate R²\n    data_filtered &lt;- data[data$t_s &gt; delay, ]\n    BLC_t_modell_at_data &lt;- laktat_model_function(data_filtered$t_s, A, k, BLC0, delay)\n    ss_res &lt;- sum((data_filtered$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data_filtered$BLC_t - mean(data_filtered$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_s_modell[t_s_modell &gt;= delay], y = BLC_t_modell[t_s_modell &gt;= delay], \n                type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = t_s_modell[t_s_modell &lt; delay], y = BLC_t_modell[t_s_modell &lt; delay], \n                type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion (vor Delay)', line = list(color = '#EF6F6A', dash = 'dash')) %&gt;%\n      add_trace(x = data$t_s, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = '#42BA97', size = 10, symbol = 'x')) %&gt;%\n      add_segments(x = delay, xend = delay, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.75) %&gt;%\n      layout(title = \"Exponentielles Laktat-Abbaumodell\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [s]\", range = c(min_x, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Zeitverzögerung manuell setzen oder mit 'Delay auf BLC_1' die Zeitverzögerung auf den Zeitpunkt des ersten BLC-Wertes setzen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,BLC_t\n0.0,5.84\n90.0,3.60\n180.0,1.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nOptimierung (nlsLM - Fit):\n\nVerwendete Funktion: nlsLM\nParameter: A, k, BLC0\nModell: BLC_t ~ A · exp(-k · (t_s - delay)) + BLC0\nGrenzen:\n\nA: 0 bis 15 mmol/l\nk: 0.0001 bis 0.02 s^-1\nBLC0: 0 bis 5 mmol/l\n\nProzess:\n\nDatenauswahl:\n\nVerwendung der Daten nach dem eingestellten Delay-Wert\nÜberprüfung auf mindestens 3 Datenpunkte nach dem Delay\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · A: Zufallswert zwischen 0 und 15 · k: Zufallswert zwischen 0.0001 und 0.02 · BLC0: Zufallswert zwischen 0 und 5\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\n\n\n\n\n\n\n2 Blutlaktat-Bateman-Modellfunktion: Während und nach dem Belastungszeitraum\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Definiere Daten\nt_min &lt;- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)\nBLC_t &lt;- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)\n\n# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist\nif (min(t_min) &gt; 0.0) {\n  t_min &lt;- t_min - min(t_min)\n}\n\n# Bateman-Funktion für Laktatwerte (in Minuten) mit BLC0\nbateman_function &lt;- function(t, a, k1, k2, BLC0) {\n  BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t) - exp(-k2 * t))\n}\n\n# Invasions- und Eliminationsfunktionen\ninvasion_function &lt;- function(t, a, k1, BLC0) {\n  BLC0 + a * (1 - exp(-k1 * t))\n}\n\nelimination_function &lt;- function(t, a, k2, BLC0) {\n  BLC0 + a * exp(-k2 * t)\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"a\", \"a [mmol/l]\", min = 0.0, max = 30.0, value = 15.0, step = 0.01),\n      sliderInput(\"k1\", \"k1 [min^-1]\", min = 0.1, max = 3.5, value = 0.5, step = 0.001),\n      sliderInput(\"k2\", \"k2 [min^-1]\", min = 0.020, max = 0.200, value = 0.10, step = 0.001),\n      sliderInput(\"BLC0\", \"BLC0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server-Logik\nserver &lt;- function(input, output, session) {\n  \n  # Reaktiver Wert für hochgeladene Daten\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Beobachter für CSV-Upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_min\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      if (df$t_min[1] != 0.0) {\n        df$t_min &lt;- df$t_min - df$t_min[1]\n      }\n      \n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    # Setze BLC0 Grenzen basierend auf dem ersten BLC_t Wert\n    BLC0_lower &lt;- max(0, data$BLC_t[1] * 0.9)\n    BLC0_upper &lt;- min(5, data$BLC_t[1] * 1.1)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte\n        a_start &lt;- runif(1, 0, 30)\n        k1_start &lt;- runif(1, 0.1, 3.5)\n        k2_start &lt;- runif(1, 0.020, 0.200)\n        BLC0_start &lt;- runif(1, BLC0_lower, BLC0_upper)\n        \n        start_values &lt;- list(a = a_start, k1 = k1_start, k2 = k2_start, BLC0 = BLC0_start)\n        \n        model_equation &lt;- BLC_t ~ BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t_min) - exp(-k2 * t_min))\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data,\n                         start = start_values,\n                         lower = c(a = 0.0, k1 = 0.1, k2 = 0.020, BLC0 = BLC0_lower),\n                         upper = c(a = 30.0, k1 = 3.5, k2 = 0.200, BLC0 = BLC0_upper),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"a\", value = params$a)\n      updateSliderInput(session, \"k1\", value = params$k1)\n      updateSliderInput(session, \"k2\", value = params$k2)\n      updateSliderInput(session, \"BLC0\", value = params$BLC0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    a &lt;- input$a\n    k1 &lt;- input$k1\n    k2 &lt;- input$k2\n    BLC0 &lt;- input$BLC0\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_min) * 1.66\n    \n    t_min_modell &lt;- seq(0, max_x, length.out = 1000)\n    BLC_t_modell &lt;- bateman_function(t_min_modell, a, k1, k2, BLC0)\n    invasion_modell &lt;- invasion_function(t_min_modell, a, k1, BLC0)\n    elimination_modell &lt;- elimination_function(t_min_modell, a, k2, BLC0)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2, max(invasion_modell) * 1.2, max(elimination_modell) * 1.2)\n    \n    # Berechne tmax und Lamax\n    tmax &lt;- log(k1/k2) / (k1 - k2)\n    Lamax &lt;- bateman_function(tmax, a, k1, k2, BLC0)\n    \n    # Erstelle Gleichungstext\n    eq_text &lt;- sprintf(\"[La]&lt;sub&gt;b(t)&lt;/sub&gt; = %.2f + (%.2f * %.3f / (%.3f - %.3f)) * (e&lt;sup&gt;-%.3f*t&lt;/sup&gt; - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;)\", \n                       BLC0, a, k1, k2, k1, k1, k2)\n    \n    # Berechne R²\n    BLC_t_modell_at_data &lt;- bateman_function(data$t_min, a, k1, k2, BLC0)\n    ss_res &lt;- sum((data$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data$BLC_t - mean(data$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly-Plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', \n                name = 'Bateman-Funktion', line = list(color = '#EF5350')) %&gt;%\n      add_trace(x = t_min_modell, y = invasion_modell, type = 'scatter', mode = 'lines', \n                name = 'Invasion', line = list(color = \"#9C85C0\", width = 2, dash = '8 5'),\n                opacity = 0.65) %&gt;%\n      add_trace(x = t_min_modell, y = elimination_modell, type = 'scatter', mode = 'lines', \n                name = 'Elimination', line = list(color = '#2683C6', width = 2, dash = '8 5'),\n                opacity = 0.65) %&gt;%\n      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = \"#42BA97\", size = 9, symbol = 'x')) %&gt;%\n      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      layout(title = \"Bateman-Funktion für Laktat-Modellierung\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [min]\", range = c(0, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.85,\n                 text = sprintf(\"BLC&lt;sub&gt;max&lt;/sub&gt;: %.2f mmol/l\", Lamax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.80,\n                 text = sprintf(\"TBLC&lt;sub&gt;max&lt;/sub&gt;: %.2f min\",tmax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_min,BLC_t\n0.0,2.84\n1.5,3.60\n3.0,5.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: a, k1, k2, BLC0\nModell: BLC_t ~ BLC0 + (a · k1 / (k2 - k1)) · (exp(-k1 · t_min) - exp(-k2 · t_min))\nGrenzen:\n\na: 0.0 bis 30.0 mmol/l\nk1: 0.1 bis 3.5 min^-1\nk2: 0.020 bis 0.200 min^-1\nBLC0: 0.90 · BLC_t[1] bis 1.10 · BLC_t[1], begrenzt auf 0 bis 5 mmol/l\n\nProzess:\n\nBestimmung der BLC0-Grenzen:\n\nUntere Grenze: max(0, 0.90 · erster BLC-Wert)\nObere Grenze: min(5, 1.10 · erster BLC-Wert)\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · a: Zufallswert zwischen 0 und 30 · k1: Zufallswert zwischen 0.1 und 3.5 · k2: Zufallswert zwischen 0.020 und 0.200 · BLC0: Zufallswert zwischen der unteren und oberen BLC0-Grenze\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n3 Blutlaktat-Kompartmentmodell-Modellfunktion (nach Freund et al. 1986): Während und nach dem Belastungszeitraum\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Definiere Daten\nt_min &lt;- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)\nBLC_t &lt;- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)\n\n# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist\nif (min(t_min) &gt; 0.0) {\n  t_min &lt;- t_min - min(t_min)\n}\n\n# Freund et al. Kompartmentmodell-Funktion\nfreund_model &lt;- function(t, A1, A2, gamma1, gamma2, La0) {\n  La0 + A1 * (1 - exp(-gamma1 * t)) + A2 * (1 - exp(-gamma2 * t))\n}\n\n# Berechne tmax und Lamax\ncalculate_tmax_lamax &lt;- function(A1, A2, gamma1, gamma2, La0) {\n  f &lt;- function(t) freund_model(t, A1, A2, gamma1, gamma2, La0)\n  tmax &lt;- optimize(f, c(0, 100), maximum = TRUE)$maximum\n  Lamax &lt;- f(tmax)\n  list(tmax = tmax, Lamax = Lamax)\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"A1\", \"A1 [mmol/l]\", min = 0.0, max = 100.0, value = 20.0, step = 0.1),\n      sliderInput(\"A2\", \"A2 [mmol/l]\", min = -100.0, max = 0.0, value = -20.0, step = 0.1),\n      sliderInput(\"gamma1\", \"γ1 [min^-1]\", min = 0.05, max = 2.0, value = 0.1, step = 0.001),\n      sliderInput(\"gamma2\", \"γ2 [min^-1]\", min = 0.01, max = 0.5, value = 0.05, step = 0.001),\n      sliderInput(\"La0\", \"La0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server-Logik\nserver &lt;- function(input, output, session) {\n  \n  # Reaktiver Wert für hochgeladene Daten\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Beobachter für CSV-Upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_min\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      if (df$t_min[1] != 0.0) {\n        df$t_min &lt;- df$t_min - df$t_min[1]\n      }\n      \n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    # Setze La0 Grenzen basierend auf dem ersten BLC_t Wert\n    La0_lower &lt;- max(0, data$BLC_t[1] * 0.9)\n    La0_upper &lt;- min(5, data$BLC_t[1] * 1.1)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte\n        A1_start &lt;- runif(1, 0, 100)\n        A2_start &lt;- runif(1, -100, 0)\n        gamma1_start &lt;- runif(1, 0.05, 2)\n        gamma2_start &lt;- runif(1, 0.01, 0.5)\n        La0_start &lt;- runif(1, La0_lower, La0_upper)\n        \n        start_values &lt;- list(A1 = A1_start, A2 = A2_start, gamma1 = gamma1_start, gamma2 = gamma2_start, La0 = La0_start)\n        \n        model_equation &lt;- BLC_t ~ La0 + A1 * (1 - exp(-gamma1 * t_min)) + A2 * (1 - exp(-gamma2 * t_min))\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data,\n                         start = start_values,\n                         lower = c(A1 = 0.0, A2 = -100.0, gamma1 = 0.05, gamma2 = 0.01, La0 = La0_lower),\n                         upper = c(A1 = 100.0, A2 = 0.0, gamma1 = 2.0, gamma2 = 0.5, La0 = La0_upper),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"A1\", value = params$A1)\n      updateSliderInput(session, \"A2\", value = params$A2)\n      updateSliderInput(session, \"gamma1\", value = params$gamma1)\n      updateSliderInput(session, \"gamma2\", value = params$gamma2)\n      updateSliderInput(session, \"La0\", value = params$La0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A1 &lt;- input$A1\n    A2 &lt;- input$A2\n    gamma1 &lt;- input$gamma1\n    gamma2 &lt;- input$gamma2\n    La0 &lt;- input$La0\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_min) * 1.66\n    \n    t_min_modell &lt;- seq(0, max_x, length.out = 1000)\n    BLC_t_modell &lt;- freund_model(t_min_modell, A1, A2, gamma1, gamma2, La0)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2)\n    \n    # Berechne tmax und Lamax\n    results &lt;- calculate_tmax_lamax(A1, A2, gamma1, gamma2, La0)\n    tmax &lt;- results$tmax\n    Lamax &lt;- results$Lamax\n    \n    # Erstelle Gleichungstext\n    eq_text &lt;- sprintf(\"[La]&lt;sub&gt;b(t)&lt;/sub&gt; = %.2f + %.1f * (1 - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;) + %.1f * (1 - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;)\", \n                       La0, A1, gamma1, A2, gamma2)\n    \n    # Berechne R²\n    BLC_t_modell_at_data &lt;- freund_model(data$t_min, A1, A2, gamma1, gamma2, La0)\n    ss_res &lt;- sum((data$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data$BLC_t - mean(data$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly-Plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', \n                name = 'Modellgleichung', line = list(color = '#EF5350')) %&gt;%\n      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = \"#42BA97\", size = 9, symbol = 'x')) %&gt;%\n      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      layout(title = \"Freund et al. Kompartmentmodell für Laktat-Modellierung\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [min]\", range = c(0, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.85,\n                 text = sprintf(\"BLC&lt;sub&gt;max&lt;/sub&gt;: %.2f mmol/l\", Lamax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.80,\n                 text = sprintf(\"TBLC&lt;sub&gt;max&lt;/sub&gt;: %.2f min\",tmax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_min,BLC_t\n0.0,2.84\n1.5,3.60\n3.0,5.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: A1, A2, gamma1, gamma2, La0\nModell: BLC_t ~ La0 + A1 · (1 - exp(-gamma1 · t_min)) + A2 · (1 - exp(-gamma2 · t_min))\nGrenzen:\n\nA1: 0.0 bis 100.0 mmol/l\nA2: -100.0 bis 0.0 mmol/l\ngamma1: 0.05 bis 2.0 min^-1\ngamma2: 0.01 bis 0.5 min^-1\nLa0: 0.90 · BLC_t[1] bis 1.10 · BLC_t[1], begrenzt auf 0 bis 5 mmol/l\n\nProzess:\n\nBestimmung der La0-Grenzen:\n\nUntere Grenze: max(0, 0.90 · erster BLC-Wert)\nObere Grenze: min(5, 1.10 · erster BLC-Wert)\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · A1: Zufallswert zwischen 0 und 100 · A2: Zufallswert zwischen -100 und 0 · gamma1: Zufallswert zwischen 0.05 und 2.0 · gamma2: Zufallswert zwischen 0.01 und 0.5 · La0: Zufallswert zwischen der unteren und oberen La0-Grenze\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n4 Laktat-Leistungs-Beziehung\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Laktat-Leistungs-Modell\"),\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"num_rows\", \"Anzahl der Datenpunkte\", 4, min = 1, max = 20),\n      uiOutput(\"input_fields\"),\n      width = 2  \n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  # Initialwerte für die Leistung und ΔBLC\n  initial_values &lt;- list(\n    list(Leistung = 100, DeltaBLC = 0.3),\n    list(Leistung = 200, DeltaBLC = 1.0),\n    list(Leistung = 300, DeltaBLC = 2.8),\n    list(Leistung = 400, DeltaBLC = 8.0)\n  )\n  \n  # Dynamisch Input-Felder erzeugen\n  output$input_fields &lt;- renderUI({\n    num_rows &lt;- input$num_rows\n    \n    lapply(1:num_rows, function(i) {\n      initial_value &lt;- if (i &lt;= length(initial_values)) initial_values[[i]] else list(Leistung = 0, DeltaBLC = 0)\n      tagList(\n        numericInput(paste0(\"leistung_\", i), paste(\"Leistung\", i), value = initial_value$Leistung, step = 10),\n        numericInput(paste0(\"deltaBLC_\", i), paste(\"ΔBLC\", i), value = initial_value$DeltaBLC, step = 0.1)\n      )\n    })\n  })\n  \n  # Reaktive Datenframe basierend auf Eingabewerten\n  input_data &lt;- reactive({\n    num_rows &lt;- input$num_rows\n    if (is.null(num_rows)) return(NULL)\n    \n    data &lt;- data.frame(Leistung = numeric(num_rows), ΔBLC = numeric(num_rows))\n    \n    for (i in 1:num_rows) {\n      leistung_val &lt;- input[[paste0(\"leistung_\", i)]]\n      deltaBLC_val &lt;- input[[paste0(\"deltaBLC_\", i)]]\n      \n      if (is.null(leistung_val) || is.null(deltaBLC_val)) {\n        data$Leistung[i] &lt;- if (i &lt;= length(initial_values)) initial_values[[i]]$Leistung else 0\n        data$ΔBLC[i] &lt;- if (i &lt;= length(initial_values)) initial_values[[i]]$DeltaBLC else 0\n      } else {\n        data$Leistung[i] &lt;- leistung_val\n        data$ΔBLC[i] &lt;- deltaBLC_val\n      }\n    }\n    \n    data\n  })\n  \n  # Initiale Werte setzen\n  observe({\n    for (i in 1:length(initial_values)) {\n      updateNumericInput(session, paste0(\"leistung_\", i), value = initial_values[[i]]$Leistung)\n      updateNumericInput(session, paste0(\"deltaBLC_\", i), value = initial_values[[i]]$DeltaBLC)\n    }\n  })\n  \n  # Modell anpassen und Plot aktualisieren\n  output$plot &lt;- renderPlotly({\n    df_proband &lt;- input_data()\n    \n    if (is.null(df_proband)) return(NULL)\n    \n    # Anpassung des Exponentialmodells\n    model &lt;- nls(ΔBLC ~ a * exp(b * Leistung), data = df_proband, start = list(a = 1, b = 0.01))\n    coef_exponential_model &lt;- coef(model)\n    \n    # Vorhersagen und Sequenz für den Plot\n    x_seq &lt;- seq(min(df_proband$Leistung), max(df_proband$Leistung), length.out = 100)\n    y_pred &lt;- predict(model, newdata = data.frame(Leistung = x_seq))\n    \n    # Plotly-Diagramm\n    plot_ly() %&gt;%\n      add_trace(data = df_proband, x = ~Leistung, y = ~ΔBLC, type = 'scatter', mode = 'markers',\n                name = \"ΔBLC\",\n                marker = list(color = \"#2683C6\", size = 7.0)) %&gt;%\n      add_trace(x = x_seq, y = y_pred, type = 'scatter', mode = 'lines', \n                name = 'Laktat-Modellfunktion', \n                line = list(color = '#62A39F', width = 3)) %&gt;%\n      add_annotations(text = sprintf(\"ΔBLC = %.5f \\u00B7 e&lt;sup&gt;%.5f \\u00B7 Leistung&lt;/sup&gt;\", \n                                     coef_exponential_model['a'], coef_exponential_model['b']),\n                      x = min(df_proband$Leistung), y = max(y_pred), showarrow = FALSE,\n                      xanchor = 'left', yanchor = 'bottom',\n                      font = list(family = \"Arial, sans-serif\", size = 12, color = \"black\")) %&gt;%\n      layout(\n        title = \"Laktat-Leistungs-Modell\",\n        margin = list(t = 40),\n        xaxis = list(title = \"Leistung [Watt]\"),\n        yaxis = list(title = \"ΔBLC [mmol \\u00B7 l&lt;sup&gt;-1&lt;/sup&gt;]\")\n      )\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Anzahl der Datenpunkte bestimmen.&lt;/li&gt;\n          &lt;li&gt;Für jeden Datenpunkt die Leistung (in Watt) und den entsprechenden ΔBLC-Wert eingeben.&lt;/li&gt;\n          &lt;li&gt;Das exponentielle Modell wird automatisch an die eingegebenen Daten angepasst.&lt;/li&gt;\n        &lt;/ol&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Optimierung (nls - Fit):\n\nVerwendete Funktion: nls (Non-Linear Least Squares)\nParameter: a, b\nModell: ΔBLC ~ a · exp(b · Leistung)\nProzess:\n\nDatenaufbereitung:\n\nErstellung eines reaktiven Dataframes basierend auf den Benutzereingaben\n\nModellierung:\n\nAnwendung des nicht-linearen Regressionsmodells auf die eingegebenen Daten\nStartwerte:\n\na: 1.0\nb: 0.01\n\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung der Standard-nls-Funktion in R\nKeine expliziten Grenzen für die Parameter gesetzt\n\nErgebnisverarbeitung:\n\nExtraktion der Koeffizienten a und b aus dem angepassten Modell\n\nVisualisierung:\n\nErstellung einer Sequenz von Leistungswerten für glatte Kurvendarstellung\nBerechnung der vorhergesagten ΔBLC-Werte basierend auf dem Modell\nDarstellung der eingegebenen Datenpunkte und der Modellkurve\nAnzeige der Modellgleichung mit den angepassten Koeffizienten\n\n\nOptimierung: Minimierung der Summe der quadrierten Abweichungen (nls)",
    "crumbs": [
      "Laktat-Modellfunktionen"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Demo: Shinylive-Apps & webR",
    "section": "",
    "text": "In den folgenden Abschnitten werden Möglichkeiten zur interaktiven Gestaltung der Masterarbeit mittels verschiedener Shiny-Apps und webR-Anwendungen vorgestellt. Dazu zählt eine interaktive exponentielle V̇O₂-Modellfunktion, die den Anstieg des Sauerstoffvolumenstroms zu Beginn einer Belastung modelliert. Zudem wird eine interaktive bi-exponentielle EPOC-Modellfunktion dargestellt. Die unterschiedlichen Parameter der Modellfunktionen können mittels Schiebereglern angepasst werden. Darüber hinaus ist es möglich, eigene Daten in Form einer CSV-Datei hochzuladen. Zusätzlich ist eine interaktive Laktat-Leistungs-Beziehung in einer Shiny-App integriert, bei der die Datenpunkte ebenfalls interaktiv verändert werden können.\nDie automatische Anpassung mittels nichtlinearer Regression ist derzeit noch nicht funktionsfähig.\nIn der finalen Masterarbeit sollen weitere interaktive Shiny-Apps nach diesem Vorbild implementiert werden, um Berechnungen anschaulich darzustellen und die Nutzung sowie Berechnung verschiedener Parameter mit eigenen Daten zu ermöglichen.",
    "crumbs": [
      "Demo: Shinylive-Apps & webR"
    ]
  }
]