[
  {
    "objectID": "VO2.html",
    "href": "VO2.html",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Der Anstieg des Sauerstoffvolumenstroms (\\(\\dot{V}O_{2}\\)) zu Beginn einer leichten bis moderaten körperlichen Belastung auf dem Fahrradergometer unterhalb der Laktatschwelle (LT1) wurde traditionell in der Literatur als monoexponentiell beschrieben, mit einer Amplitude von ungefähr 9–10 ml O2·W-1·min-1 [@Barstow1991; @Bearden2000]. Die Zeitkonstante \\(\\tau_{\\text{Start}}\\) beschreibt die Geschwindigkeit, mit der der Sauerstoffvolumenstrom den Gleichgewichtszustand \\(\\dot{V}O_{2,\\text{gross, SS}}\\) erreicht. Dies lässt sich mit der folgenden Formel darstellen [@Hill1924; @Henry1956; @Margaria1965; @Whipp1971; @Oezyner2001; @Francescato2003; @Clark2014]:\n\\[\n\\dot{V}O_{2,\\text{Belastung}}(t) = \\dot{V}O_{2,\\text{gross, SS}} \\cdot \\left(1 - e^{-\\frac{t - TD}{\\tau_{\\text{Start}}}}\\right) + \\dot{V}O_{2,\\text{Start}}\n\\tag{1}\\]\nDabei beschreibt \\(\\dot{V}O_{2,\\text{Start}}\\) den Sauerstoffvolumenstrom zu Beginn der Belastung, und \\(\\dot{V}O_{2,\\text{net, SS}}\\) bezeichnet den Steady-State-Wert abzüglich des Ruhe-Sauerstoffvolumenstroms (\\(\\dot{V}O_{2, \\text{Ruhe}}\\)). In der folgenden Shiny-App wird ein Beispiel dieser Modellfunktion gezeigt, wie in Gleichung 1 beschrieben. Eigene \\(\\dot{V}O_{2}\\)-Daten können hochgeladen und mittels nichtlinearer Regression an die Beispieldaten angepasst werden.\n\n\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nProzess:\n\nBestimmung des V̇O2_Start-Wertes:\n\nFinden des nächstgelegenen Zeitpunkts zu t_delay in den Daten\nSetzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses Punktes\n\nDatenauswahl:\n\nVerwendung der Daten zwischen t_delay und nlsLM_end\n\nStartwertebestimmung:\n\nVerwendung der aktuellen Slider-Werte für V̇O2 und Tau\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung des Levenberg-Marquardt-Algorithmus\nMaximale Iterationen: 1024\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n\n\nDie Analyse der \\(\\dot{V}O_{2}\\)-Kinetik kann durch die Berücksichtigung von Zeitverzögerungen und/oder Exponentialfunktionen zweiter Ordnung verfeinert werden. Dazu kann die Anpassungsreaktion des \\(\\dot{V}O_{2}\\) nach Beginn der sportlichen Betätigung in drei Phasen unterteilt werden, wie in Abbildung 1 zu sehen [@Whipp1982]. Dies ermöglicht es, die erhöhte Komplexität der \\(\\dot{V}O_{2}\\)-Kinetik oberhalb der LT besser darzustellen und eine präzisere Analyse der physiologischen Anpassungen bei körperlicher Belastung durchzuführen, da oberhalb der LT der \\(\\dot{V}O_2\\)-Umsatz über 10 ml O2·W-1·min-1 steigt [@Barstow1994; @Bearden2000; @Siestema2020]. Die 3 Phasen lassen sich wie folgt beschreiben:\n\n\n\n\n\n\n\n\nAbbildung 1: Beispiel der Drei-Phasen der VO2-Kinetik bis zum Erreichen eines SS nach Beginn der Belastung (McNulty & Robergs, 2017)\n\n\n\n\n\n\n\n\n\n\n\nPhase 1: Phase I, häufig als kardiodynamische Phase bezeichnet, umfasst ungefähr die ersten 10 bis 25 Sekunden nach Beginn der Belastung. Aufgrund des schnellen Anstiegs des Herzzeitvolumens und des Lungenblutflusses zu Beginn der Belastung steigt \\(\\dot{V}O_2\\) abrupt an. In dieser Phase bleibt die Zusammensetzung des gemischtvenösen Blutes sowie der respiratorische Quotient (\\(RQ = \\frac{\\dot{V}CO_{2}}{\\dot{V}O_{2}}\\)) im Vergleich zum Ruhezustand unverändert. Somit ist der Anstieg des \\(\\dot{V}O_2\\) ausschließlich auf das erhöhte Herzminutenvolumen zurückzuführen, da sich die Sauerstoffkonzentration im arteriellen und venösen Blut (Ca und Cv) noch nicht verändert haben. Dies lässt sich mit Hilfe der Fick’schen Gleichung Gleichung 2 verdeutlichen [@Fick1855; @Whipp1982; @Stirling2005; @Clark2014; @Siestema2020].\n\\[\n\\dot{V}O_2 = \\dot{Q} \\cdot (C_a - C_v)\n\\tag{2}\\]\nDa die anfängliche „kardiodynamische“ Phase der \\(\\dot{V}O_2\\)-Reaktion nicht direkt den Sauerstoffumsatz der aktiven Muskulatur repräsentiert, werden in der Regel die ersten 20 bis 25 Sekunden von Phase I bei Modellierungen der \\(\\dot{V}O_2\\)-Kinetik aus der Modellanpassung ausgeschlossen [@Bearden2000; @Oezyener2001].\nPhase 2: Phase 2 folgt auf Phase 1 und ist durch einen schnellen, monoexponentiellen Anstieg des \\(\\dot{V}O_2\\) gekennzeichnet. Die Zeitkonstante beträgt im Durchschnitt etwa 30 [@Siestema2020] bis 33 Sekunden [@Oezyner2001]. Anschließend wird entweder ein SS erreicht oder der \\(\\dot{V}O_2\\) steigt weiter an, was dann in dem Modell als Phase 3 bezeichnet wird [@Stirling2005].\nPhase 3: In Phase 3 des \\(\\dot{V}O_2\\)-Modells wird bei leichten bis moderaten Belastungen unterhalb der Laktatschwelle (LT) nach etwa 3 Minuten ein stabiler Zustand (SS) erreicht. Dieses Verhalten beschreibt, wie der \\(\\dot{V}O_2\\) sich im 3-Phasen-Modell für Belastungen unterhalb der LT verhält. Bei Belastungen oberhalb der LT erreicht der \\(\\dot{V}O_2\\) nach der primären Anpassungsreaktion keinen SS mehr, sondern steigt weiter an (siehe Abbildung 2). Diese zusätzliche Komponente, meist als “slow component” bezeichnet und überlagert die anfängliche monoexponentielle Funktion aus Phase 2.\n\n\n\n\n\n\n\n\n\nAbbildung 2: Beispiele der VO2-Anstiegskinetik eines Probanden für verschiedene Belastungsintensitäten: sehr intensiv, schwer, mittelschwer und moderat (von oben nach unten). Unterhalb der VO2-Daten ist der entsprechende Residuenplot zu sehen. In Spalte A wird eine Modellfunktion mit mono-exponentieller Kurvenanpassung gezeigt, in Spalte B eine mit bi-exponentieller Anpassung (Özyener, 2001).\n\n\n\n\n\nMathematische Modellierungen haben gezeigt, dass die langsame Komponente etwa 90 bis 200 Sekunden nach Beginn des Übergangs einsetzt [@Whipp1972; @Barstow1991; @PatersonWhipp1991; @Whipp1994; @Bearden2000; @Siestema2020]. Die Komponente der Anpassungsreaktion bis zum Beginn der slow component wird in der Literatur oft als “primary component” oder “fundamental component” bezeichnet [@Barstow1994; @Oeyzener2001]. Im Folgenden wird diese Hauptkomponente mit dem Index “fast” gekennzeichnet.\n\n\n\nPhase 2 und 3 des 3-Phasen-Modells lassen sich mit Hilfe der Gleichung 3 modellieren:\n\\[\n\\dot{V}O_2(t) = \\dot{V}O_{2,\\text{fast}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay, fast}}{\\tau_\\text{fast}}}\\right) +\n\\dot{V}O_{2,\\text{slow}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay,slow}}{\\tau_\\text{slow}}}\\right) +\n\\dot{V}O_{2,\\text{Start}}\n\\tag{3}\\]\n\\(\\dot{V}O_{2,\\text{fast}}\\) repräsentiert die Amplitude der Hauptkomponente, während \\(\\dot{V}O_{2,\\text{slow}}\\) die Amplitude der slow component beschreibt. Die Zeitkonstanten \\(\\tau_\\text{fast}\\) und \\(\\tau_\\text{slow}\\) steuern die Geschwindigkeit der jeweiligen Reaktionsprozesse, wobei die Zeitverzögerungen \\(t_\\text{delay, fast}\\) und \\(t_\\text{delay, slow}\\) den Beginn dieser Prozesse bestimmen. \\(\\dot{V}O_{2,\\text{Start}}\\) beschreibt den Sauerstoffvolumenstrom zu Beginn der Belastung.\nIn der folgenden Shiny-App wird die Modellanpassung der Gleichung Gleichung 3 an Beispieldaten demonstriert. Eigene \\(\\dot{V}O_{2}\\)-Daten können hochgeladen und mittels nichtlinearer Regression an die Modellparameter angepasst werden.\n\n\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten\nt_data &lt;- c(0.0, 2.7, 5.3, 8.3, 11.5, 13.6, 15.4, 17.1, 19.8, 21.1, 22.3, 23.5, 24.9, 27.5, 30.9, 32.4, 35.0, 38.3, 39.7, 41.6, 43.7, 45.3, 46.8, 49.8, 52.0, 53.6, 55.5, 57.5, 59.0, 60.7, 62.4, 64.4, 66.6, 68.1, 69.8, 71.4, 73.3, 75.0, 76.7, 78.4, 80.0, 82.2, 83.9, 85.4, 87.3, 88.8, 90.6, 92.0, 93.6, 94.8, 96.3, 97.9, 99.5, 101.1, 102.7, 104.3, 106.0, 107.7, 109.3, 110.9, 112.5, 114.8, 116.4, 118.1, 119.7, 121.3, 122.8, 124.3, 125.9, 127.4, 128.9, 130.6, 132.1, 133.6, 135.6, 137.1, 138.6, 140.1, 141.6, 143.1, 144.4, 145.8, 147.2, 148.4, 149.9, 151.6, 153.1, 154.7, 156.1, 157.4, 158.7, 160.5, 161.9, 163.3, 164.7, 166.2, 167.6, 169.1, 172.6, 173.9, 175.4, 176.7, 178.1, 179.6, 181.0, 182.4, 183.8, 185.3, 186.7, 188.2, 189.6, 191.0, 192.4, 193.8, 195.2, 196.6, 198.0, 199.3, 200.7, 202.0, 203.3, 204.7, 206.1, 207.5, 208.8, 210.2, 211.6, 213.0, 214.3, 215.7, 217.1, 218.4, 219.8, 221.1, 222.4, 223.7, 225.0, 226.3, 227.7, 229.0, 230.5, 231.9, 233.1, 234.4)\nVO2_data &lt;- c(0.823, 0.898, 0.966, 1.122, 1.281, 1.313, 1.463, 1.537, 1.602, 1.595, 1.598, 1.674, 1.923, 2.168, 2.439, 2.670, 2.797, 2.712, 2.688, 2.968, 3.228, 3.371, 3.673, 3.938, 4.076, 3.959, 3.886, 3.880, 3.928, 3.962, 4.173, 4.381, 4.268, 4.208, 4.234, 4.132, 4.109, 4.192, 4.304, 4.493, 4.352, 4.349, 4.332, 4.346, 4.345, 4.373, 4.320, 4.286, 4.353, 4.346, 4.287, 4.322, 4.250, 4.332, 4.257, 4.161, 4.120, 4.144, 4.115, 4.158, 4.186, 4.206, 4.220, 4.259, 4.291, 4.279, 4.295, 4.339, 4.371, 4.425, 4.448, 4.474, 4.517, 4.536, 4.544, 4.528, 4.432, 4.371, 4.367, 4.430, 4.492, 4.535, 4.510, 4.433, 4.399, 4.305, 4.308, 4.304, 4.366, 4.434, 4.501, 4.535, 4.512, 4.463, 4.509, 4.529, 4.586, 4.624, 4.740, 4.769, 4.788, 4.794, 4.824, 4.830, 4.888, 4.887, 4.915, 4.924, 4.955, 4.965, 4.982, 4.992, 5.016, 5.024, 5.033, 5.066, 5.081, 5.053, 5.035, 4.997, 5.018, 5.038, 5.035, 5.039, 4.970, 4.970, 4.973, 4.964, 4.945, 4.953, 4.974, 4.984, 4.997, 4.995, 4.946, 4.997, 5.014, 5.092, 5.072, 5.111, 5.088, 5.065, 5.061, 5.038)\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  titlePanel(\"Bi-exponentielle V̇O2-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"VO2\", \"V̇O2_fast\", min = 0.0, max = 7.0, value = 3.7, step = 0.01),\n           sliderInput(\"tau_fast\", \"Tau_fast\", min = 10, max = 120, value = 45, step = 0.1),\n           sliderInput(\"VO2_Start\", \"V̇O2_Start\", min = 0.0, max = 4.0, value = 0.8, step = 0.01),\n           sliderInput(\"VO2_Ruhe\", \"V̇O2_Ruhe\", min = 0, max = 1, value = 0.4, step = 0.1),\n           sliderInput(\"time_delay\", \"Zeitverzögerung_fast\", min = 0, max = 600, value = 0, step = 1),\n           sliderInput(\"VO2_slow\", \"V̇O2_slow\", min = 0.0, max = 1.0, value = 0.3, step = 0.01),\n           sliderInput(\"tau_slow\", \"Tau_slow\", min = 90, max = 600, value = 110, step = 0.1),\n           sliderInput(\"time_delay_slow\", \"Zeitverzögerung_slow\", min = 0, max = 1200, value = 160, step = 1),\n           conditionalPanel(\n             condition = \"output.showFitSlider\",\n             sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = 300, value = 300, step = 1)\n           ),\n           actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modellanpassung:\")),\n           actionButton(\"fit_fast\", \"1. Fit: Schnelle Komponente\"),br(),\n           actionButton(\"fit_slow\", \"2. Fit: Langsame Komponente & Verfeinerung\"),br(),\n           actionButton(\"fit_optimize\", \"3. Fit: Optimierung\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  current_data &lt;- reactiveVal(NULL)\n  current_r_squared &lt;- reactiveVal(NA)\n  \n  calculate_r_squared &lt;- function(observed, predicted) {\n    ss_res &lt;- sum((observed - predicted)^2, na.rm = TRUE)\n    ss_tot &lt;- sum((observed - mean(observed, na.rm = TRUE))^2, na.rm = TRUE)\n    return(1 - (ss_res / ss_tot))\n  }\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    if (show_data()) {\n      current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n    } else {\n      current_data(NULL)\n    }\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observe({\n    req(input$VO2_Start, input$VO2_Ruhe)\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  # Hilfsfunktion zur Bestimmung des nächstgelegenen VO2-Wertes\n  find_nearest_VO2 &lt;- function(data, t_delay) {\n    req(data, t_delay)\n    if (nrow(data) == 0) return(NA)\n    \n    index &lt;- which.min(abs(data$t_s - t_delay))\n    return(data$VO2_t[index])\n  }\n  \n  \n  observeEvent(input$fit_fast, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    t_delay &lt;- isolate(input$time_delay)\n    \n    # Bestimme den nächstgelegenen VO2-Wert als VO2_Start\n    VO2_Start &lt;- find_nearest_VO2(Beispieldaten, t_delay)\n    \n    # Aktualisiere den VO2_Start Slider\n    updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte innerhalb der Slider-Grenzen\n        VO2_start &lt;- runif(1, 0.5, 7.0)\n        tau_fast_start &lt;- runif(1, 10, 120)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = 0.5, tau_fast = 10),\n                         upper = c(VO2 = 7.0, tau_fast = 120),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"VO2\", value = params$VO2)\n      updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = 0)\n      updateSliderInput(session, \"tau_slow\", value = 0)\n      \n      predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 1 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    \n    # Setze VO2_slow und tau_slow auf die initialen Werte\n    VO2_slow &lt;- 0.4\n    tau_slow &lt;- 160\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Berechne die obere Grenze für t_delay_slow\n    t_delay_slow_upper &lt;- max(Beispieldaten$t_s)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    best_t_delay_slow &lt;- NULL\n    best_VO2_fast &lt;- VO2\n    best_tau_fast &lt;- tau_fast\n    best_VO2_slow &lt;- VO2_slow\n    best_tau_slow &lt;- tau_slow\n    \n    # Berechne die Anzahl der Iterationen für t_delay_slow\n    num_iterations &lt;- floor(t_delay_slow_upper - (tau_fast + t_delay)) + 1\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:num_iterations) {\n        t_delay_slow &lt;- tau_fast + t_delay + i - 1\n        \n        # Fit VO2_fast und tau_fast nach unten\n        current_VO2_fast &lt;- best_VO2_fast\n        current_tau_fast &lt;- best_tau_fast\n        current_VO2_slow &lt;- best_VO2_slow\n        current_tau_slow &lt;- best_tau_slow\n        \n        model &lt;- function(VO2_fast, tau_fast, VO2_slow, tau_slow, t_delay_slow) {\n          VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast)) + \n            VO2_slow * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow, 0)) / tau_slow)) + \n            VO2_Start\n        }\n        \n        current_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n        \n        # Optimiere VO2_fast und tau_fast\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_fast zu reduzieren\n          if (current_VO2_fast &gt; 0.1) {\n            new_VO2_fast &lt;- max(0.1, current_VO2_fast - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(new_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_fast &lt;- new_VO2_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_fast zu reduzieren\n          if (current_tau_fast &gt; 10) {\n            new_tau_fast &lt;- max(10, current_tau_fast - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, new_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_fast &lt;- new_tau_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Optimiere VO2_slow und tau_slow\n        # Zuerst nach unten\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu reduzieren\n          if (current_VO2_slow &gt; 0.05) {\n            new_VO2_slow &lt;- max(0.05, current_VO2_slow - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu reduzieren\n          if (current_tau_slow &gt; 90) {\n            new_tau_slow &lt;- max(90, current_tau_slow - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_slow &lt;- new_tau_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Dann nach oben\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu erhöhen\n          if (current_VO2_slow &lt; 1.0) {  # Angenommen, 1.0 ist die obere Grenze für VO2_slow\n            new_VO2_slow &lt;- min(1.0, current_VO2_slow + 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu erhöhen\n          new_tau_slow &lt;- current_tau_slow + 0.1\n          new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n          if (new_rss &lt; current_rss) {\n            current_tau_slow &lt;- new_tau_slow\n            current_rss &lt;- new_rss\n            improved &lt;- TRUE\n          }\n          \n          if (!improved) break\n        }\n        \n        if (current_rss &lt; best_rss) {\n          best_rss &lt;- current_rss\n          best_t_delay_slow &lt;- t_delay_slow\n          best_VO2_fast &lt;- current_VO2_fast\n          best_tau_fast &lt;- current_tau_fast\n          best_VO2_slow &lt;- current_VO2_slow\n          best_tau_slow &lt;- current_tau_slow\n        }\n        \n        incProgress(1 / num_iterations, detail = paste(\"Iteration\", i, \"von\", num_iterations))\n      }\n    })\n    \n    if (!is.null(best_t_delay_slow)) {\n      updateSliderInput(session, \"time_delay_slow\", value = best_t_delay_slow)\n      updateSliderInput(session, \"VO2\", value = best_VO2_fast)\n      updateSliderInput(session, \"tau_fast\", value = best_tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = best_VO2_slow)\n      updateSliderInput(session, \"tau_slow\", value = best_tau_slow)\n      \n      predicted &lt;- VO2_Start + best_VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / best_tau_fast)) +\n        best_VO2_slow * (1 - exp(-(pmax(data_subset$t_s - best_t_delay_slow, 0)) / best_tau_slow))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 2 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"Fit fehlgeschlagen\",\n        \"Die Anpassung für die langsame Komponente konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_optimize, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$time_delay_slow)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Werte aus Schritt 2\n    VO2_step2 &lt;- input$VO2\n    tau_fast_step2 &lt;- input$tau_fast\n    VO2_slow_step2 &lt;- input$VO2_slow\n    tau_slow_step2 &lt;- input$tau_slow\n    t_delay_slow_step2 &lt;- input$time_delay_slow\n    \n    # Berechne R² für Schritt 2\n    step2_predicted &lt;- VO2_Start + VO2_step2 * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast_step2)) +\n      VO2_slow_step2 * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow_step2, 0)) / tau_slow_step2))\n    step2_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step2_predicted)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Optimierung läuft', value = 0, {\n      for (i in 1:1000) {\n        # Randomisierte Startwerte innerhalb der festgelegten Grenzen\n        VO2_start &lt;- runif(1, VO2_step2 * 0.98, VO2_step2 * 1.02)\n        tau_fast_start &lt;- runif(1, max(10, tau_fast_step2 - 3), tau_fast_step2 + 3)\n        VO2_slow_start &lt;- runif(1, VO2_slow_step2 * 0.98, VO2_slow_step2 * 1.02)\n        tau_slow_start &lt;- runif(1, max(90, tau_slow_step2 - 3), tau_slow_step2 + 3)\n        t_delay_slow_start &lt;- runif(1, max(0, t_delay_slow_step2 - 5), t_delay_slow_step2 + 5)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start,\n          VO2_slow = VO2_slow_start,\n          tau_slow = tau_slow_start,\n          t_delay_slow = t_delay_slow_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + \n                           VO2_slow * (1 - exp(-(t_s - t_delay_slow) / tau_slow)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = VO2_step2 * 0.98, \n                                   tau_fast = max(10, tau_fast_step2 - 3), \n                                   VO2_slow = VO2_slow_step2 * 0.98, \n                                   tau_slow = max(90, tau_slow_step2 - 3), \n                                   t_delay_slow = max(0, t_delay_slow_step2 - 5)),\n                         upper = c(VO2 = VO2_step2 * 1.02, \n                                   tau_fast = tau_fast_step2 + 3, \n                                   VO2_slow = VO2_slow_step2 * 1.02, \n                                   tau_slow = tau_slow_step2 + 3, \n                                   t_delay_slow = t_delay_slow_step2 + 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/1000, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      step3_predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast)) +\n        params$VO2_slow * (1 - exp(-(pmax(data_subset$t_s - params$t_delay_slow, 0)) / params$tau_slow))\n      step3_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step3_predicted)\n      \n      if (step3_r_squared &gt; step2_r_squared) {\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n        updateSliderInput(session, \"VO2_slow\", value = params$VO2_slow)\n        updateSliderInput(session, \"tau_slow\", value = params$tau_slow)\n        updateSliderInput(session, \"time_delay_slow\", value = params$t_delay_slow)\n        \n        current_r_squared(step3_r_squared)\n        showNotification(sprintf(\"Optimierung erfolgreich. Neues R²: %.3f\", step3_r_squared), type = \"message\")\n      } else {\n        current_r_squared(step2_r_squared)\n        showNotification(sprintf(\"Kein besserer Fit gefunden. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n      }\n    } else {\n      current_r_squared(step2_r_squared)\n      showNotification(sprintf(\"Optimierung fehlgeschlagen. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    req(input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$VO2_Start, input$time_delay, input$time_delay_slow, input$VO2_Ruhe)\n    \n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    VO2_slow &lt;- input$VO2_slow\n    tau_slow &lt;- input$tau_slow\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    t_delay_slow &lt;- input$time_delay_slow\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    \n    model_function &lt;- function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast)) + \n        pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0) + \n        VO2_Start\n    }\n    \n    model_fast &lt;- function(t_s, VO2, tau_fast, t_delay) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast))\n    }\n    \n    model_slow &lt;- function(t_s, VO2_slow, tau_slow, t_delay_slow) {\n      pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0)\n    }\n    \n    Beispieldaten &lt;- current_data()\n    \n    max_t &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$t_s, na.rm = TRUE) else 300\n    max_x &lt;- max_t * 1.20\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    \n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow), NA)\n    fast_values &lt;- ifelse(t_s &gt;= t_delay, model_fast(t_s, VO2, tau_fast, t_delay), NA)\n    slow_values &lt;- ifelse(t_s &gt;= t_delay_slow, model_slow(t_s, VO2_slow, tau_slow, t_delay_slow), NA)\n    \n    max_y &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05 else max(model_values, na.rm = TRUE) * 1.05\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * (1 - e&lt;sup&gt;-(t - %.0f) / %.1f&lt;/sup&gt;) + %.2f * (1 - e&lt;sup&gt;-(t - %.1f) / %.0f&lt;/sup&gt;) + %.2f\",\n                       VO2, t_delay, tau_fast, VO2_slow, t_delay_slow, tau_slow, VO2_Start)\n    t_halb &lt;- tau_fast * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = t_delay_slow, x1 = t_delay_slow, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'V̇O2-Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~fast_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~slow_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      layout(title = \"Bi-exponentielle V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".1f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.3,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.2,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = t_delay_slow, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay_slow&lt;/sub&gt;: %.1f\", t_delay_slow), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               )\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data() && !is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) {\n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n      \n      model_values_at_data &lt;- model_function(data_subset$t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow)\n      \n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, model_values_at_data)\n      current_r_squared(r_squared)\n      \n      current_r_squared(r_squared)  # Aktualisieren Sie die reaktive Variable\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n      \n      p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                  list(\n                                    list(\n                                      x = max_x * 0.35,\n                                      y = max_y * 0.10,\n                                      text = sprintf(\"R²: %.3f\", current_r_squared()),\n                                      showarrow = FALSE,\n                                      xanchor = 'left',\n                                      yanchor = 'bottom',\n                                      font = list(\n                                        family = \"Arial, sans-serif\",\n                                        size = 10,\n                                        color = \"black\"\n                                      )\n                                    )\n                                  ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n      &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n      &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n        &lt;li&gt;Beispiel-VO2-Daten einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n        &lt;li&gt;Zeitverzögerung_fast festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n        &lt;li&gt;Schrittweise die Modellanpassung durchführen:\n          &lt;ol&gt;\n            &lt;li&gt;Fit: Schnelle Komponente&lt;/li&gt;\n            &lt;li&gt;Fit: Langsame Komponente Verfeinerung&lt;/li&gt;\n            &lt;li&gt;Fit: Optimierung&lt;/li&gt;\n          &lt;/ol&gt;\n        &lt;/li&gt;\n        &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n      &lt;/ol&gt;\n      &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n      &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n      &lt;/pre&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Schnelle Komponente (1. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast\nGrenzen:\n\nV̇O2_fast: 0.5 bis 7.0 l/min\ntau_fast: 10 bis 120 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n2. Langsame Komponente & Verfeinerung (2. Fit):\n\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nInitiale Werte (basierend auf Ozyener et al., 2001):\n\nV̇O2_slow: 0.4 l/min\ntau_slow: 160 s\n\nGrenzen:\n\nV̇O2_slow: 0.05 bis 1.0 l/min\ntau_slow: 90 bis Unendlich s\nt_delay_slow: tau_fast + t_delay bis max(t_s)\n\nProzess für t_delay_slow:\n\nBerechnung des Suchbereichs: von (tau_fast + t_delay) bis zum maximalen Zeitpunkt der Daten\nIteration durch jeden möglichen Wert in diesem Bereich (1-Sekunden-Schritte)\nFür jeden t_delay_slow-Wert:\n\nBerechnung der RSS mit festen Werten für V̇O2_slow (0.4 l/min) und tau_slow (160 s)\n\nAuswahl des t_delay_slow-Wertes mit der niedrigsten RSS\n\nOptimierung von V̇O2_fast und tau_fast:\n\nSchrittweise Reduzierung von V̇O2_fast (0.01 l/min) und tau_fast (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung bis keine Verbesserung mehr möglich\n\nOptimierung von V̇O2_slow und tau_slow:\n\nZunächst Reduzierung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nDann Erhöhung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung jeder Richtung bis keine Verbesserung mehr möglich\n\n\n3. Optimierung (3. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nGrenzen: Basierend auf den Ergebnissen von Schritt 2\n\nV̇O2_fast: ±2% des Wertes aus Schritt 2\ntau_fast: ±3 s des Wertes aus Schritt 2 (Minimum 10 s)\nV̇O2_slow: ±2% des Wertes aus Schritt 2\ntau_slow: ±3 s des Wertes aus Schritt 2 (Minimum 90 s)\nt_delay_slow: ±5 s des Wertes aus Schritt 2 (Minimum 0 s)\n\nProzess: 1000 Iterationen mit zufälligen Startwerten innerhalb der Grenzen\nOptimierung: Minimierung der RSS\n\n\n\n\n\n\n\n\nIn dieser Arbeit wurde der Anstieg des \\(\\dot{V}O_{2}\\) nach Belastungsbeginn für jede Belastungsstufe wie folgt analysiert: Zunächst wurden aus den Atemzug-für-Atemzug \\(\\dot{V}O_{2}\\)-Daten die Ausreißer entfernt. Danach erfolgte eine Glättung der Daten mittels eines gleitenden 3-Atemzug-Durchschnitts, gefolgt von der Kurvenanpassung.\nVor der Kurvenanpassung wurde die Zeitverzögerung der Hauptkomponente des \\(\\dot{V}O_{2}\\) grafisch so bestimmt, dass die Phase-I-Daten der kardiorespiratorischen Antwort nicht einbezogen wurden. Dies entsprach in der Regel dem von [@Bearden2000; @Stirling2005] beschriebenen Zeitraum von 10-25 Sekunden für Phase 1. Die Kurvenanpassung wurde anschließend mit Gleichung 3 an die jeweiligen Daten durchgeführt. Die Modellparameter der Kurvenanpassung wurden wie folgt gewählt: ::: {.callout-note icon=false collapse=true appearance=“simple”} ### Parameter - Kurvenanpassung: - Verwendete Funktion: nlsLM * Maximale Iterationen: 1024 * Verwendung des Levenberg-Marquardt-Algorithmus - Parameter: V̇O2 (Amplitude), Tau - Modell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start - Grenzen: * V̇O2: 0.5 bis 7.0 l/min * Tau: 5 bis 360 s - Optimierung: Minimierung der Residuenquadratsumme (RSS) :::\n\n\nCode\n### Dauer der Zeitkonstante bei verschiedenen Intensitäten unterschiedlich\n# @Oezyner2001 fanden, dass der Wert von τ~Start~ für die Sauerstoffaufnahme im Durchschnitt bei 33 ± 16 s liegt, unabhängig von der Belastungshöhe. \n# -Im Gegensatz dazu berichten andere Studien von einem Anstieg von τ~Start~ mit zunehmender Belastung (Linnarsson 1974).\n# Wasserman et al. [@Wasserman1967] prognostizierten und fanden experimentell heraus, dass der Sauerstoffverbrauch bei schweren Arbeitsbelastungen länger ansteigt als bei moderaten Intensitäten. Henry und DeMoor [@Henry1956] stellten ebenfalls fest, dass die Zeit bis zum Erreichen eines stabilen Zustands der Sauerstoffaufnahme (VO2) mit steigender Arbeitslast zunimmt. Im Gegensatz dazu berichten Di Prampero et al. [@DiPrampero1970] und Margaria et al. [@Margaria1965], dass das Muster des VO2-Anstiegs zum stabilen Zustand unabhängig von der Arbeitsintensität gleich ist und dieser Anstieg durch einen einzigen exponentiellen Prozess beschrieben wird, wobei die Reaktionskonstante für alle Arbeitslasten gleich ist.\n# \n# **Moderate Intensität:**\n# Die pulmonale V̇O~2~steigt monoexponentiell und erreicht innerhalb von etwa 3 Minuten einen Steady State [@Whipp1982; @Hughson1988; @Whipp1994]. Die V̇O~2~ erhöht sich linear zur Arbeitsrate um etwa 10 ml·min^-1·W^-1. Sobald der Steady State erreicht ist, sind ATP-Resynthese und oxidative Phosphorylierung im Gleichgewicht [@Kindermann1979; @Faude2009].\n# \n# **Schwere Intensität:**\n# Die schwere Intensität liegt zwischen der maximalen Leistungsfähigkeit (GXT) und der kritischen Leistung (CP) [@Hill1993]. Bei schwerer Belastung ist der oxidative Bedarf höher, und der Steady State verzögert sich durch die V̇O~2~ Slow Component. Die O~2~-Kosten steigen auf etwa 13 ml·min^-1·W^-1 [@WhippWasserman1972; @PearceMilhorn1977; @WhippMahler1980; @BarstowMole1991]. Die arterielle Laktatkonzentration steigt über die Ausgangswerte, erreicht aber ein erhöhtes Gleichgewicht [@Billat2003].\n# \n# **Schwere Intensität:**\n# In der Forschung ist umstritten, ob die primäre V̇O~2~-Kinetik bei schwerer Belastung langsamer ist als bei moderater. Dies könnte auf eine größere Zeitkonstante oder eine zusätzliche Slow Component in V̇O~2~ hindeuten, die einen verzögerten Steady State über dem vorhergesagten Niveau erreicht [@PatersonWhipp1991; @BarstowMole1991].\n# \n# **Sehr schwere Intensität:**\n# Bei sehr schwerer Intensität, oberhalb des maximalen Laktat-Steady-State oder der kritischen Leistung, erreichen weder V̇O~2~ noch arterielle Laktatkonzentration einen Steady State [@GaesserPoole1996]. Beide steigen unaufhaltsam, bis Ermüdung eintritt und maximale V̇O~2~-Werte erreicht werden [@WassermanWhipp1975; @GaesserPoole1996].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n\nCode\n1 + 1\n\n\n[1] 2"
  },
  {
    "objectID": "Laktat.html",
    "href": "Laktat.html",
    "title": "Laktat-Modellfunktionen",
    "section": "",
    "text": "1 Blutlaktat-Modellfunktion: Exponentieller Abfall nach dem Belastungsende\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Define data\nt_s &lt;- c(23, 127, 261, 422.5, 549.8, 664.5, 795.8, 1254.9)\nBLC_t &lt;- c(10.04, 7.49, 5.18, 3.9, 2.67, 2.18, 1.64, 0.98)\n\n# New model function: A * exp(-k * (t - delay)) + BLC0\nlaktat_model_function &lt;- function(t, A, k, BLC0, delay) {\n  A * exp(-k * (t - delay)) + BLC0\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"A\", \"A [mmol/l]\", min = 0.0, max = 15.0, value = 8.0, step = 0.1),\n      sliderInput(\"k\", \"k [s^-1]\", min = 0.0001, max = 0.02, value = 0.005, step = 0.0001),\n      sliderInput(\"BLC0\", \"BLC0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      sliderInput(\"delay\", \"Delay [s]\", min = 0, max = 3600, value = 0, step = 0.1),\n      actionButton(\"set_delay\", \"Delay auf BLC_1\"),\n      br(), br(),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server logic\nserver &lt;- function(input, output, session) {\n  # Reactive value for uploaded data\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Observer for CSV upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_s\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_s' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Observer for setting delay to first time point\n  observeEvent(input$set_delay, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    updateSliderInput(session, \"delay\", value = min(data$t_s))\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    delay &lt;- input$delay\n    \n    # Filter data points after the delay\n    data_filtered &lt;- data[data$t_s &gt; delay, ]\n    \n    if (nrow(data_filtered) &lt; 3) {\n      showNotification(\"Nicht genügend Datenpunkte nach dem Delay für den Fitting-Prozess.\", type = \"error\")\n      return()\n    }\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomized starting values\n        A_start &lt;- runif(1, 0, 15)\n        k_start &lt;- runif(1, 0.0001, 0.02)\n        BLC0_start &lt;- runif(1, 0, 5)\n        \n        start_values &lt;- list(A = A_start, k = k_start, BLC0 = BLC0_start)\n        \n        model_equation &lt;- BLC_t ~ A * exp(-k * (t_s - delay)) + BLC0\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data_filtered,\n                         start = start_values,\n                         lower = c(A = 0, k = 0.0001, BLC0 = 0),\n                         upper = c(A = 15, k = 0.02, BLC0 = 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"A\", value = params$A)\n      updateSliderInput(session, \"k\", value = params$k)\n      updateSliderInput(session, \"BLC0\", value = params$BLC0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A &lt;- input$A\n    k &lt;- input$k\n    BLC0 &lt;- input$BLC0\n    delay &lt;- input$delay\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_s = t_s, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_s) * 1.66\n    min_x &lt;- max(delay - 360, 0)\n    \n    t_s_modell &lt;- seq(min_x, max_x, length.out = 1000)\n    BLC_t_modell &lt;- laktat_model_function(t_s_modell, A, k, BLC0, delay)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.1, max(data$BLC_t) * 1.1)\n    \n    # Create equation text\n    eq_text &lt;- sprintf(\"BLC(t) = %.2f * e&lt;sup&gt;-%.4f*(t-%.2f)&lt;/sup&gt; + %.3f\", A, k, delay, BLC0)\n    \n    # Calculate R²\n    data_filtered &lt;- data[data$t_s &gt; delay, ]\n    BLC_t_modell_at_data &lt;- laktat_model_function(data_filtered$t_s, A, k, BLC0, delay)\n    ss_res &lt;- sum((data_filtered$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data_filtered$BLC_t - mean(data_filtered$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_s_modell[t_s_modell &gt;= delay], y = BLC_t_modell[t_s_modell &gt;= delay], \n                type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = t_s_modell[t_s_modell &lt; delay], y = BLC_t_modell[t_s_modell &lt; delay], \n                type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion (vor Delay)', line = list(color = '#EF6F6A', dash = 'dash')) %&gt;%\n      add_trace(x = data$t_s, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = '#42BA97', size = 10, symbol = 'x')) %&gt;%\n      add_segments(x = delay, xend = delay, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.75) %&gt;%\n      layout(title = \"Exponentielles Laktat-Abbaumodell\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [s]\", range = c(min_x, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Zeitverzögerung manuell setzen oder mit 'Delay auf BLC_1' die Zeitverzögerung auf den Zeitpunkt des ersten BLC-Wertes setzen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,BLC_t\n0.0,5.84\n90.0,3.60\n180.0,1.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nOptimierung (nlsLM - Fit):\n\nVerwendete Funktion: nlsLM\nParameter: A, k, BLC0\nModell: BLC_t ~ A · exp(-k · (t_s - delay)) + BLC0\nGrenzen:\n\nA: 0 bis 15 mmol/l\nk: 0.0001 bis 0.02 s^-1\nBLC0: 0 bis 5 mmol/l\n\nProzess:\n\nDatenauswahl:\n\nVerwendung der Daten nach dem eingestellten Delay-Wert\nÜberprüfung auf mindestens 3 Datenpunkte nach dem Delay\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · A: Zufallswert zwischen 0 und 15 · k: Zufallswert zwischen 0.0001 und 0.02 · BLC0: Zufallswert zwischen 0 und 5\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\n\n\n\n\n\n\n2 Blutlaktat-Bateman-Modellfunktion: Während und nach dem Belastungszeitraum\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Definiere Daten\nt_min &lt;- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)\nBLC_t &lt;- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)\n\n# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist\nif (min(t_min) &gt; 0.0) {\n  t_min &lt;- t_min - min(t_min)\n}\n\n# Bateman-Funktion für Laktatwerte (in Minuten) mit BLC0\nbateman_function &lt;- function(t, a, k1, k2, BLC0) {\n  BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t) - exp(-k2 * t))\n}\n\n# Invasions- und Eliminationsfunktionen\ninvasion_function &lt;- function(t, a, k1, BLC0) {\n  BLC0 + a * (1 - exp(-k1 * t))\n}\n\nelimination_function &lt;- function(t, a, k2, BLC0) {\n  BLC0 + a * exp(-k2 * t)\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"a\", \"a [mmol/l]\", min = 0.0, max = 30.0, value = 15.0, step = 0.01),\n      sliderInput(\"k1\", \"k1 [min^-1]\", min = 0.1, max = 3.5, value = 0.5, step = 0.001),\n      sliderInput(\"k2\", \"k2 [min^-1]\", min = 0.020, max = 0.200, value = 0.10, step = 0.001),\n      sliderInput(\"BLC0\", \"BLC0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server-Logik\nserver &lt;- function(input, output, session) {\n  \n  # Reaktiver Wert für hochgeladene Daten\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Beobachter für CSV-Upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_min\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      if (df$t_min[1] != 0.0) {\n        df$t_min &lt;- df$t_min - df$t_min[1]\n      }\n      \n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    # Setze BLC0 Grenzen basierend auf dem ersten BLC_t Wert\n    BLC0_lower &lt;- max(0, data$BLC_t[1] * 0.9)\n    BLC0_upper &lt;- min(5, data$BLC_t[1] * 1.1)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte\n        a_start &lt;- runif(1, 0, 30)\n        k1_start &lt;- runif(1, 0.1, 3.5)\n        k2_start &lt;- runif(1, 0.020, 0.200)\n        BLC0_start &lt;- runif(1, BLC0_lower, BLC0_upper)\n        \n        start_values &lt;- list(a = a_start, k1 = k1_start, k2 = k2_start, BLC0 = BLC0_start)\n        \n        model_equation &lt;- BLC_t ~ BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t_min) - exp(-k2 * t_min))\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data,\n                         start = start_values,\n                         lower = c(a = 0.0, k1 = 0.1, k2 = 0.020, BLC0 = BLC0_lower),\n                         upper = c(a = 30.0, k1 = 3.5, k2 = 0.200, BLC0 = BLC0_upper),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"a\", value = params$a)\n      updateSliderInput(session, \"k1\", value = params$k1)\n      updateSliderInput(session, \"k2\", value = params$k2)\n      updateSliderInput(session, \"BLC0\", value = params$BLC0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    a &lt;- input$a\n    k1 &lt;- input$k1\n    k2 &lt;- input$k2\n    BLC0 &lt;- input$BLC0\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_min) * 1.66\n    \n    t_min_modell &lt;- seq(0, max_x, length.out = 1000)\n    BLC_t_modell &lt;- bateman_function(t_min_modell, a, k1, k2, BLC0)\n    invasion_modell &lt;- invasion_function(t_min_modell, a, k1, BLC0)\n    elimination_modell &lt;- elimination_function(t_min_modell, a, k2, BLC0)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2, max(invasion_modell) * 1.2, max(elimination_modell) * 1.2)\n    \n    # Berechne tmax und Lamax\n    tmax &lt;- log(k1/k2) / (k1 - k2)\n    Lamax &lt;- bateman_function(tmax, a, k1, k2, BLC0)\n    \n    # Erstelle Gleichungstext\n    eq_text &lt;- sprintf(\"[La]&lt;sub&gt;b(t)&lt;/sub&gt; = %.2f + (%.2f * %.3f / (%.3f - %.3f)) * (e&lt;sup&gt;-%.3f*t&lt;/sup&gt; - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;)\", \n                       BLC0, a, k1, k2, k1, k1, k2)\n    \n    # Berechne R²\n    BLC_t_modell_at_data &lt;- bateman_function(data$t_min, a, k1, k2, BLC0)\n    ss_res &lt;- sum((data$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data$BLC_t - mean(data$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly-Plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', \n                name = 'Bateman-Funktion', line = list(color = '#EF5350')) %&gt;%\n      add_trace(x = t_min_modell, y = invasion_modell, type = 'scatter', mode = 'lines', \n                name = 'Invasion', line = list(color = \"#9C85C0\", width = 2, dash = '8 5'),\n                opacity = 0.65) %&gt;%\n      add_trace(x = t_min_modell, y = elimination_modell, type = 'scatter', mode = 'lines', \n                name = 'Elimination', line = list(color = '#2683C6', width = 2, dash = '8 5'),\n                opacity = 0.65) %&gt;%\n      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = \"#42BA97\", size = 9, symbol = 'x')) %&gt;%\n      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      layout(title = \"Bateman-Funktion für Laktat-Modellierung\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [min]\", range = c(0, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.85,\n                 text = sprintf(\"BLC&lt;sub&gt;max&lt;/sub&gt;: %.2f mmol/l\", Lamax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.80,\n                 text = sprintf(\"TBLC&lt;sub&gt;max&lt;/sub&gt;: %.2f min\",tmax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_min,BLC_t\n0.0,2.84\n1.5,3.60\n3.0,5.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: a, k1, k2, BLC0\nModell: BLC_t ~ BLC0 + (a · k1 / (k2 - k1)) · (exp(-k1 · t_min) - exp(-k2 · t_min))\nGrenzen:\n\na: 0.0 bis 30.0 mmol/l\nk1: 0.1 bis 3.5 min^-1\nk2: 0.020 bis 0.200 min^-1\nBLC0: 0.90 · BLC_t[1] bis 1.10 · BLC_t[1], begrenzt auf 0 bis 5 mmol/l\n\nProzess:\n\nBestimmung der BLC0-Grenzen:\n\nUntere Grenze: max(0, 0.90 · erster BLC-Wert)\nObere Grenze: min(5, 1.10 · erster BLC-Wert)\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · a: Zufallswert zwischen 0 und 30 · k1: Zufallswert zwischen 0.1 und 3.5 · k2: Zufallswert zwischen 0.020 und 0.200 · BLC0: Zufallswert zwischen der unteren und oberen BLC0-Grenze\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n3 Blutlaktat-Kompartmentmodell-Modellfunktion (nach Freund et al. 1986): Während und nach dem Belastungszeitraum\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Definiere Daten\nt_min &lt;- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)\nBLC_t &lt;- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)\n\n# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist\nif (min(t_min) &gt; 0.0) {\n  t_min &lt;- t_min - min(t_min)\n}\n\n# Freund et al. Kompartmentmodell-Funktion\nfreund_model &lt;- function(t, A1, A2, gamma1, gamma2, La0) {\n  La0 + A1 * (1 - exp(-gamma1 * t)) + A2 * (1 - exp(-gamma2 * t))\n}\n\n# Berechne tmax und Lamax\ncalculate_tmax_lamax &lt;- function(A1, A2, gamma1, gamma2, La0) {\n  f &lt;- function(t) freund_model(t, A1, A2, gamma1, gamma2, La0)\n  tmax &lt;- optimize(f, c(0, 100), maximum = TRUE)$maximum\n  Lamax &lt;- f(tmax)\n  list(tmax = tmax, Lamax = Lamax)\n}\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"A1\", \"A1 [mmol/l]\", min = 0.0, max = 100.0, value = 20.0, step = 0.1),\n      sliderInput(\"A2\", \"A2 [mmol/l]\", min = -100.0, max = 0.0, value = -20.0, step = 0.1),\n      sliderInput(\"gamma1\", \"γ1 [min^-1]\", min = 0.05, max = 2.0, value = 0.1, step = 0.001),\n      sliderInput(\"gamma2\", \"γ2 [min^-1]\", min = 0.01, max = 0.5, value = 0.05, step = 0.001),\n      sliderInput(\"La0\", \"La0 [mmol/l]\", min = 0.0, max = 5.0, value = 1.0, step = 0.01),\n      actionButton(\"optimize\", \"Fit: nlsLM\"), \n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server-Logik\nserver &lt;- function(input, output, session) {\n  \n  # Reaktiver Wert für hochgeladene Daten\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  # Beobachter für CSV-Upload\n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_min\" %in% names(df) && \"BLC_t\" %in% names(df)) {\n      if (df$t_min[1] != 0.0) {\n        df$t_min &lt;- df$t_min - df$t_min[1]\n      }\n      \n      uploaded_data(df)\n    } else {\n      showModal(modalDialog(\n        title = \"Ungültige CSV\",\n        \"Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$optimize, {\n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    # Setze La0 Grenzen basierend auf dem ersten BLC_t Wert\n    La0_lower &lt;- max(0, data$BLC_t[1] * 0.9)\n    La0_upper &lt;- min(5, data$BLC_t[1] * 1.1)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte\n        A1_start &lt;- runif(1, 0, 100)\n        A2_start &lt;- runif(1, -100, 0)\n        gamma1_start &lt;- runif(1, 0.05, 2)\n        gamma2_start &lt;- runif(1, 0.01, 0.5)\n        La0_start &lt;- runif(1, La0_lower, La0_upper)\n        \n        start_values &lt;- list(A1 = A1_start, A2 = A2_start, gamma1 = gamma1_start, gamma2 = gamma2_start, La0 = La0_start)\n        \n        model_equation &lt;- BLC_t ~ La0 + A1 * (1 - exp(-gamma1 * t_min)) + A2 * (1 - exp(-gamma2 * t_min))\n        \n        fit &lt;- try(nlsLM(model_equation,\n                         data = data,\n                         start = start_values,\n                         lower = c(A1 = 0.0, A2 = -100.0, gamma1 = 0.05, gamma2 = 0.01, La0 = La0_lower),\n                         upper = c(A1 = 100.0, A2 = 0.0, gamma1 = 2.0, gamma2 = 0.5, La0 = La0_upper),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"A1\", value = params$A1)\n      updateSliderInput(session, \"A2\", value = params$A2)\n      updateSliderInput(session, \"gamma1\", value = params$gamma1)\n      updateSliderInput(session, \"gamma2\", value = params$gamma2)\n      updateSliderInput(session, \"La0\", value = params$La0)\n      \n      showNotification(\"Fitting completed successfully!\", type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A1 &lt;- input$A1\n    A2 &lt;- input$A2\n    gamma1 &lt;- input$gamma1\n    gamma2 &lt;- input$gamma2\n    La0 &lt;- input$La0\n    \n    data &lt;- if (is.null(uploaded_data())) {\n      data.frame(t_min = t_min, BLC_t = BLC_t)\n    } else {\n      uploaded_data()\n    }\n    \n    max_x &lt;- max(data$t_min) * 1.66\n    \n    t_min_modell &lt;- seq(0, max_x, length.out = 1000)\n    BLC_t_modell &lt;- freund_model(t_min_modell, A1, A2, gamma1, gamma2, La0)\n    \n    max_y &lt;- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2)\n    \n    # Berechne tmax und Lamax\n    results &lt;- calculate_tmax_lamax(A1, A2, gamma1, gamma2, La0)\n    tmax &lt;- results$tmax\n    Lamax &lt;- results$Lamax\n    \n    # Erstelle Gleichungstext\n    eq_text &lt;- sprintf(\"[La]&lt;sub&gt;b(t)&lt;/sub&gt; = %.2f + %.1f * (1 - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;) + %.1f * (1 - e&lt;sup&gt;-%.3f*t&lt;/sup&gt;)\", \n                       La0, A1, gamma1, A2, gamma2)\n    \n    # Berechne R²\n    BLC_t_modell_at_data &lt;- freund_model(data$t_min, A1, A2, gamma1, gamma2, La0)\n    ss_res &lt;- sum((data$BLC_t - BLC_t_modell_at_data)^2)\n    ss_tot &lt;- sum((data$BLC_t - mean(data$BLC_t))^2)\n    r_squared &lt;- 1 - (ss_res / ss_tot)\n    \n    # Plotly-Plot\n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', \n                name = 'Modellgleichung', line = list(color = '#EF5350')) %&gt;%\n      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', \n                name = 'Gemessene BLC-Werte', marker = list(color = \"#42BA97\", size = 9, symbol = 'x')) %&gt;%\n      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, \n                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), \n                   showlegend = FALSE, opacity = 0.5) %&gt;%\n      layout(title = \"Freund et al. Kompartmentmodell für Laktat-Modellierung\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [min]\", range = c(0, max_x)),\n             yaxis = list(title = \"Laktat [mmol/l]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = max_x * 0.5, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.90,\n                 text = sprintf(\"R²: %.4f\", r_squared),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.85,\n                 text = sprintf(\"BLC&lt;sub&gt;max&lt;/sub&gt;: %.2f mmol/l\", Lamax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.5,\n                 y = max_y * 0.80,\n                 text = sprintf(\"TBLC&lt;sub&gt;max&lt;/sub&gt;: %.2f min\",tmax),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel-Laktatdaten verwenden oder eigene Laktat-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nLaktat-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_min,BLC_t\n0.0,2.84\n1.5,3.60\n3.0,5.09\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: A1, A2, gamma1, gamma2, La0\nModell: BLC_t ~ La0 + A1 · (1 - exp(-gamma1 · t_min)) + A2 · (1 - exp(-gamma2 · t_min))\nGrenzen:\n\nA1: 0.0 bis 100.0 mmol/l\nA2: -100.0 bis 0.0 mmol/l\ngamma1: 0.05 bis 2.0 min^-1\ngamma2: 0.01 bis 0.5 min^-1\nLa0: 0.90 · BLC_t[1] bis 1.10 · BLC_t[1], begrenzt auf 0 bis 5 mmol/l\n\nProzess:\n\nBestimmung der La0-Grenzen:\n\nUntere Grenze: max(0, 0.90 · erster BLC-Wert)\nObere Grenze: min(5, 1.10 · erster BLC-Wert)\n\nIterative Optimierung (100 Durchläufe):\n\nZufällige Startwertebestimmung für jeden Durchlauf: · A1: Zufallswert zwischen 0 und 100 · A2: Zufallswert zwischen -100 und 0 · gamma1: Zufallswert zwischen 0.05 und 2.0 · gamma2: Zufallswert zwischen 0.01 und 0.5 · La0: Zufallswert zwischen der unteren und oberen La0-Grenze\nDurchführung der nicht-linearen Regression: · Verwendung des Levenberg-Marquardt-Algorithmus · Maximale Iterationen: 1024\nBerechnung der Residuenquadratsumme (RSS) für jede Anpassung\nSpeicherung der besten Anpassung (niedrigste RSS)\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\n4 Laktat-Leistungs-Beziehung\n#| standalone: true\n#| viewerHeight: 900\nlibrary(shiny)\nlibrary(plotly)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Laktat-Leistungs-Modell\"),\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"num_rows\", \"Anzahl der Datenpunkte\", 4, min = 1, max = 20),\n      uiOutput(\"input_fields\"),\n      width = 2  \n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  # Initialwerte für die Leistung und ΔBLC\n  initial_values &lt;- list(\n    list(Leistung = 100, DeltaBLC = 0.3),\n    list(Leistung = 200, DeltaBLC = 1.0),\n    list(Leistung = 300, DeltaBLC = 2.8),\n    list(Leistung = 400, DeltaBLC = 8.0)\n  )\n  \n  # Dynamisch Input-Felder erzeugen\n  output$input_fields &lt;- renderUI({\n    num_rows &lt;- input$num_rows\n    \n    lapply(1:num_rows, function(i) {\n      initial_value &lt;- if (i &lt;= length(initial_values)) initial_values[[i]] else list(Leistung = 0, DeltaBLC = 0)\n      tagList(\n        numericInput(paste0(\"leistung_\", i), paste(\"Leistung\", i), value = initial_value$Leistung, step = 10),\n        numericInput(paste0(\"deltaBLC_\", i), paste(\"ΔBLC\", i), value = initial_value$DeltaBLC, step = 0.1)\n      )\n    })\n  })\n  \n  # Reaktive Datenframe basierend auf Eingabewerten\n  input_data &lt;- reactive({\n    num_rows &lt;- input$num_rows\n    if (is.null(num_rows)) return(NULL)\n    \n    data &lt;- data.frame(Leistung = numeric(num_rows), ΔBLC = numeric(num_rows))\n    \n    for (i in 1:num_rows) {\n      leistung_val &lt;- input[[paste0(\"leistung_\", i)]]\n      deltaBLC_val &lt;- input[[paste0(\"deltaBLC_\", i)]]\n      \n      if (is.null(leistung_val) || is.null(deltaBLC_val)) {\n        data$Leistung[i] &lt;- if (i &lt;= length(initial_values)) initial_values[[i]]$Leistung else 0\n        data$ΔBLC[i] &lt;- if (i &lt;= length(initial_values)) initial_values[[i]]$DeltaBLC else 0\n      } else {\n        data$Leistung[i] &lt;- leistung_val\n        data$ΔBLC[i] &lt;- deltaBLC_val\n      }\n    }\n    \n    data\n  })\n  \n  # Initiale Werte setzen\n  observe({\n    for (i in 1:length(initial_values)) {\n      updateNumericInput(session, paste0(\"leistung_\", i), value = initial_values[[i]]$Leistung)\n      updateNumericInput(session, paste0(\"deltaBLC_\", i), value = initial_values[[i]]$DeltaBLC)\n    }\n  })\n  \n  # Modell anpassen und Plot aktualisieren\n  output$plot &lt;- renderPlotly({\n    df_proband &lt;- input_data()\n    \n    if (is.null(df_proband)) return(NULL)\n    \n    # Anpassung des Exponentialmodells\n    model &lt;- nls(ΔBLC ~ a * exp(b * Leistung), data = df_proband, start = list(a = 1, b = 0.01))\n    coef_exponential_model &lt;- coef(model)\n    \n    # Vorhersagen und Sequenz für den Plot\n    x_seq &lt;- seq(min(df_proband$Leistung), max(df_proband$Leistung), length.out = 100)\n    y_pred &lt;- predict(model, newdata = data.frame(Leistung = x_seq))\n    \n    # Plotly-Diagramm\n    plot_ly() %&gt;%\n      add_trace(data = df_proband, x = ~Leistung, y = ~ΔBLC, type = 'scatter', mode = 'markers',\n                name = \"ΔBLC\",\n                marker = list(color = \"#2683C6\", size = 7.0)) %&gt;%\n      add_trace(x = x_seq, y = y_pred, type = 'scatter', mode = 'lines', \n                name = 'Laktat-Modellfunktion', \n                line = list(color = '#62A39F', width = 3)) %&gt;%\n      add_annotations(text = sprintf(\"ΔBLC = %.5f \\u00B7 e&lt;sup&gt;%.5f \\u00B7 Leistung&lt;/sup&gt;\", \n                                     coef_exponential_model['a'], coef_exponential_model['b']),\n                      x = min(df_proband$Leistung), y = max(y_pred), showarrow = FALSE,\n                      xanchor = 'left', yanchor = 'bottom',\n                      font = list(family = \"Arial, sans-serif\", size = 12, color = \"black\")) %&gt;%\n      layout(\n        title = \"Laktat-Leistungs-Modell\",\n        margin = list(t = 40),\n        xaxis = list(title = \"Leistung [Watt]\"),\n        yaxis = list(title = \"ΔBLC [mmol \\u00B7 l&lt;sup&gt;-1&lt;/sup&gt;]\")\n      )\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Anzahl der Datenpunkte bestimmen.&lt;/li&gt;\n          &lt;li&gt;Für jeden Datenpunkt die Leistung (in Watt) und den entsprechenden ΔBLC-Wert eingeben.&lt;/li&gt;\n          &lt;li&gt;Das exponentielle Modell wird automatisch an die eingegebenen Daten angepasst.&lt;/li&gt;\n        &lt;/ol&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Optimierung (nls - Fit):\n\nVerwendete Funktion: nls (Non-Linear Least Squares)\nParameter: a, b\nModell: ΔBLC ~ a · exp(b · Leistung)\nProzess:\n\nDatenaufbereitung:\n\nErstellung eines reaktiven Dataframes basierend auf den Benutzereingaben\n\nModellierung:\n\nAnwendung des nicht-linearen Regressionsmodells auf die eingegebenen Daten\nStartwerte:\n\na: 1.0\nb: 0.01\n\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung der Standard-nls-Funktion in R\nKeine expliziten Grenzen für die Parameter gesetzt\n\nErgebnisverarbeitung:\n\nExtraktion der Koeffizienten a und b aus dem angepassten Modell\n\nVisualisierung:\n\nErstellung einer Sequenz von Leistungswerten für glatte Kurvendarstellung\nBerechnung der vorhergesagten ΔBLC-Werte basierend auf dem Modell\nDarstellung der eingegebenen Datenpunkte und der Modellkurve\nAnzeige der Modellgleichung mit den angepassten Koeffizienten\n\n\nOptimierung: Minimierung der Summe der quadrierten Abweichungen (nls)",
    "crumbs": [
      "Laktat-Modellfunktionen"
    ]
  },
  {
    "objectID": "EPOC.html",
    "href": "EPOC.html",
    "title": "EPOC-Modellfunktion",
    "section": "",
    "text": "1 Modellfunktion des EPOC in Abhängigkeit von der Zeit während der Belastung\n#| standalone: true\n#| viewerHeight: 1200\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten ohne Nachbelastung \nt_data &lt;- c(3505.1, 3506.8, 3508.3, 3509.8, 3511.4, 3513.2, 3514.7, 3516.2, 3517.5, 3518.9, 3520.3, 3521.6, 3523.0, 3524.7, 3526.0, 3527.2, 3528.7, 3530.0, 3531.4, 3532.8, 3534.3, 3535.7, 3537.0, 3538.4, 3539.9, 3541.2, 3542.8, 3544.3, 3545.6, 3547.0, 3548.4, 3550.1, 3551.7, 3553.2, 3554.6, 3556.1, 3557.5, 3560.2, 3561.8, 3564.3, 3566.0, 3567.8, 3569.6, 3571.5, 3573.3, 3575.3, 3577.1, 3579.1, 3581.0, 3582.7, 3584.2, 3585.7, 3587.1, 3588.5, 3589.9, 3591.4, 3593.3, 3594.7, 3596.2, 3597.8, 3599.5, 3601.0, 3602.4, 3603.9, 3605.6, 3607.1, 3608.6, 3610.4, 3612.0, 3613.4, 3616.4, 3618.5, 3620.2, 3621.8, 3623.8, 3626.1, 3628.4, 3630.5, 3632.5, 3635.1, 3637.2, 3639.6, 3641.7, 3643.7, 3648.5, 3652.4, 3654.4, 3656.7, 3658.9, 3660.1, 3662.3, 3664.6, 3667.2, 3669.5, 3671.4, 3673.6, 3675.5, 3677.1, 3679.0, 3681.0, 3683.0, 3685.0, 3687.1, 3689.0, 3691.1, 3692.9, 3695.6, 3697.2, 3699.4, 3701.8, 3704.0, 3706.0, 3708.1, 3709.9, 3711.8, 3715.0, 3717.5, 3719.6, 3721.7, 3724.0, 3726.2, 3728.2, 3730.1, 3732.0, 3734.3, 3736.0, 3738.4, 3739.2, 3741.1, 3743.1, 3745.4, 3746.5, 3748.7, 3750.9, 3753.1, 3755.3, 3757.6, 3762.7, 3765.6, 3768.1, 3770.2, 3772.4, 3774.8, 3777.5, 3779.9, 3782.3, 3785.3, 3787.7, 3789.8, 3792.2, 3794.9, 3796.5, 3798.2, 3800.6, 3802.4, 3805.3, 3808.0, 3810.9, 3813.0, 3815.1, 3818.0, 3820.4, 3822.3, 3824.5, 3826.6, 3829.8, 3833.1, 3835.3, 3838.1, 3840.1, 3844.9, 3847.1, 3848.5, 3850.0, 3855.3, 3859.2, 3861.9, 3863.6, 3865.6, 3867.8, 3869.8, 3872.0, 3874.4, 3876.1, 3878.4, 3881.1, 3882.9, 3884.9, 3886.3, 3888.9, 3890.6, 3892.8, 3895.1, 3897.1, 3898.8, 3900.7, 3903.3, 3905.3, 3907.7, 3910.3, 3913.8, 3916.9, 3919.2, 3921.5, 3923.6, 3926.4, 3928.3, 3930.3, 3932.2, 3934.5, 3936.9, 3940.6, 3942.8, 3944.4, 3946.6, 3948.7, 3950.6, 3954.0, 3956.5, 3960.8, 3962.3, 3964.1, 3966.5, 3969.3, 3971.7, 3975.9, 3977.9, 3982.9, 3985.3, 3987.5, 3990.2, 3992.7, 3995.5, 3997.9, 4000.1, 4004.3, 4006.5, 4009.6, 4012.7, 4015.5, 4017.9, 4020.0, 4024.2, 4026.1, 4028.8, 4031.2, 4033.7, 4035.6, 4037.6, 4041.3, 4044.9, 4047.2, 4049.9, 4054.3, 4057.3, 4060.2, 4062.4, 4065.5, 4068.0, 4070.5, 4072.6, 4074.5, 4076.4, 4078.1, 4080.3, 4082.8, 4084.9)\nVO2_data &lt;- c(4.3916, 4.33868, 4.29972, 4.26048, 4.25328, 4.22856, 4.18768, 4.16656, 4.118, 4.06268, 4.00452, 3.9486, 3.85204, 3.81448, 3.74268, 3.67572, 3.61052, 3.5468, 3.47268, 3.37056, 3.25912, 3.20024, 3.17932, 3.13008, 3.08712, 2.97636, 2.95052, 2.891, 2.82488, 2.72496, 2.6324, 2.55344, 2.45564, 2.38944, 2.32268, 2.2388, 2.16588, 2.09852, 1.99972, 1.9584, 1.87604, 1.81076, 1.74984, 1.70644, 1.66456, 1.64564, 1.59204, 1.53048, 1.47084, 1.4078, 1.40632, 1.34116, 1.29948, 1.26596, 1.23048, 1.22116, 1.19188, 1.19668, 1.16332, 1.153, 1.15444, 1.14004, 1.14976, 1.15704, 1.15192, 1.15128, 1.14088, 1.1228, 1.11288, 1.10284, 1.07976, 1.07524, 1.0516, 1.0596, 1.0478, 1.03064, 1.03404, 1.01436, 1.01996, 1.02592, 0.99788, 1.00092, 0.96684, 0.98036, 0.96396, 0.96056, 0.94256, 0.93244, 0.92228, 0.9068, 0.90336, 0.88984, 0.87968, 0.88288, 0.85096, 0.84, 0.83584, 0.83428, 0.82228, 0.82996, 0.8382, 0.831, 0.86264, 0.83748, 0.83664, 0.8596, 0.8622, 0.86216, 0.85472, 0.85588, 0.8374, 0.84796, 0.84512, 0.85952, 0.84476, 0.8158, 0.8146, 0.80048, 0.77164, 0.7736, 0.76624, 0.77088, 0.77992, 0.80724, 0.80412, 0.80112, 0.8068, 0.78476, 0.79444, 0.79072, 0.78772, 0.79112, 0.79316, 0.79112, 0.78536, 0.7758, 0.76944, 0.77496, 0.76204, 0.7836, 0.79964, 0.81584, 0.85324, 0.85488, 0.89108, 0.904, 0.89116, 0.87828, 0.86268, 0.8416, 0.84192, 0.83324, 0.8332, 0.83228, 0.83992, 0.8094, 0.79928, 0.80512, 0.811, 0.82524, 0.82652, 0.8246, 0.80908, 0.80036, 0.80152, 0.81324, 0.79372, 0.76376, 0.78108, 0.76332, 0.75032, 0.78964, 0.78632, 0.78452, 0.78252, 0.77932, 0.78952, 0.78984, 0.7888, 0.77604, 0.79476, 0.8106, 0.79136, 0.76844, 0.73712, 0.7374, 0.74148, 0.75156, 0.74932, 0.7288, 0.72612, 0.75984, 0.76316, 0.76744, 0.76004, 0.75084, 0.70948, 0.70316, 0.68816, 0.70184, 0.6916, 0.681, 0.67276, 0.66776, 0.66792, 0.65952, 0.64368, 0.67064, 0.67144, 0.68348, 0.67592, 0.65776, 0.63996, 0.64432, 0.6382, 0.62112, 0.58896, 0.6054, 0.57796, 0.58432, 0.59236, 0.60632, 0.62372, 0.63128, 0.63308, 0.6444, 0.6382, 0.64336, 0.64684, 0.65508, 0.66076, 0.63596, 0.60768, 0.62748, 0.62472, 0.6284, 0.64236, 0.66068, 0.65004, 0.67312, 0.67836, 0.69416, 0.66368, 0.65028, 0.629, 0.62796, 0.60816, 0.61548, 0.61224, 0.62336, 0.61552, 0.62804, 0.63852, 0.64872, 0.641, 0.633, 0.64456, 0.66328, 0.6502, 0.65676, 0.66388, 0.6542, 0.63828, 0.64624, 0.63272, 0.65072, 0.64964)\n\n# Beispieldaten mit 50 Watt Nachbelastung \nt_data_50W &lt;- c(2552.6, 2554.0, 2555.6, 2557.1, 2558.7, 2560.3, 2562.0, 2563.7, 2565.4, 2567.0, 2568.6, 2570.0, 2571.5, 2572.8, 2574.6, 2576.1, 2577.5, 2579.0, 2580.5, 2582.7, 2584.2, 2586.3, 2587.7, 2589.0, 2590.8, 2592.2, 2594.2, 2595.8, 2597.4, 2599.1, 2600.6, 2602.1, 2603.6, 2605.3, 2606.9, 2608.5, 2610.3, 2612.6, 2613.9, 2615.6, 2617.2, 2618.8, 2621.5, 2623.0, 2625.5, 2627.3, 2628.9, 2630.3, 2631.9, 2633.3, 2635.0, 2636.5, 2638.2, 2639.9, 2641.5, 2643.0, 2644.9, 2646.6, 2648.3, 2649.8, 2651.3, 2652.9, 2654.5, 2656.3, 2658.2, 2660.1, 2661.9, 2663.7, 2665.4, 2667.0, 2669.1, 2670.9, 2672.6, 2674.4, 2676.1, 2678.0, 2679.9, 2681.6, 2683.1, 2684.7, 2685.7, 2687.1, 2690.9, 2692.6, 2695.9, 2697.7, 2698.9, 2701.2, 2703.0, 2705.0, 2706.7, 2708.5, 2710.3, 2711.8, 2713.4, 2715.1, 2716.7, 2718.2, 2719.8, 2721.3, 2723.2, 2725.4, 2727.1, 2729.0, 2730.8, 2732.4, 2733.9, 2735.4, 2737.4, 2739.1, 2741.2, 2743.1, 2746.2, 2747.8, 2749.5, 2751.3, 2753.0, 2755.0, 2757.3, 2759.5, 2761.7, 2763.6, 2765.7, 2767.8, 2769.3, 2770.8, 2772.2, 2774.3, 2776.1, 2777.7, 2779.3, 2781.1, 2783.0, 2786.2, 2787.9, 2789.5, 2791.4, 2793.2, 2795.0, 2796.8, 2798.5, 2800.4, 2802.0, 2804.0, 2805.9, 2807.8, 2809.5, 2812.5, 2814.2, 2816.4, 2818.5, 2821.0, 2822.8, 2824.7, 2826.5, 2828.5, 2830.5, 2831.9, 2833.4, 2835.0, 2836.6, 2838.8, 2840.5, 2842.4, 2844.1, 2846.2, 2848.4, 2851.5, 2853.3, 2855.3, 2858.8, 2861.1, 2863.4, 2865.8, 2868.2, 2870.2, 2872.7, 2875.1, 2877.3, 2879.4, 2883.0, 2884.8, 2887.1, 2888.6, 2891.0, 2893.1, 2895.0, 2896.8, 2898.9, 2900.8, 2903.5, 2905.3, 2907.2, 2909.2, 2911.5, 2913.4, 2915.6, 2917.4, 2919.2, 2921.4, 2923.8, 2925.5, 2927.5, 2929.7, 2932.9, 2935.1, 2937.1, 2939.6, 2941.4, 2943.8, 2945.9, 2948.6, 2950.7, 2952.7, 2956.5, 2958.8, 2961.0, 2962.6, 2964.9, 2966.5, 2967.7, 2969.9, 2971.3, 2973.1, 2975.5, 2977.4, 2979.5, 2981.4, 2983.5, 2985.5, 2988.0, 2990.2, 2992.4, 2994.5, 2998.4, 3000.1, 3002.2, 3004.5, 3007.0, 3008.6, 3010.9, 3013.3, 3015.8, 3017.5, 3019.1, 3021.1, 3023.5, 3025.5, 3027.8, 3029.6, 3030.7, 3033.6, 3035.9, 3038.1, 3040.4, 3042.4, 3046.1, 3048.6, 3050.9, 3053.4, 3055.2, 3057.3, 3059.2, 3061.3, 3063.1, 3065.5, 3067.7, 3069.6, 3071.9, 3074.3, 3076.4, 3078.2, 3080.2, 3082.2, 3084.0, 3086.9, 3089.5, 3092.9, 3095.6, 3098.2, 3100.8, 3103.1, 3106.6, 3108.5, 3110.5, 3113.1, 3115.6, 3121.1, 3124.1, 3127.0, 3129.7, 3132.6, 3134.2, 3136.4, 3138.8, 3141.6, 3144.1, 3146.2, 3149.5, 3152.2, 3154.6, 3157.2, 3159.6)\nVO2_data_50W &lt;- c(4.4001, 4.3817, 4.3121, 4.3409, 4.3439, 4.3299, 4.2480, 4.1318, 4.1017, 4.0326, 3.9826, 3.9325, 3.8651, 3.8096, 3.7446, 3.6772, 3.6132, 3.5336, 3.4854, 3.4446, 3.3776, 3.3045, 3.2331, 3.1704, 3.0984, 3.0216, 2.9686, 2.9386, 2.8810, 2.8061, 2.7353, 2.7127, 2.7239, 2.6456, 2.6377, 2.5957, 2.5540, 2.5138, 2.4619, 2.4145, 2.4251, 2.3901, 2.3788, 2.3462, 2.2943, 2.2786, 2.2648, 2.2418, 2.2427, 2.2392, 2.2386, 2.1912, 2.1595, 2.1360, 2.1111, 2.1224, 2.0777, 2.0514, 2.0310, 1.9780, 1.9727, 1.9440, 1.9551, 1.9516, 1.9462, 1.9169, 1.8937, 1.8818, 1.8560, 1.8333, 1.8018, 1.8064, 1.8136, 1.7820, 1.7528, 1.7488, 1.7494, 1.7520, 1.7599, 1.7941, 1.7951, 1.8142, 1.8182, 1.8387, 1.8880, 1.8747, 1.8848, 1.8750, 1.8730, 1.8576, 1.8532, 1.8552, 1.8566, 1.8779, 1.9174, 1.9636, 1.9640, 1.9728, 1.9767, 2.0114, 1.9866, 2.0298, 2.0401, 2.0414, 2.0417, 2.0099, 2.0261, 1.9837, 1.9544, 1.9402, 1.9313, 1.9273, 1.9265, 1.9295, 1.9441, 1.9727, 1.9943, 2.0044, 1.9720, 1.9654, 1.9225, 1.9068, 1.8688, 1.8623, 1.8394, 1.8563, 1.8187, 1.7995, 1.7750, 1.7498, 1.7746, 1.7715, 1.8122, 1.8389, 1.8352, 1.8090, 1.8296, 1.8238, 1.8328, 1.8290, 1.8123, 1.7960, 1.7923, 1.7896, 1.7622, 1.7592, 1.7674, 1.7858, 1.7950, 1.8137, 1.8496, 1.8495, 1.8664, 1.8851, 1.8865, 1.8747, 1.8502, 1.8631, 1.8322, 1.8341, 1.8650, 1.8490, 1.8762, 1.8531, 1.8437, 1.8368, 1.8438, 1.8350, 1.8540, 1.8645, 1.8486, 1.8179, 1.8006, 1.7843, 1.7765, 1.7372, 1.7319, 1.7322, 1.7202, 1.7160, 1.7033, 1.6818, 1.6498, 1.6551, 1.6361, 1.6277, 1.6271, 1.6044, 1.6204, 1.6176, 1.5965, 1.6116, 1.5948, 1.5813, 1.6099, 1.6333, 1.6588, 1.6799, 1.6902, 1.6858, 1.6819, 1.6689, 1.6550, 1.6356, 1.6488, 1.6722, 1.6864, 1.6533, 1.6580, 1.6782, 1.6916, 1.6921, 1.6927, 1.6946, 1.7046, 1.7356, 1.6985, 1.7132, 1.7104, 1.6868, 1.6894, 1.6880, 1.6834, 1.6632, 1.6246, 1.6189, 1.6194, 1.6530, 1.6906, 1.6982, 1.6821, 1.6484, 1.7026, 1.7012, 1.6998, 1.6902, 1.6894, 1.6715, 1.5961, 1.6080, 1.5906, 1.5955, 1.5864, 1.6033, 1.5882, 1.5746, 1.5551, 1.5417, 1.5668, 1.6209, 1.6475, 1.6627, 1.6290, 1.6070, 1.5852, 1.5877, 1.6354, 1.5954, 1.5910, 1.5767, 1.5835, 1.6019, 1.6368, 1.6969, 1.6874, 1.6751, 1.6753, 1.6987, 1.6867, 1.6964, 1.7220, 1.7142, 1.7196, 1.7078, 1.6907, 1.6628, 1.6343, 1.6318, 1.6129, 1.6256, 1.6123, 1.6096, 1.6335, 1.6262, 1.6195, 1.6204, 1.5709, 1.5486, 1.5559, 1.5600, 1.5710, 1.5819, 1.5609, 1.5808, 1.5985, 1.5951, 1.6267, 1.6258, 1.5771, 1.5974, 1.6163, 1.6230, 1.6052)\n\n# Normalisierung der t_data Werte auf 0\nt_data &lt;- t_data - t_data[1]\nt_data_50W &lt;- t_data_50W - t_data_50W[1]\n\n# Modellfunktion\nmodel_function &lt;- function(t_s, A, TauA, B, TauB, C, t_delay) {\n  A * exp(-(t_s - t_delay) / TauA) + B * exp(-(t_s - t_delay) / TauB) + C\n}\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  tags$head(\n    tags$style(HTML(\"\n      .reduced-margin { margin-bottom: 5px !important; }\n      .radio-buttons-compact { margin-top: -20px; }\n    \"))\n  ),\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"A\", \"A\", min = 0.0, max = 6, value = 2.2, step = 0.01),\n           sliderInput(\"TauA\", \"TauA\", min = 5, max = 90, value = 35, step = 0.10),\n           sliderInput(\"B\", \"B\", min = 0.0, max = 5, value = 0.8, step = 0.01),\n           sliderInput(\"TauB\", \"TauB\", min = 0.0, max = 1800, value = 180, step = 0.10),\n           sliderInput(\"C\", \"C\", min = 0.0, max = 3.0, value = 0.30, step = 0.01),\n           sliderInput(\"O2_Store\", \"O2-Speicher [l]\", min = 0, max = 1, value = 0.4, step = 0.01),\n           sliderInput(\"t_delay\", \"Zeitverzögerung [s]\", min = 0, max = 300, value = 0, step = 1),\n           sliderInput(\"VO2_Ruhe\", \"VO2 Ruhe [l · min^-1]\", min = 0.0, max = 1.0, value = 0.3, step = 0.001),\n           sliderInput(\"VO2_Referenz\", \"VO2 Referenz (50 Watt) [l · min^-1]\", min = 0.0, max = 2.0, value = 1.0, step = 0.001),\n           br(), \n           tags$h4(tags$strong(\"Beispieldaten einfügen:\")),\n           actionButton(\"show_data_ohne\", \"ohne Nachbelastung\"),\n           br(), \n           actionButton(\"show_data_50W\", \"50 Watt Nachbelastung\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modelanpassung:\")),\n           actionButton(\"fit_all\", \"nlsLM - Fit\"),\n           tags$h4(class = \"reduced-margin\", \"Optionen:\"),\n           div(class = \"radio-buttons-compact\",\n               radioButtons(\"fit_mit\", \"\", \n                            choices = c(\"mit VO2 Ruhe\" = \"ruhe\", \"mit VO2 Referenz\" = \"referenz\"),\n                            selected = \"referenz\")\n           ),\n           div(class = \"radio-buttons-compact\",\n               radioButtons(\"fit_steps\", \"\", \n                            choices = c(\"3 Schritte\" = \"three_steps\", \"1 Schritt\" = \"one_step\"),\n                            selected = \"three_steps\")\n           ),\n           h4(\"Schrittweise:\"),\n           actionButton(\"fit_tau\", \"1. Fit: Tau\"), br(),\n           actionButton(\"fit_slow\", \"2. Fit: EPOC Slow\"), br(),\n           actionButton(\"fit_full\", \"3. Fit: EPOC Fast\"),\n           br(), br(),\n           sliderInput(\"ruhe_sim_range\", \"Zeitraum der simulierten Ruhewerte [s]:\",\n                       min = 1200, max = 7200, value = c(3600, 4200), step = 100),\n           actionButton(\"toggle_view\", \"Ruhe_sim anzeigen\"),\n           br(), br(),\n           tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n           radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n           sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 90),\n           sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 193),\n           sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 27),\n           sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n           actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    column(8,\n           fluidRow(\n             column(12, plotlyOutput(\"plot\"))\n           ),\n           fluidRow(\n             column(12, htmlOutput(\"instructions\"))\n           )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  current_data &lt;- reactiveVal(NULL)\n  uploaded_data &lt;- reactiveVal(NULL)\n  tau_estimate &lt;- reactiveVal(NULL)\n  slow_estimates &lt;- reactiveVal(NULL)\n  show_full_view &lt;- reactiveVal(FALSE)\n  max_ruhe_t_s &lt;- reactiveVal(NULL)\n  ruhe_sim &lt;- reactiveVal(NULL)\n  fit_mode &lt;- reactive({\n    input$fit_steps\n  })\n  \n  observeEvent(input$show_data_ohne, {\n    show_data(TRUE)\n    current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n  })\n  \n  observeEvent(input$show_data_50W, {\n    show_data(TRUE)\n    current_data(data.frame(t_s = t_data_50W, VO2_t = VO2_data_50W))\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    \n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      if (df$t_s[1] != 0.0) {\n        df$t_s &lt;- df$t_s - df$t_s[1]\n      }\n      \n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die CSV-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Funktion zur Berechnung des Grundumsatzes\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  # Funktion zur Berechnung des RMR\n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2,Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  observeEvent(input$fit_tau, {\n    if (fit_mode() == \"three_steps\" && show_data()) {\n      Beispieldaten &lt;- current_data()\n      if (is.null(Beispieldaten)) return(p)\n      \n      t_delay &lt;- isolate(input$t_delay)\n      C &lt;- isolate(input$VO2_Ruhe)\n      \n      # Datenfilterung und Zeitverschiebung\n      filtered_data &lt;- Beispieldaten %&gt;%\n        filter(t_s &gt;= t_delay) %&gt;%\n        mutate(t_s = t_s - t_delay)\n      \n      model_tau &lt;- nlsLM(VO2_t ~ x * exp(-t_s/Tau) + C, \n                         data = filtered_data,\n                         start = list(x = max(filtered_data$VO2_t), Tau = 45, C = C),\n                         lower = c(x = 0, Tau = 10, C = 0),\n                         upper = c(x = Inf, Tau = 600, C = Inf),\n                         control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n      \n      tau_estimate(round(as.list(coef(model_tau))$Tau, 1))\n      \n      updateSliderInput(session, \"TauA\", value = tau_estimate())\n      updateSliderInput(session, \"A\", value = as.list(coef(model_tau))$x)\n      updateSliderInput(session, \"C\", value = as.list(coef(model_tau))$C)\n      \n      # Set B and TauB sliders to 0\n      updateSliderInput(session, \"B\", value = 0)\n      updateSliderInput(session, \"TauB\", value = 0)\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    if (fit_mode() == \"three_steps\") {\n      req(tau_estimate())\n      if (show_data()) {\n        Beispieldaten &lt;- current_data()\n        \n        VO2_Basis &lt;- if(input$fit_mit == \"ruhe\") input$VO2_Ruhe else input$VO2_Referenz\n        t_delay &lt;- isolate(input$t_delay)\n        max_VO2 &lt;- max(Beispieldaten$VO2_t) * 1.1\n        \n        tau2 &lt;- 2 * tau_estimate()\n        tau8 &lt;- 8 * tau_estimate()\n        last_data_point &lt;- max(Beispieldaten$t_s)\n        \n        actual_data_count &lt;- sum(Beispieldaten$t_s &gt;= tau2)\n        \n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        ruhe_sim_end &lt;- input$ruhe_sim_range[2]\n        \n        simulated_time_points &lt;- seq(ruhe_sim_start, ruhe_sim_end, length.out = actual_data_count)\n        \n        ruhe_sim_data &lt;- data.frame(\n          t_s = simulated_time_points,\n          VO2_t = rep(VO2_Basis, actual_data_count)  # Hier VO2_Basis statt VO2_Ruhe verwenden\n        )\n        \n        ruhe_sim(ruhe_sim_data)\n        max_ruhe_t_s(max(ruhe_sim_data$t_s))\n        \n        Beispieldaten_extended &lt;- rbind(Beispieldaten, ruhe_sim_data)\n        \n        filtered_data &lt;- Beispieldaten_extended %&gt;% \n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &gt;= tau2)\n        \n        model_slow &lt;- nlsLM(VO2_t ~ B * exp(-t_s/TauB) + VO2_Basis,\n                            data = filtered_data,\n                            start = list(B = 0.5, TauB = 540),\n                            lower = c(B = 0.1, TauB = 90),\n                            upper = c(B = (max_VO2 * 0.5), TauB = 3600),\n                            control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n        \n        slow_estimates_list &lt;- list(\n          B = as.numeric(coef(model_slow)[\"B\"]),\n          TauB = round(as.numeric(coef(model_slow)[\"TauB\"]), 1),\n          C = VO2_Basis\n        )\n        \n        slow_estimates(slow_estimates_list)\n        \n        updateSliderInput(session, \"B\", value = slow_estimates_list$B)\n        updateSliderInput(session, \"TauB\", value = slow_estimates_list$TauB)\n        updateSliderInput(session, \"C\", value = VO2_Basis)  # Hier VO2_Basis statt VO2_Ruhe verwenden\n      }\n    }\n  })\n  \n  observeEvent(input$fit_full, {\n    if (fit_mode() == \"three_steps\") {\n      req(tau_estimate(), slow_estimates())\n      if (show_data()) {\n        Beispieldaten &lt;- current_data()\n        \n        slow_est &lt;- slow_estimates()\n        t_delay &lt;- isolate(input$t_delay)\n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        \n        if (is.null(tau_estimate()) || is.null(slow_est)) {\n          showNotification(\"Einige Schätzwerte fehlen. Bitte führen Sie Schritt 1 und 2 erneut aus.\", type = \"error\")\n          return()\n        }\n        \n        start_params &lt;- list(\n          A = isolate(input$A),\n          TauA = tau_estimate()\n        )\n        \n        # Definiere eine Funktion mit festen Werten für B, TauB und C\n        model_func &lt;- function(t_s, A, TauA) {\n          A * exp(-t_s/TauA) + slow_est$B * exp(-t_s/slow_est$TauB) + slow_est$C\n        }\n        \n        # Berechne 2tau\n        tau2 &lt;- 2 * tau_estimate()\n        \n        # Datenfilterung und Zeitverschiebung\n        Beispieldaten_gefiltert &lt;- Beispieldaten %&gt;%\n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &lt; (ruhe_sim_start - t_delay))  # Entferne simulierte Ruhewerte\n        \n        # Erstelle Gewichte basierend auf t_s\n        weights &lt;- ifelse(Beispieldaten_gefiltert$t_s &lt;= tau2, 1, 1)\n        \n        tryCatch({\n          model_full &lt;- nlsLM(VO2_t ~ model_func(t_s, A, TauA),\n                              data = Beispieldaten_gefiltert,\n                              start = list(A = 2.5, TauA = 42),\n                              lower = c(A = 1.0, TauA = 15),\n                              upper = c(A = 4.0, TauA = 90),\n                              weights = weights,\n                              control = nls.lm.control(maxiter = 1024, ftol = 1e-10, ptol = 1e-10))\n          \n          full_estimates &lt;- list(\n            A = as.numeric(coef(model_full)[\"A\"]),\n            TauA = round(as.numeric(coef(model_full)[\"TauA\"]), 1)\n          )\n          \n          updateSliderInput(session, \"A\", value = full_estimates$A)\n          updateSliderInput(session, \"TauA\", value = full_estimates$TauA)\n          \n          showNotification(\"Fitting erfolgreich abgeschlossen\", type = \"message\")\n        }, error = function(e) {\n          showNotification(paste(\"Fehler beim Fitting:\", e$message), type = \"error\")\n        })\n      }\n    }\n  })\n  \n  observeEvent(input$toggle_view, {\n    show_full_view(!show_full_view())\n  })\n  \n  observeEvent(input$fit_all, {\n    if (show_data()) {\n      if (fit_mode() == \"three_steps\") {\n        # Trigger fit_tau\n        shinyjs::click(\"fit_tau\")\n        \n        # Warte kurz, bevor der nächste Fit ausgeführt wird\n        Sys.sleep(0.5)\n        \n        # Trigger fit_slow\n        shinyjs::click(\"fit_slow\")\n        \n        # Warte kurz, bevor der nächste Fit ausgeführt wird\n        Sys.sleep(0.5)\n        \n        # Trigger fit_full\n        shinyjs::click(\"fit_full\")\n        \n        showNotification(\"Alle Fits wurden nacheinander durchgeführt.\", type = \"message\")\n      } else if (fit_mode() == \"one_step\") {\n        Beispieldaten &lt;- current_data()\n        \n        t_delay &lt;- isolate(input$t_delay)\n        C &lt;- if(input$fit_mit == \"ruhe\") isolate(input$VO2_Ruhe) else isolate(input$VO2_Referenz)\n        \n        best_fit &lt;- NULL\n        best_rss &lt;- Inf\n        \n        withProgress(message = 'Fitting in progress', value = 0, {\n          for (i in 1:100) {\n            # Randomisierte Startwerte\n            A_start &lt;- runif(1, 1.5, 6)\n            TauA_start &lt;- runif(1, 20, 90)\n            B_start &lt;- runif(1, 0.3, 1.0)\n            TauB_start &lt;- runif(1, 300, 900)\n            \n            start_values &lt;- list(A = A_start, TauA = TauA_start, B = B_start, TauB = TauB_start)\n            \n            model_equation &lt;- VO2_t ~ A * exp(-(t_s - t_delay) / TauA) + B * exp(-(t_s - t_delay) / TauB) + C\n            \n            fit &lt;- try(nlsLM(model_equation,\n                             data = Beispieldaten,\n                             start = start_values,\n                             lower = c(A = 1.5, TauA = 20, B = 0.3, TauB = 90),\n                             upper = c(A = 6, TauA = 90, B = 3.0, TauB = 900),\n                             control = nls.control(maxiter = 1024)), silent = TRUE)\n            \n            if (!inherits(fit, \"try-error\")) {\n              rss &lt;- sum(residuals(fit)^2)\n              if (rss &lt; best_rss) {\n                best_rss &lt;- rss\n                best_fit &lt;- fit\n              }\n            }\n            \n            incProgress(1/100, detail = paste(\"Iteration\", i))\n          }\n        })\n        \n        if (!is.null(best_fit)) {\n          params &lt;- as.list(coef(best_fit))\n          updateSliderInput(session, \"A\", value = params$A)\n          updateSliderInput(session, \"TauA\", value = params$TauA)\n          updateSliderInput(session, \"B\", value = params$B)\n          updateSliderInput(session, \"TauB\", value = params$TauB)\n          \n          showNotification(\"Fitting completed successfully!\", type = \"message\")\n        } else {\n          showModal(modalDialog(\n            title = \"nlsLM fehlgeschlagen\",\n            \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n            easyClose = TRUE,\n            footer = NULL\n          ))\n        }\n      }\n    } else {\n      showNotification(\"Bitte fügen Sie zuerst Daten ein.\", type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    A &lt;- input$A\n    TauA &lt;- input$TauA\n    B &lt;- input$B\n    TauB &lt;- input$TauB\n    C &lt;- input$C\n    O2_Store &lt;- input$O2_Store\n    t_delay &lt;- input$t_delay\n    VO2_Basis &lt;- if(input$fit_mit == \"ruhe\") input$VO2_Ruhe else input$VO2_Referenz\n    \n    # Bestimmen des x-Achsen-Bereichs\n    x_range &lt;- if (show_full_view()) {\n      c(0, max_ruhe_t_s())\n    } else {\n      max_x_value &lt;- max(600, if (!is.null(current_data())) max(current_data()$t_s) else 600)\n      c(0, max_x_value * 1.1)  # Erhöhung um 10%\n    }\n    \n    max_x &lt;- max(max_ruhe_t_s(), 600 + 0.5 * TauB, max(t_data))\n    \n    Beispieldaten &lt;- current_data()\n    \n    if (!is.null(current_data())) {\n      max_y &lt;- max((A + B + C) * 1.1, max(current_data()$VO2_t) * 1.1)\n    } else {\n      max_y &lt;- (A + B + C) * 1.1\n    }\n    \n    t_s &lt;- seq(0, max_x, by = 1)\n    \n    model_values &lt;- A * exp(-t_s / TauA) + B * exp(-t_s / TauB) + C\n    model_fast &lt;- A * exp(-t_s / TauA)\n    model_slow &lt;- B * exp(-t_s / TauB)\n    model_ruhe &lt;- rep(C, length(t_s))\n    \n    model_fast_func &lt;- function(t_s) A * exp(-t_s / TauA)\n    integrated_model_fast &lt;- integrate(model_fast_func, lower = 0, upper = max(t_s))\n    \n    VO2_fast &lt;- integrated_model_fast$value / 60\n    CE_max &lt;- 21.1307796\n    WPCR &lt;- VO2_fast * CE_max\n    WPCR_corrected &lt;- ifelse(VO2_fast &lt; O2_Store, 0, (VO2_fast * CE_max) - (O2_Store * CE_max))\n    \n    cumulative_area &lt;- cumsum(A * exp(-t_s / TauA)) * diff(t_s)[1]\n    O2_Store_index &lt;- which.min(abs(cumulative_area - O2_Store * 60))\n    O2_Store_x &lt;- t_s[O2_Store_index]\n    \n    last_data_point &lt;- if (!is.null(current_data())) max(current_data()$t_s) else 0\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * e&lt;sup&gt;-t / %.1f&lt;/sup&gt; + %.2f * e&lt;sup&gt;-t / %.1f&lt;/sup&gt; + %.2f\", \n                       A, TauA, B, TauB, C)\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines', \n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_fast, type = 'scatter', mode = 'lines', \n                name = 'EPOC&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_slow, type = 'scatter', mode = 'lines', \n                name = 'EPOC&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      add_trace(x = ~t_s, y = ~model_ruhe, type = 'scatter', mode = 'lines', \n                name = 'C', line = list(color = '#1CADE4')) %&gt;%\n      add_ribbons(x = ~t_s, ymin = 0, ymax = ~model_fast, \n                  name = 'EPOC&lt;sub&gt;fast,Integriert&lt;/sub&gt;', fillcolor = 'rgba(66,186,151,0.5)', \n                  line = list(color = \"rgba(0,0,0,0)\")) %&gt;%\n      add_ribbons(x = ~t_s, ymin = 0, ymax = ~model_fast, \n                  data = data.frame(t_s = t_s[1:O2_Store_index], model_fast = model_fast[1:O2_Store_index]),\n                  fillcolor = 'rgba(0,131,143,0.3)', line = list(color = \"rgba(0,0,0,0)\", dash = \"dash\"), \n                  name = 'O&lt;sub&gt;2&lt;/sub&gt;-Speicher') %&gt;%\n      add_trace(x = c(O2_Store_x, O2_Store_x), y = c(0, max(model_fast[O2_Store_index])),\n                type = 'scatter', mode = 'lines', \n                line = list(color = \"#00838F\", width = 1, dash = \"dash\"),\n                name = 'O2 Store Linie', showlegend = FALSE) %&gt;%\n      add_segments(x = 2 * TauA, xend = 2 * TauA, y = 0, yend = max_y,\n                   line = list(color = \"gray\", width = 0.5, dash = \"dash\"),\n                   showlegend = FALSE) %&gt;%\n      layout(title = \"EPOC-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"Zeit [s]\", range = x_range, autorange = FALSE),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", range = c(0, max_y)),\n             annotations = list(\n               list(\n                 x = 2 * TauA, y = max_y * 0.75, text = sprintf(\"2tau: %.1f\", 2 * TauA), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11, color = \"darkgrey\")\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.85,\n                 text = paste(\"W&lt;sub&gt;PCR&lt;/sub&gt;:\", round(WPCR, 2), \"kJ\"),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.75,\n                 text = paste(\"W&lt;sub&gt;PCR, korrigiert&lt;/sub&gt;:\", round(WPCR_corrected, 2), \"kJ\"),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.10, \n                 y = max_y * 0.95,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   size = 12,\n                   color = \"black\"\n                 )\n               )\n             ))\n    \n    if (show_data()) {\n      Beispieldaten &lt;- current_data()\n      if (!is.null(Beispieldaten)) {\n        ruhe_sim_start &lt;- input$ruhe_sim_range[1]\n        \n        # Datenfilterung und Zeitverschiebung\n        Beispieldaten &lt;- Beispieldaten %&gt;%\n          filter(t_s &gt;= t_delay) %&gt;%\n          mutate(t_s = t_s - t_delay) %&gt;%\n          filter(t_s &lt; (ruhe_sim_start - t_delay))  # Entferne simulierte Ruhewerte\n        \n        last_data_point &lt;- max(Beispieldaten$t_s)\n        \n        # Füge last_data_point Linie und Annotation hinzu\n        p &lt;- p %&gt;% add_segments(x = last_data_point, xend = last_data_point, y = 0, yend = max_y,\n                                line = list(color = \"gray\", width = 0.5, dash = \"dash\"),\n                                showlegend = FALSE)\n        \n        p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                    list(\n                                      list(\n                                        x = last_data_point, y = max_y * 0.75, text = sprintf(\"t&lt;sub&gt;data_last&lt;/sub&gt;: %.1f\", last_data_point), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                                        textangle = -90, font = list(size = 11, color = \"darkgrey\")\n                                      )\n                                    ))\n        \n        model_values_at_data &lt;- A * exp(-Beispieldaten$t_s / TauA) + B * exp(-Beispieldaten$t_s / TauB) + C\n        \n        data_subset &lt;- Beispieldaten\n        \n        ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data)^2, na.rm = TRUE)\n        ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n        r_squared &lt;- 1 - (ss_res / ss_tot)\n        \n        p &lt;- p %&gt;%\n          add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                    name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                    marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                    line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n        \n        if (show_full_view()) {\n          ruhe_sim &lt;- data.frame(\n            t_s = seq(input$ruhe_sim_range[1], input$ruhe_sim_range[2], by = 1),\n            VO2_t = rep(VO2_Basis, input$ruhe_sim_range[2] - input$ruhe_sim_range[1] + 1)\n          )\n          \n          p &lt;- p %&gt;%\n            add_trace(data = ruhe_sim, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                      name = 'Sim. Ruhewerte', \n                      marker = list(color = '#1CADE4', size = 3.0),\n                      line = list(color = '#1CADE4', width = 0.5, dash = '4 4'))\n        }\n        \n        p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                    list(\n                                      list(\n                                        x = max_x * 0.10,\n                                        y = max_y * 0.65,\n                                        text = sprintf(\"R²: %.3f\", r_squared),\n                                        showarrow = FALSE,\n                                        xanchor = 'left',\n                                        yanchor = 'bottom',\n                                        font = list(\n                                          family = \"Arial, sans-serif\",\n                                          size = 12,\n                                          color = \"black\"\n                                        )\n                                      )\n                                    ))\n      }\n    }\n    \n    p\n  })\n  \n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px;'&gt;\n    &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n    &lt;ol style='color: #555;'&gt;\n      &lt;li&gt;Beispiel-VO2-Daten (mit oder ohne Nachbelastung) einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n      &lt;li&gt;Ruhesauerstoffaufnahme (VO2 Ruhe) manuell eingeben oder anhand der Parameter (Geschlecht, Körpermasse, Alter, RQ) berechnen lassen.&lt;/li&gt;\n      &lt;li&gt;Bei Daten ohne Nachbelastung 'Mit VO2 Ruhe' wählen, bei Daten mit Nachbelastung 'VO2 Referenz' wählen und den entsprechenden Referenzwert festlegen.&lt;/li&gt;\n      &lt;li&gt;O2-Speicher festlegen oder auf 0 setzen, falls dieser in der Berechnung nicht berücksichtigt werden soll.&lt;/li&gt;\n      &lt;li&gt;Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n      &lt;li&gt;Wählen Sie zwischen 3-Schritt- oder 1-Schritt-Modellanpassung. Bei 3-Schritt-Anpassung den Zeitraum für simulierte Ruhe- bzw. Referenzwerte mit dem Slider einstellen.&lt;/li&gt;\n      &lt;li&gt;Modellanpassung durchführen:&lt;/li&gt;\n      &lt;ul&gt;\n        &lt;li&gt;'Fit: nlsLM' für komplette Anpassung oder&lt;/li&gt;\n        &lt;li&gt;Schrittweise: '1. Fit: Tau', '2. Fit: EPOC Slow', '3. Fit: EPOC Fast'&lt;/li&gt;\n      &lt;/ul&gt;\n      &lt;li&gt;Mit 'Ruhe_sim anzeigen' können simulierte Ruhewerte in der Abbildung ein- oder ausgeblendet werden.&lt;/li&gt;\n      &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n    &lt;/ol&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nA. Dreischritt-Modellanpassung:\n\nSchnelle Komponente (1. Fit: Tau):\n\nVerwendete Funktion: nlsLM\nParameter: x (entspricht A), Tau (entspricht TauA)\nModell: VO2_t ~ x · exp(-t_s/Tau) + C\nGrenzen:\n\nx: 0 bis Inf\nTau: 10 bis 600 s\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\nLangsame Komponente (2. Fit: EPOC Slow):\n\nVerwendete Funktion: nlsLM\nParameter: B, TauB\nModell: VO2_t ~ B · exp(-t_s/TauB) + VO2_Basis\nGrenzen:\n\nB: 0.1 bis (VO2_max · 0.5) l/min\nTauB: 90 bis 3600 s\n\nProzess:\n\nDatenauswahl: Verwendung der Daten ab 2 · Tau\nErweiterung der Daten mit simulierten Ruhe- oder Referenzwerten:\n\nZeitraum: Festgelegter Bereich der simulierten Werte (Standard: 3600-4200s)\nAnzahl der simulierten Werte: Gleiche Anzahl wie reale Datenpunkte ab dem Zeitpunkt 2 · Tau bis zum Start der simulierten Werte\nWert: Konstant auf VO2_Ruhe oder VO2_Referenz (je nach Auswahl)\n\n\nOptimierung: Minimierung der RSS\n\nVollständige Anpassung (3. Fit: EPOC Fast):\n\nVerwendete Funktion: nlsLM\nParameter: A, TauA\nModell: VO2_t ~ A · exp(-t_s/TauA) + B · exp(-t_s/TauB) + C (B, TauB und C aus vorherigen Modellanpassungen)\nGrenzen:\n\nA: 1.0 bis 4.0 l/min\nTauA: 15 bis 90 s\n\nProzess:\n\nDatenauswahl: Verwendung der Daten bis zum Beginn der simulierten Ruhe- oder Referenzwerte\n\nOptimierung: Minimierung der RSS\n\n\nB. Einschritt-Modellanpassung:\n\nVerwendete Funktion: nlsLM\nParameter: A, TauA, B, TauB\nModell: VO2_t ~ A · exp(-(t_s - t_delay) / TauA) + B · exp(-(t_s - t_delay) / TauB) + C\nGrenzen:\n\nA: 1.5 bis 6.0 l/min\nTauA: 20 bis 90 s\nB: 0.3 bis 3.0 l/min\nTauB: 90 bis 900 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der RSS\nKeine Verwendung von simulierten Ruhe- oder Referenzwerten",
    "crumbs": [
      "EPOC-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#asdfg",
    "href": "VO2.html#asdfg",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "asdf\n\nDie Funktion der automatischen Anpassung mittels nichtlinearer Regression ist noch nicht funktionsfähig.\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie Funktion der automatischen Anpassung mittels nichtlinearer Regression ist noch nicht funktionsfähig.\n\n\n\n\n\n\n\n\nCsv-Datei hochladen\n\n\n\nEs können VO2-Daten als csv-Datei in folgender Form hochgeladen werden: t_s,VO2 0,0.479 3.3,0.488 5.5,0.477 …,…",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Demo: Shinylive-Apps & webR",
    "section": "",
    "text": "In den folgenden Abschnitten werden Möglichkeiten zur interaktiven Gestaltung der Masterarbeit mittels verschiedener Shiny-Apps und webR-Anwendungen vorgestellt. Dazu zählt eine interaktive exponentielle V̇O₂-Modellfunktion, die den Anstieg des Sauerstoffvolumenstroms zu Beginn einer Belastung modelliert. Zudem wird eine interaktive bi-exponentielle EPOC-Modellfunktion dargestellt. Die unterschiedlichen Parameter der Modellfunktionen können mittels Schiebereglern angepasst werden. Darüber hinaus ist es möglich, eigene Daten in Form einer CSV-Datei hochzuladen. Zusätzlich ist eine interaktive Laktat-Leistungs-Beziehung in einer Shiny-App integriert, bei der die Datenpunkte ebenfalls interaktiv verändert werden können.\nDie automatische Anpassung mittels nichtlinearer Regression ist derzeit noch nicht funktionsfähig.\nIn der finalen Masterarbeit sollen weitere interaktive Shiny-Apps nach diesem Vorbild implementiert werden, um Berechnungen anschaulich darzustellen und die Nutzung sowie Berechnung verschiedener Parameter mit eigenen Daten zu ermöglichen.",
    "crumbs": [
      "Demo: Shinylive-Apps & webR"
    ]
  },
  {
    "objectID": "VO2_alt.html",
    "href": "VO2_alt.html",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung in Shiny\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"V̇O2-Modellfunktion\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"VO2\", \"V̇O2\", min = 0.0, max = 7.0, value = 1.7, step = 0.1),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.1),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 10, step = 1),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.4, step = 0.1),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      actionButton(\"optimize\", \"Fit: nlsLM\")\n    ),\n    mainPanel(\n      plotlyOutput(\"plot\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n  })\n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"V̇O2, Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n\n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      diffs &lt;- abs(Beispieldaten$t_s - t_delay)\n      row_index &lt;- which.min(diffs)\n      min_VO2 &lt;- Beispieldaten$VO2_t[row_index] # VO2 zum Zeitpunkt von t_delay\n      max_VO2 &lt;- max(Beispieldaten$VO2_t, na.rm = TRUE)\n      VO2_Ruhe &lt;- isolate(input$VO2_Ruhe)\n      \n      # Fitten des VO2_SS * (1 - exp(-(t_s-t_delay)/Tau)) + VO2_Start Terms mit den Startwerten für VO2_SS und C\n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau), VO2_Start = isolate(input$VO2_Start))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = Beispieldaten,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5, VO2_Start = 0.2),\n                       upper = c(VO2 = 7.0, Tau = 360, VO2_Start = 4.0),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- coef(fit)\n        updateSliderInput(session, \"VO2\", value = params[\"VO2\"])\n        updateSliderInput(session, \"Tau\", value = params[\"Tau\"])\n        updateSliderInput(session, \"VO2_Start\", value = params[\"VO2_Start\"])\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    \n    # Modellfunktion\n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.2f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"VO₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             xaxis = list(title = \"t [s]\"),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".1f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.85,\n                 y = max_y * 0.5,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.85,\n                 y = max_y * 0.4,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.85,\n                 y = max_y * 0.3,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.85,\n                 y = max_y * 0.2,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               )\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      # Modellwerte für die eingefügten Datenpunkte berechnen\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      # Beschränke die Daten auf den Zeitraum von t_delay bis max_t für die R²-Berechnung\n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= max_t, ]\n      \n      # R² berechnen\n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= max_t])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.85,\n            y = max_y * 0.1,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nnlsLM\n\n\n\nDie Funktion der automatischen Anpassung mittels nichtlinearer Regression ist noch nicht funktionsfähig.\n\n\n\n\n\n\n\n\nCSV-Datei hochladen\n\n\n\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden: t_s,VO2_t 0.0,0.479 1.0,0.459 2.3,0.488 3.5,0.477 …\n\n\n\n\n2 Anpassbarer und ausführbarer R-Code mit webR\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "VO2.html#historical-background",
    "href": "VO2.html#historical-background",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "2.1 Historical background",
    "text": "2.1 Historical background\nSauerstoffaufnahme-Kinetik untersucht die Veränderungsrate der pulmonalen Sauerstoffaufnahme (V̇O2) zu Beginn oder Ende körperlicher Belastung. Die Reaktion unterscheidet sich oberhalb und unterhalb der Gasaustauschschwelle (GXT) und verläuft phasenweise, abhängig von der relativen Belastungsintensität [@Hughson1982; @Hughson1990; @Barstow1994; @JonesPoole2005].\nBis ca. 1980 wurde die V̇O2-Reaktion auf Belastung meist als einzelne Exponentialfunktion ab Belastungsbeginn charakterisiert [@Hagberg1978; @Hagberg1980]. Dies war angemessen für Studien, die die Douglas-Bag-Methode der indirekten Kalorimetrie verwendeten, bei der die Anzahl der Datenpunkte in der Übergangsphase relativ gering und die Dauer jeder Probe vergleichsweise lang war (~30 s) [@HillLupton1923; @Henry1951]. Die Entwicklung von Breath-by-Breath-Messgeräten und die Mittelung wiederholter Belastungstests führten zur Unterscheidung von drei diskreten Phasen in den Gasaustauschprofilen [@WhippWasserman1972; @Linnarsson1974; @Whipp1982].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#three-phase-response",
    "href": "VO2.html#three-phase-response",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "2.2 Three phase response",
    "text": "2.2 Three phase response\nWhipp et al. [@Whipp1982] demonstrierten eine dreiphasige V̇O2-Reaktion bei moderater Intensität. Sie schlugen vor, dass ein abrupter V̇O2-Anstieg (Phase 1) durch ein erhöhtes Herzzeitvolumen vermittelt wurde, da eine veränderte gemischt-venöse PO2 aufgrund der Muskel-Lungen-Transitverzögerung zu Beginn der Belastung keinen Einfluss auf die V̇O2 in der Lunge haben würde.\nDie Phase 1-Reaktion wird daher als kardiodynamische Phase bezeichnet, da der V̇O2-Anstieg (~15 s) eine erhöhte Herzzeitvolumen widerspiegelt, die unabhängig von Veränderungen der Muskel-O2-Utilisation zu Beginn der Belastung auftritt [@Whipp1982].\nPhase 2 oder die Primärkomponente stellt einen exponentiellen V̇O2-Anstieg dar, der mit dem kontinuierlichen Anstieg des pulmonalen (und Muskel-) Blutflusses sowie der Rückkehr von desoxygeniertem Blut zusammenhängt. Diese Phase spiegelt eng die Anpassungen des oxidativen Stoffwechsels auf der Ebene der aktiven Skelettmuskulatur wider [@Grassi1996; @Rossiter1999].\nBei Belastungsintensitäten oberhalb der GXT wird die V̇O2-Reaktion komplexer. V̇O2 erreicht nach der primären V̇O2-Reaktion keinen Steady State mehr und steigt für mehrere Minuten weiter an, eine zusätzliche Komponente, die als Slow Component bezeichnet wird [@WhippWasserman1972; @PatersonWhipp1991; @Whipp1994].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#moderate-intensity-exercise",
    "href": "VO2.html#moderate-intensity-exercise",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.1 Moderate Intensity Exercise",
    "text": "3.1 Moderate Intensity Exercise\nIm moderaten Intensitätsbereich steigt die pulmonale V̇O2 monoexponentiell an und erreicht innerhalb von ~3 Minuten einen neuen Steady State [@Whipp1982; @Hughson1988; @Whipp1994]. Die V̇O2-Reaktion zeigt drei distinkte Antworten: eine sich langsam entwickelnde Reaktion (auch kardiodynamisch genannt), die Primärreaktion und den Steady State. V̇O2 steigt linear mit der Arbeitsrate um ~10 ml.min-1.W-1 an, und sobald der neue Steady State erreicht ist, befinden sich die ATP-Resynthese innerhalb der Myozyten und die Rate der ATP-Resynthese aus der oxidativen Phosphorylierung im Gleichgewicht [@Kindermann1979; @Faude2009].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#heavy-intensity-exercise",
    "href": "VO2.html#heavy-intensity-exercise",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.2 Heavy Intensity Exercise",
    "text": "3.2 Heavy Intensity Exercise\nSchwere Belastungsintensität wurde von einigen Autoren als Belastung oberhalb der GXT, aber unterhalb der kritischen Leistung (CP) beschrieben [@Hill1993]. Während schwerer Belastung gibt es einen größeren oxidativen Bedarf und das Erreichen des Steady States wird durch das Vorhandensein der V̇O2 Slow Component verzögert. Die mit dieser Art von Belastung verbundenen O2-Kosten steigen im Allgemeinen auf ~13 ml.min-1.W-1 an [@WhippWasserman1972; @PearceMilhorn1977; @WhippMahler1980; @BarstowMole1991]. Zusätzlich steigt die arterielle Laktatkonzentration über die Ausgangswerte an, erreicht jedoch ein Gleichgewicht (auf einem erhöhten Niveau) [@Billat2003].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#modelling-heavy-intensity",
    "href": "VO2.html#modelling-heavy-intensity",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.3 Modelling heavy intensity",
    "text": "3.3 Modelling heavy intensity\nDie Forschung ist sich uneinig darüber, ob die primäre V̇O2-Kinetik bei schwerer Belastungsintensität im Vergleich zu moderater Belastungsintensität verlangsamt ist. Dies könnte eine größere Zeitkonstante in der Primärkomponente oder eine zusätzliche Slow Component in V̇O2 widerspiegeln, die einen verzögerten Steady State auf einem Niveau über dem erreicht, das aus einer sub-GXT V̇O2/Arbeitsrate-Regression vorhergesagt wird, oder möglicherweise beides [@PatersonWhipp1991; @BarstowMole1991].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#severe-exercise-intensity",
    "href": "VO2.html#severe-exercise-intensity",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.4 Severe Exercise Intensity",
    "text": "3.4 Severe Exercise Intensity\nDer Bereich schwerer Intensität wurde als Belastung oberhalb der maximalen Laktat-Steady-State oder der kritischen Leistung beschrieben, da in diesem Bereich sowohl V̇O2 als auch arterielle Laktatkonzentration keinen Steady State erreichen [@GaesserPoole1996]. Es wurde allgemein gezeigt, dass sowohl V̇O2 als auch arterielle Laktatkonzentration unaufhaltsam ansteigen, bis Ermüdung eintritt, wobei zu diesem Zeitpunkt maximale V̇O2-Werte erreicht werden [@WassermanWhipp1975; @GaesserPoole1996].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "5.1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung",
    "text": "5.1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#bi-exponentiale-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#bi-exponentiale-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "5.2 Bi-exponentiale Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung",
    "text": "5.2 Bi-exponentiale Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#phase-1",
    "href": "VO2.html#phase-1",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "In Phase I, die in den ersten 10 bis 25 Sekunden auftritt, wird der Anstieg des V̇O2 primär durch ein erhöhtes Herzzeitvolumen und sekundär durch Veränderungen im gemischtvenösen O2-Gehalt und in den Lungengasspeichern verursacht [@Stirling2005]. Whipp et al. [@Whipp1982] beschrieben diese Phase als kardiodynamische Phase, da der plötzliche Anstieg des Herzzeitvolumens und des pulmonalen Blutflusses zu einem abrupten Anstieg von V̇O₂ und V̇CO₂ führt, bevor Stoffwechselprodukte die Lungen erreichen. In dieser Phase bleibt die Zusammensetzung des gemischtvenösen Blutes unverändert, und das Verhältnis R (V̇CO₂/V̇O₂) bleibt auf dem Ruheniveau. Die Formeln zur Beschreibung dieser Anstiege lauten:\n[ O_2 = _p (CaO_2 - C O_2) ] [ CO_2 = _p (C CO_2 - CaCO_2) ]\nHierbei ist (_p) der pulmonale Blutfluss. Diese Erkenntnisse verdeutlichen, dass der V̇O2-Anstieg (~15 s) in Phase I eine direkte Folge des erhöhten Herzzeitvolumens ist, unabhängig von Veränderungen der Muskel-O2-Utilisation zu Beginn der Belastung [aus Clark2014 nach Wassermann].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#phase-2",
    "href": "VO2.html#phase-2",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "2.1 Phase 2",
    "text": "2.1 Phase 2\nPhase 2 folgt auf Phase 1, und in dieser Phase gibt es einen schnellen, mono-exponential ähnlichen Anstieg der \\(\\dot{V}O_2\\) bis bei moderaten Belastungen unterhalb der LT innerhalb von ungefähr 3 Minuten konstanter Belastung einen Steady State erreicht wird.\nBei Belastungen oberhalb der LT erreicht der \\(\\dot{V}O_2\\) nach der primären Reaktion keinen Steady State mehr und steigt weiter an.\nDiese zusätzliche Komponente wird als Slow Component bezeichnet und in Phase 3 beschrieben [@Whipp1972; @PatersonWhipp1991; @Whipp1994].\nDiese Phase reflektiert eng die Anpassungen des oxidativen Stoffwechsels auf der Ebene der aktiven Skelettmuskulatur [@Sterling2005; @Siestema2020].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#phase-3",
    "href": "VO2.html#phase-3",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "2.2 Phase 3",
    "text": "2.2 Phase 3\nPhase III repräsentiert das neue Steady-State-Niveau des V̇O2, wenn es unterhalb der Laktatschwelle erreicht wird. Innerhalb von etwa 3 Minuten konstanter Belastung erreicht V̇O2 einen Steady State. Bei höheren Arbeitsraten folgt V̇O2(t) jedoch nicht der Steady-State-Reaktion. Stattdessen steigt der Sauerstoffverbrauch weiter an, über die typische Zeit hinaus, die zum Erreichen des Steady-State-Wertes benötigt wird. Dieser langsame Anstieg wird als langsame Komponente der Sauerstoffaufnahmekinetik bezeichnet und tritt allgemein 100 bis 200 Sekunden nach Beginn der Belastung auf. Die langsame Komponente kann entweder zu einem verzögerten submaximalen Steady State oder zu einem Steady State gleich dem V̇O2max führen, indem sie sich zu den metabolischen Anforderungen dieser Arbeitsrate addiert.\nDiskussionen über die Ursache der langsamen Komponente haben ergeben, dass das Blutlaktatprofil zwar gut mit ihrer zeitlichen Entwicklung korreliert, die Beziehung jedoch eher zufällig als kausal ist. Der wahrscheinlichste Mechanismus ist die Rekrutierung von Muskelfasern [Gaesser und Poole 1996]. Billat (2000) definiert die kritische Geschwindigkeit, vcrit, als die höchste Geschwindigkeit, bei der V̇O2 einen verzögerten, submaximalen Steady State erreichen kann. Hill und Ferguson (1999) zeigten, dass “vcrit die Schwellenintensität ist, oberhalb derer Belastung von ausreichender Dauer zum Erreichen von V̇O2max führt”. Dies wird verwendet, um die untere Grenze für schwere Belastung als “knapp über vcrit, was die höchste Arbeitsrate ist, die über einen längeren Zeitraum aufrechterhalten werden kann und nicht V̇O2max hervorruft” zu definieren.\nDie V̇O2 langsame Komponente sollte nicht mit dem Phänomen der V̇O2-Drift verwechselt werden, einem langsamen Anstieg des V̇O2 während längerer, submaximaler Belastung mit konstanter Leistungsabgabe. Im Gegensatz zur langsamen Komponente wird die V̇O2-Drift bei Leistungen weit unterhalb der Laktatschwelle beobachtet, und das Ausmaß des V̇O2-Anstiegs ist viel geringer [Stirling2015].\n\nUntersuchungen haben gezeigt, dass der “Gain” (VI2/∆WR) oberhalb der Laktatschwelle höher ist als bei moderater Belastung [@BarstowMole1991; @Zoladz1995; @TschakovskyHughson1999], was auf einen höheren O2-“Verbrauch” pro Arbeitsrateninkrement hinweist.\nCerretelli (1987) zeigte, dass bei quadratischer Belastung eine anfängliche schnelle Komponente der V̇O2- und V̇CO2-Anschaltreaktionen existiert, die etwa 30% der gesamten Steady-State-Änderung ausmacht [@Cerretelli1987.315].\n\n-Aus @Barstow1994: Die vorherrschende Phase-2-Reaktion steigt weiterhin exponentiell an, mit etwa der gleichen Zeitkonstante wie bei moderater Belastung, und ihre Amplitude bleibt linear zur Belastungsintensität. Allerdings wird in der Regel auch ein zusätzlicher, sich langsam entwickelnder Anstieg des VO2 beobachtet, der etwa 100-200 Sekunden nach Beginn der Belastung einsetzt. Dieser zusätzliche VO2-Anstieg verzögert das Erreichen eines Steady-States, erhöht den gesamten Sauerstoff-“Bedarf” der Übung und steht in statistischem Zusammenhang mit der Geschwindigkeit und dem Ausmaß des Blutlaktatanstiegs.\n-@Oezyner2001 fanden, dass der Wert von τStart für die Sauerstoffaufnahme im Durchschnitt bei 33 ± 16 s liegt, unabhängig von der Belastungshöhe. -Im Gegensatz dazu berichten andere Studien von einem Anstieg von τStart mit zunehmender Belastung (Linnarsson 1974). Wasserman et al. [@Wasserman1967] prognostizierten und fanden experimentell heraus, dass der Sauerstoffverbrauch bei schweren Arbeitsbelastungen länger ansteigt als bei moderaten Intensitäten. Henry und DeMoor [@Henry1956] stellten ebenfalls fest, dass die Zeit bis zum Erreichen eines stabilen Zustands der Sauerstoffaufnahme (VO2) mit steigender Arbeitslast zunimmt. Im Gegensatz dazu berichten Di Prampero et al. [@DiPrampero1970] und Margaria et al. [@Margaria1965], dass das Muster des VO2-Anstiegs zum stabilen Zustand unabhängig von der Arbeitsintensität gleich ist und dieser Anstieg durch einen einzigen exponentiellen Prozess beschrieben wird, wobei die Reaktionskonstante für alle Arbeitslasten gleich ist.\n\n\n\n\n\n\nAbbildung 2: Verlauf VO2 - leicht bis schwer (klein)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#verhalten-bei-verschiedenen-intensitäten",
    "href": "VO2.html#verhalten-bei-verschiedenen-intensitäten",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Moderate Intensität: Die pulmonale V̇O2steigt monoexponentiell und erreicht innerhalb von etwa 3 Minuten einen Steady State [@Whipp1982; @Hughson1988; @Whipp1994]. Die V̇O2 erhöht sich linear zur Arbeitsrate um etwa 10 ml·min-1·W-1. Sobald der Steady State erreicht ist, sind ATP-Resynthese und oxidative Phosphorylierung im Gleichgewicht [@Kindermann1979; @Faude2009].\nSchwere Intensität: Die schwere Intensität liegt zwischen der maximalen Leistungsfähigkeit (GXT) und der kritischen Leistung (CP) [@Hill1993]. Bei schwerer Belastung ist der oxidative Bedarf höher, und der Steady State verzögert sich durch die V̇O2 Slow Component. Die O2-Kosten steigen auf etwa 13 ml·min-1·W-1 [@WhippWasserman1972; @PearceMilhorn1977; @WhippMahler1980; @BarstowMole1991]. Die arterielle Laktatkonzentration steigt über die Ausgangswerte, erreicht aber ein erhöhtes Gleichgewicht [@Billat2003].\nSchwere Intensität: In der Forschung ist umstritten, ob die primäre V̇O2-Kinetik bei schwerer Belastung langsamer ist als bei moderater. Dies könnte auf eine größere Zeitkonstante oder eine zusätzliche Slow Component in V̇O2 hindeuten, die einen verzögerten Steady State über dem vorhergesagten Niveau erreicht [@PatersonWhipp1991; @BarstowMole1991].\nSehr schwere Intensität: Bei sehr schwerer Intensität, oberhalb des maximalen Laktat-Steady-State oder der kritischen Leistung, erreichen weder V̇O2 noch arterielle Laktatkonzentration einen Steady State [@GaesserPoole1996]. Beide steigen unaufhaltsam, bis Ermüdung eintritt und maximale V̇O2-Werte erreicht werden [@WassermanWhipp1975; @GaesserPoole1996].\n\n\n\n\n\n\n\n\n\nAbbildung 4: Beispiele der VO2-Anstiegskinetik bei einem Probanden für unterschiedliche Intensitäten: sehr intensiv, schwer, mittelschwer und moderat (von oben nach unten). Unterhalb der VO2-Daten ist der zugehörige Residuenplot zu sehen. In Spalte A ist das mono-exponentielle Modell und in Spalte B das doppel-exponentielle Modell dargestellt (Özyener 2001).",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#historical-background---clark2014",
    "href": "VO2.html#historical-background---clark2014",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.1 Historical background -> Clark2014",
    "text": "3.1 Historical background -&gt; Clark2014\nSauerstoffaufnahme-Kinetik untersucht die Veränderungsrate der pulmonalen Sauerstoffaufnahme (V̇O2) zu Beginn oder Ende körperlicher Belastung. Die Reaktion unterscheidet sich oberhalb und unterhalb der Gasaustauschschwelle (GXT) und verläuft phasenweise, abhängig von der relativen Belastungsintensität [@Hughson1982; @Hughson1990; @Barstow1994; @JonesPoole2005].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#ferretti2023-s.109-ff-noch-anschauen",
    "href": "VO2.html#ferretti2023-s.109-ff-noch-anschauen",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "3.2 Ferretti2023 S.109 ff noch anschauen",
    "text": "3.2 Ferretti2023 S.109 ff noch anschauen",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung-1",
    "href": "VO2.html#modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung-1",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "5.1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung",
    "text": "5.1 Modellfunktion des Sauerstoffvolumenstroms in Abhängigkeit von der Zeit während der Belastung\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nProzess:\n\nBestimmung des V̇O2_Start-Wertes:\n\nFinden des nächstgelegenen Zeitpunkts zu t_delay in den Daten\nSetzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses Punktes\n\nDatenauswahl:\n\nVerwendung der Daten zwischen t_delay und nlsLM_end\n\nStartwertebestimmung:\n\nVerwendung der aktuellen Slider-Werte für V̇O2 und Tau\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung des Levenberg-Marquardt-Algorithmus\nMaximale Iterationen: 1024\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#shiny-app-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#shiny-app-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#einteilung-der-vo2-kinetik-in-drei-phasen",
    "href": "VO2.html#einteilung-der-vo2-kinetik-in-drei-phasen",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Die Analyse der \\(\\dot{V}O_{2}\\)-Kinetik kann durch die Berücksichtigung von Zeitverzögerungen und/oder Exponentialfunktionen zweiter Ordnung verfeinert werden. Dazu kann die Anpassungsreaktion des \\(\\dot{V}O_{2}\\) nach Beginn der sportlichen Betätigung in drei Phasen unterteilt werden, wie in Abbildung 1 zu sehen [@Whipp1982]. Dies ermöglicht es, die erhöhte Komplexität der \\(\\dot{V}O_{2}\\)-Kinetik oberhalb der LT besser darzustellen und eine präzisere Analyse der physiologischen Anpassungen bei körperlicher Belastung durchzuführen, da oberhalb der LT der \\(\\dot{V}O_2\\)-Umsatz über 10 ml O2·W-1·min-1 steigt [@Barstow1994; @Bearden2000; @Siestema2020]. Die 3 Phasen lassen sich wie folgt beschreiben:\n\n\n\n\n\n\n\n\nAbbildung 1: Beispiel der Drei-Phasen der VO2-Kinetik bis zum Erreichen eines SS nach Beginn der Belastung (McNulty & Robergs, 2017)\n\n\n\n\n\n\n\n\n\n\n\nPhase 1: Phase I, häufig als kardiodynamische Phase bezeichnet, umfasst ungefähr die ersten 10 bis 25 Sekunden nach Beginn der Belastung. Aufgrund des schnellen Anstiegs des Herzzeitvolumens und des Lungenblutflusses zu Beginn der Belastung steigt \\(\\dot{V}O_2\\) abrupt an. In dieser Phase bleibt die Zusammensetzung des gemischtvenösen Blutes sowie der respiratorische Quotient (\\(RQ = \\frac{\\dot{V}CO_{2}}{\\dot{V}O_{2}}\\)) im Vergleich zum Ruhezustand unverändert. Somit ist der Anstieg des \\(\\dot{V}O_2\\) ausschließlich auf das erhöhte Herzminutenvolumen zurückzuführen, da sich die Sauerstoffkonzentration im arteriellen und venösen Blut (Ca und Cv) noch nicht verändert haben. Dies lässt sich mit Hilfe der Fick’schen Gleichung Gleichung 2 verdeutlichen [@Fick1855; @Whipp1982; @Stirling2005; @Clark2014; @Siestema2020].\n\\[\n\\dot{V}O_2 = \\dot{Q} \\cdot (C_a - C_v)\n\\tag{2}\\]\nDa die anfängliche „kardiodynamische“ Phase der \\(\\dot{V}O_2\\)-Reaktion nicht direkt den Sauerstoffumsatz der aktiven Muskulatur repräsentiert, werden in der Regel die ersten 20 bis 25 Sekunden von Phase I bei Modellierungen der \\(\\dot{V}O_2\\)-Kinetik aus der Modellanpassung ausgeschlossen [@Bearden2000; @Oezyener2001].\nPhase 2: Phase 2 folgt auf Phase 1 und ist durch einen schnellen, monoexponentiellen Anstieg des \\(\\dot{V}O_2\\) gekennzeichnet. Die Zeitkonstante beträgt im Durchschnitt etwa 30 [@Siestema2020] bis 33 Sekunden [@Oezyner2001]. Anschließend wird entweder ein SS erreicht oder der \\(\\dot{V}O_2\\) steigt weiter an, was dann in dem Modell als Phase 3 bezeichnet wird [@Stirling2005].\nPhase 3: In Phase 3 des \\(\\dot{V}O_2\\)-Modells wird bei leichten bis moderaten Belastungen unterhalb der Laktatschwelle (LT) nach etwa 3 Minuten ein stabiler Zustand (SS) erreicht. Dieses Verhalten beschreibt, wie der \\(\\dot{V}O_2\\) sich im 3-Phasen-Modell für Belastungen unterhalb der LT verhält. Bei Belastungen oberhalb der LT erreicht der \\(\\dot{V}O_2\\) nach der primären Anpassungsreaktion keinen SS mehr, sondern steigt weiter an (siehe Abbildung 2). Diese zusätzliche Komponente, meist als “slow component” bezeichnet und überlagert die anfängliche monoexponentielle Funktion aus Phase 2.\n\n\n\n\n\n\n\n\n\nAbbildung 2: Beispiele der VO2-Anstiegskinetik eines Probanden für verschiedene Belastungsintensitäten: sehr intensiv, schwer, mittelschwer und moderat (von oben nach unten). Unterhalb der VO2-Daten ist der entsprechende Residuenplot zu sehen. In Spalte A wird eine Modellfunktion mit mono-exponentieller Kurvenanpassung gezeigt, in Spalte B eine mit bi-exponentieller Anpassung (Özyener, 2001).\n\n\n\n\n\nMathematische Modellierungen haben gezeigt, dass die langsame Komponente etwa 90 bis 200 Sekunden nach Beginn des Übergangs einsetzt [@Whipp1972; @Barstow1991; @PatersonWhipp1991; @Whipp1994; @Bearden2000; @Siestema2020]. Die Komponente der Anpassungsreaktion bis zum Beginn der slow component wird in der Literatur oft als “primary component” oder “fundamental component” bezeichnet [@Barstow1994; @Oeyzener2001]. Im Folgenden wird diese Hauptkomponente mit dem Index “fast” gekennzeichnet.",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#footnotes",
    "href": "VO2.html#footnotes",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "Fußnoten",
    "text": "Fußnoten\n\n\nDie LT beschreibt den Punkt, an dem das Blutlaktat bei zunehmender Belastungsintensität über das Ruheniveau hinaus zu akkumulieren beginnt [@Siestema2020].↩︎",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#monoexponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#monoexponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Der Anstieg des Sauerstoffvolumenstroms (\\(\\dot{V}O_{2}\\)) zu Beginn einer leichten bis moderaten körperlichen Belastung auf dem Fahrradergometer unterhalb der Laktatschwelle (LT1) wurde traditionell in der Literatur als monoexponentiell beschrieben, mit einer Amplitude von ungefähr 9–10 ml O2·W-1·min-1 [@Barstow1991; @Bearden2000]. Die Zeitkonstante \\(\\tau_{\\text{Start}}\\) beschreibt die Geschwindigkeit, mit der der Sauerstoffvolumenstrom den Gleichgewichtszustand \\(\\dot{V}O_{2,\\text{gross, SS}}\\) erreicht. Dies lässt sich mit der folgenden Formel darstellen [@Hill1924; @Henry1956; @Margaria1965; @Whipp1971; @Oezyner2001; @Francescato2003; @Clark2014]:\n\\[\n\\dot{V}O_{2,\\text{Belastung}}(t) = \\dot{V}O_{2,\\text{gross, SS}} \\cdot \\left(1 - e^{-\\frac{t - TD}{\\tau_{\\text{Start}}}}\\right) + \\dot{V}O_{2,\\text{Start}}\n\\tag{1}\\]\nDabei beschreibt \\(\\dot{V}O_{2,\\text{Start}}\\) den Sauerstoffvolumenstrom zu Beginn der Belastung, und \\(\\dot{V}O_{2,\\text{net, SS}}\\) bezeichnet den Steady-State-Wert abzüglich des Ruhe-Sauerstoffvolumenstroms (\\(\\dot{V}O_{2, \\text{Ruhe}}\\)). In der folgenden Shiny-App wird ein Beispiel dieser Modellfunktion gezeigt, wie in Gleichung 1 beschrieben. Eigene \\(\\dot{V}O_{2}\\)-Daten können hochgeladen und mittels nichtlinearer Regression an die Beispieldaten angepasst werden.\n\n\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nProzess:\n\nBestimmung des V̇O2_Start-Wertes:\n\nFinden des nächstgelegenen Zeitpunkts zu t_delay in den Daten\nSetzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses Punktes\n\nDatenauswahl:\n\nVerwendung der Daten zwischen t_delay und nlsLM_end\n\nStartwertebestimmung:\n\nVerwendung der aktuellen Slider-Werte für V̇O2 und Tau\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung des Levenberg-Marquardt-Algorithmus\nMaximale Iterationen: 1024\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#mono-exponentielle-shiny-app",
    "href": "VO2.html#mono-exponentielle-shiny-app",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\n\n# Beispieldaten\nt_data &lt;- c(0, 2.8, 5.3, 8.6, 10.4, 15.2, 19.7, 22.5, 24.5, 26.2, 28.2, 31.6, 33.5, 35.3, 37, 38.5, 40.3, 41.9, 43.5, 45.2, 46.8, 48.4, 50, 51.5, 53.3, 54.8, 56.5, 57.9, 59.5, 61.1, 62.9, 64.3, 65.8, 67.7, 69.1, 70.7, 72.4, 73.9, 75.7, 77.2, 78.9, 80.5, 82.7, 84.1, 85.5, 87, 88.6, 90.2, 91.5, 92.9, 94.3, 95.8, 97.6, 99.1, 100.5, 102.1, 103.5, 105.3, 106.6, 108.1, 109.6, 111.4, 112.8, 114.3, 115.8, 117.7, 119.1, 120.8, 122.3, 124.2, 125.7, 127.2, 128.8, 131.1, 132.5, 133.9, 135.4, 136.9, 138.4, 140, 141.3, 143, 144.5, 146.1, 147.6, 149, 150.5, 152.3, 153.9, 155.6, 156.9, 158.6, 160.1, 162.4, 163.7, 165.1)\nVO2_data &lt;- c(0.465, 0.34, 0.466, 0.503, 0.452, 0.687, 0.846, 0.963, 0.936, 1.125, 1.238, 1.541, 1.395, 1.685, 1.689, 1.622, 1.917, 1.732, 1.835, 1.801, 1.664, 1.744, 1.891, 1.85, 1.858, 1.89, 2.108, 1.962, 1.992, 1.972, 2.026, 1.868, 1.949, 2.033, 1.887, 1.856, 2.112, 2.117, 2.129, 1.994, 2.03, 1.925, 1.916, 1.949, 1.956, 2.119, 1.894, 2.034, 1.766, 1.994, 1.985, 2.068, 1.796, 2.172, 2.09, 2.017, 2.152, 2.238, 2.027, 2.214, 2.159, 2.098, 1.963, 2.063, 2.292, 2.21, 1.84, 2.102, 2.1, 2.086, 2.008, 2.048, 1.978, 1.87, 2.16, 1.977, 2.335, 2.053, 2.084, 2.056, 2.005, 2.161, 2.088, 2.161, 2.078, 2.038, 2.117, 2.148, 2.043, 2.342, 2.142, 2.306, 2.043, 1.881, 1.918, 2.252)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"EPOC-Modellfunktion\"),\n  fluidRow(\n    column(3,\n     style = \"height: 90vh; overflow-y: auto;\",\n     \n      tags$h4(tags$strong(\"Modellparameter:\")),\n      sliderInput(\"VO2\", \"V̇O2 Amplitude\", min = 0.0, max = 7.0, value = 1.7, step = 0.001),\n      sliderInput(\"Tau\", \"Tau\", min = 5, max = 360, value = 23, step = 1.0),\n      sliderInput(\"VO2_Start\", \"V̇O2 Start\", min = 0.0, max = 4.0, value = 0.4, step = 0.001),\n      sliderInput(\"VO2_Ruhe\", \"V̇O2 Ruhe\", min = 0, max = 1, value = 0.3, step = 0.001),\n      sliderInput(\"time_delay\", \"Zeitverzögerung\", min = 0, max = 300, value = 11, step = 1),\n      conditionalPanel(\n        condition = \"output.showFitSlider\",\n        sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = max(t_data), value = max(t_data), step = 1)\n      ),\n      actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n      br(), br(),\n      fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n      tags$h4(tags$strong(\"Modelanpassung:\")),\n      actionButton(\"optimize\", \"nlsLM - Fit\"),\n      br(), br(),\n      tags$h4(tags$strong(\"Berechnung - Ruhesauerstoffaufnahme:\")),\n      radioButtons(\"geschlecht\", \"Geschlecht:\", choices = c(\"Männlich\", \"Weiblich\")),\n      sliderInput(\"koerpermasse\", \"Körpermasse [kg]:\", min = 40, max = 150, value = 55),\n      sliderInput(\"koerperlaenge\", \"Körperlänge [cm]:\", min = 140, max = 220, value = 160),\n      sliderInput(\"alter\", \"Alter [Jahre]:\", min = 18, max = 100, value = 24),\n      sliderInput(\"rq\", \"RQ:\", min = 0.7, max = 1.0, value = 0.77, step = 0.01),\n      actionButton(\"berechne_vo2_ruhe\", \"VO2 Ruhe berechnen\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    max_t &lt;- max(t_data)\n    updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      show_data(TRUE)\n      max_t &lt;- max(df$t_s)\n      updateSliderInput(session, \"nlsLM_end\", min = input$time_delay, max = max_t, value = max_t)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  # Neue Funktionen zur Berechnung des Grundumsatzes und RMR\n  berechne_grundumsatz &lt;- function(geschlecht, masse, laenge, alter) {\n    if (geschlecht == \"Männlich\") {\n      return(66.5 + (13.75 * masse) + (5.003 * laenge) - (6.775 * alter))\n    } else {\n      return(655.1 + (9.563 * masse) + (1.850 * laenge) - (4.676 * alter))\n    }\n  }\n  \n  berechne_rmr &lt;- function(grundumsatz, rq, geschlecht) {\n    ka &lt;- 19.946  # Annahme für RQ = 0.77, passen Sie dies an, wenn nötig\n    faktor &lt;- if(geschlecht == \"Männlich\") 1.287 else 1.278\n    return((grundumsatz / (24 * 60 * ka)) * 4.1868 * faktor)\n  }\n  \n  # Reaktion auf den Klick des \"VO2 Ruhe berechnen\" Buttons\n  observeEvent(input$berechne_vo2_ruhe, {\n    grundumsatz &lt;- berechne_grundumsatz(\n      input$geschlecht,\n      input$koerpermasse,\n      input$koerperlaenge,\n      input$alter\n    )\n    \n    rmr &lt;- berechne_rmr(grundumsatz, input$rq, input$geschlecht)\n    \n    # Aktualisieren Sie den VO2_Ruhe Slider mit dem berechneten Wert\n    updateSliderInput(session, \"VO2_Ruhe\", value = round(rmr, 3))\n    \n    # Zeigen Sie eine Benachrichtigung mit dem berechneten Wert an\n    showNotification(paste(\"Berechnete Ruhesauerstoffaufnahme:\", round(rmr, 3), \"l/min\"), type = \"message\")\n  })\n  \n  \n  \n  observe({\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  output$showFitSlider &lt;- reactive({\n    show_data()\n  })\n  outputOptions(output, \"showFitSlider\", suspendWhenHidden = FALSE)\n  \n  observeEvent(input$optimize, {\n    if (show_data()) {\n      Beispieldaten &lt;- if (is.null(uploaded_data())) {\n        data.frame(t_s = t_data, VO2_t = VO2_data)\n      } else {\n        uploaded_data()\n      }\n      \n      t_delay &lt;- isolate(input$time_delay)\n      nlsLM_end &lt;- isolate(input$nlsLM_end)\n      \n      # Finde den nächstgelegenen Zeitpunkt zu t_delay\n      closest_index &lt;- which.min(abs(Beispieldaten$t_s - t_delay))\n      \n      # Setze VO2_Start auf den gerundeten Wert des nächsten Punktes\n      VO2_Start &lt;- round(Beispieldaten$VO2_t[closest_index], 3)\n      \n      updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= nlsLM_end, ]\n      \n      start_values &lt;- list(VO2 = isolate(input$VO2), Tau = isolate(input$Tau))\n      \n      fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start,\n                       data = data_subset,\n                       start = start_values,\n                       lower = c(VO2 = 0.5, Tau = 5),\n                       upper = c(VO2 = 7.0, Tau = 360),\n                       control = nls.control(maxiter = 1024)), silent = TRUE)\n      \n      if (!inherits(fit, \"try-error\")) {\n        params &lt;- as.list(coef(fit))\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"Tau\", value = params$Tau)\n      } else {\n        showModal(modalDialog(\n          title = \"nlsLM fehlgeschlagen\",\n          \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n          easyClose = TRUE,\n          footer = NULL\n        ))\n      }\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    VO2 &lt;- input$VO2\n    Tau &lt;- input$Tau\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    nlsLM_end &lt;- input$nlsLM_end\n    \n    model_function &lt;- function(t_s, VO2, Tau, VO2_Start, t_delay) {\n      VO2 * (1 - exp(-(t_s - t_delay) / Tau)) + VO2_Start\n    }\n    \n    Beispieldaten &lt;- if (show_data() && !is.null(uploaded_data())) {\n      uploaded_data()\n    } else {\n      data.frame(t_s = t_data, VO2_t = VO2_data)\n    }\n    \n    tau4 &lt;- 4 * Tau\n    max_t &lt;- max(Beispieldaten$t_s, na.rm = TRUE)\n    max_x &lt;- max(1.05 * tau4 + t_delay, max_t * 1.05)\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, Tau, VO2_Start, t_delay), NA)\n    VO2_SS_gross &lt;- model_function(tau4 + t_delay, VO2, Tau, VO2_Start, t_delay)\n    VO2_SS_net &lt;- VO2_SS_gross - VO2_Ruhe\n    max_y &lt;- max(1.05 * VO2_SS_gross, max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05)\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.3f * (1 - e&lt;sup&gt;-(t - %.2f) / %.2f&lt;/sup&gt;) + %.3f\",\n                       VO2, t_delay, Tau, VO2_Start)\n    VO2_SS_gross_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,gross&lt;/sub&gt;: %.3f\", VO2_SS_gross)\n    VO2_SS_net_text &lt;- sprintf(\"V̇O₂ &lt;sub&gt;SS,net&lt;/sub&gt;: %.3f\", VO2_SS_net)\n    t_halb &lt;- Tau * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = Tau + t_delay, x1 = Tau + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = tau4 + t_delay, x1 = tau4 + t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      if (show_data()) {\n        list(\n          type = \"line\", x0 = nlsLM_end, x1 = nlsLM_end, y0 = 0, y1 = max_y * 1.2,\n          line = list(color = \"gray\", width = 1, dash = \"dash\")\n        )\n      },\n      list(\n        type = \"line\", x0 = 0, x1 = max_x, y0 = VO2_Ruhe, y1 = VO2_Ruhe,\n        line = list(color = '#1CADE4', width = 1, dash = \"solid\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      layout(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".3f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.6,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.5,\n                 text = VO2_SS_gross_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.4,\n                 text = VO2_SS_net_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.70,\n                 y = max_y * 0.3,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 12,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = Tau + t_delay, y = max_y * 0.9, text = sprintf(\"tau: %.1f\", Tau), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = tau4 + t_delay, y = max_y * 0.9, text = sprintf(\"4tau: %.1f\", tau4), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               if (show_data()) {\n                 list(\n                   x = nlsLM_end, y = max_y * 0.9, text = sprintf(\"nlsLM Ende: %.1f\", nlsLM_end), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                   textangle = -90, font = list(size = 11)\n                 )\n               }\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data()) {\n      model_values_at_data &lt;- model_function(Beispieldaten$t_s, VO2, Tau, VO2_Start, t_delay)\n      \n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end, ]\n      \n      ss_res &lt;- sum((data_subset$VO2_t - model_values_at_data[Beispieldaten$t_s &gt;= t_delay & Beispieldaten$t_s &lt;= input$nlsLM_end])^2, na.rm = TRUE)\n      ss_tot &lt;- sum((data_subset$VO2_t - mean(data_subset$VO2_t, na.rm = TRUE))^2, na.rm = TRUE)\n      r_squared &lt;- 1 - (ss_res / ss_tot)\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4')) %&gt;%\n        layout(annotations = list(\n          list(\n            x = max_x * 0.70,\n            y = max_y * 0.2,\n            text = sprintf(\"R²: %.3f\", r_squared),\n            showarrow = FALSE,\n            xanchor = 'left',\n            yanchor = 'bottom',\n            font = list(\n              family = \"Arial, sans-serif\",\n              size = 12,\n              color = \"black\"\n            )\n          )\n        ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n        &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n        &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n          &lt;li&gt;Beispiel VO2-Daten oder eigene VO2-Daten als CSV-Datei einfügen.&lt;/li&gt;\n          &lt;li&gt;Die Zeitverzögerung festlegen, um den Startpunkt der Modellanpassung zu bestimmen, und bei Bedarf das Ende der Anpassung anpassen.&lt;/li&gt;\n          &lt;li&gt;Modellanpassung 'Fit: nlsLM' durchführen.&lt;/li&gt;\n          &lt;li&gt;Alternativ: Manuelle Modellanpassung der Modellparameter mit den Schiebereglern.&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n        &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n        &lt;/pre&gt;\n      &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\nnlsLM - Fit:\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nProzess:\n\nBestimmung des V̇O2_Start-Wertes:\n\nFinden des nächstgelegenen Zeitpunkts zu t_delay in den Daten\nSetzen von V̇O2_Start auf den gerundeten V̇O2-Wert dieses Punktes\n\nDatenauswahl:\n\nVerwendung der Daten zwischen t_delay und nlsLM_end\n\nStartwertebestimmung:\n\nVerwendung der aktuellen Slider-Werte für V̇O2 und Tau\n\nDurchführung der nicht-linearen Regression:\n\nVerwendung des Levenberg-Marquardt-Algorithmus\nMaximale Iterationen: 1024\n\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#biexponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#biexponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Phase 2 und 3 des 3-Phasen-Modells lassen sich mit Hilfe der Gleichung 3 modellieren:\n\\[\n\\dot{V}O_2(t) = \\dot{V}O_{2,\\text{fast}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay, fast}}{\\tau_\\text{fast}}}\\right) +\n\\dot{V}O_{2,\\text{slow}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay,slow}}{\\tau_\\text{slow}}}\\right) +\n\\dot{V}O_{2,\\text{Start}}\n\\tag{3}\\]\n\\(\\dot{V}O_{2,\\text{fast}}\\) repräsentiert die Amplitude der Hauptkomponente, während \\(\\dot{V}O_{2,\\text{slow}}\\) die Amplitude der slow component beschreibt. Die Zeitkonstanten \\(\\tau_\\text{fast}\\) und \\(\\tau_\\text{slow}\\) steuern die Geschwindigkeit der jeweiligen Reaktionsprozesse, wobei die Zeitverzögerungen \\(t_\\text{delay, fast}\\) und \\(t_\\text{delay, slow}\\) den Beginn dieser Prozesse bestimmen. \\(\\dot{V}O_{2,\\text{Start}}\\) beschreibt den Sauerstoffvolumenstrom zu Beginn der Belastung.\nIn der folgenden Shiny-App wird die Modellanpassung der Gleichung Gleichung 3 an Beispieldaten demonstriert. Eigene \\(\\dot{V}O_{2}\\)-Daten können hochgeladen und mittels nichtlinearer Regression an die Modellparameter angepasst werden.",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#bi-exponentielle-shiny-app",
    "href": "VO2.html#bi-exponentielle-shiny-app",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten\nt_data &lt;- c(0.0, 2.7, 5.3, 8.3, 11.5, 13.6, 15.4, 17.1, 19.8, 21.1, 22.3, 23.5, 24.9, 27.5, 30.9, 32.4, 35.0, 38.3, 39.7, 41.6, 43.7, 45.3, 46.8, 49.8, 52.0, 53.6, 55.5, 57.5, 59.0, 60.7, 62.4, 64.4, 66.6, 68.1, 69.8, 71.4, 73.3, 75.0, 76.7, 78.4, 80.0, 82.2, 83.9, 85.4, 87.3, 88.8, 90.6, 92.0, 93.6, 94.8, 96.3, 97.9, 99.5, 101.1, 102.7, 104.3, 106.0, 107.7, 109.3, 110.9, 112.5, 114.8, 116.4, 118.1, 119.7, 121.3, 122.8, 124.3, 125.9, 127.4, 128.9, 130.6, 132.1, 133.6, 135.6, 137.1, 138.6, 140.1, 141.6, 143.1, 144.4, 145.8, 147.2, 148.4, 149.9, 151.6, 153.1, 154.7, 156.1, 157.4, 158.7, 160.5, 161.9, 163.3, 164.7, 166.2, 167.6, 169.1, 172.6, 173.9, 175.4, 176.7, 178.1, 179.6, 181.0, 182.4, 183.8, 185.3, 186.7, 188.2, 189.6, 191.0, 192.4, 193.8, 195.2, 196.6, 198.0, 199.3, 200.7, 202.0, 203.3, 204.7, 206.1, 207.5, 208.8, 210.2, 211.6, 213.0, 214.3, 215.7, 217.1, 218.4, 219.8, 221.1, 222.4, 223.7, 225.0, 226.3, 227.7, 229.0, 230.5, 231.9, 233.1, 234.4)\nVO2_data &lt;- c(0.823, 0.898, 0.966, 1.122, 1.281, 1.313, 1.463, 1.537, 1.602, 1.595, 1.598, 1.674, 1.923, 2.168, 2.439, 2.670, 2.797, 2.712, 2.688, 2.968, 3.228, 3.371, 3.673, 3.938, 4.076, 3.959, 3.886, 3.880, 3.928, 3.962, 4.173, 4.381, 4.268, 4.208, 4.234, 4.132, 4.109, 4.192, 4.304, 4.493, 4.352, 4.349, 4.332, 4.346, 4.345, 4.373, 4.320, 4.286, 4.353, 4.346, 4.287, 4.322, 4.250, 4.332, 4.257, 4.161, 4.120, 4.144, 4.115, 4.158, 4.186, 4.206, 4.220, 4.259, 4.291, 4.279, 4.295, 4.339, 4.371, 4.425, 4.448, 4.474, 4.517, 4.536, 4.544, 4.528, 4.432, 4.371, 4.367, 4.430, 4.492, 4.535, 4.510, 4.433, 4.399, 4.305, 4.308, 4.304, 4.366, 4.434, 4.501, 4.535, 4.512, 4.463, 4.509, 4.529, 4.586, 4.624, 4.740, 4.769, 4.788, 4.794, 4.824, 4.830, 4.888, 4.887, 4.915, 4.924, 4.955, 4.965, 4.982, 4.992, 5.016, 5.024, 5.033, 5.066, 5.081, 5.053, 5.035, 4.997, 5.018, 5.038, 5.035, 5.039, 4.970, 4.970, 4.973, 4.964, 4.945, 4.953, 4.974, 4.984, 4.997, 4.995, 4.946, 4.997, 5.014, 5.092, 5.072, 5.111, 5.088, 5.065, 5.061, 5.038)\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  titlePanel(\"Biexponentielle V̇O2-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"VO2\", \"V̇O2_fast\", min = 0.0, max = 7.0, value = 3.7, step = 0.01),\n           sliderInput(\"tau_fast\", \"Tau_fast\", min = 10, max = 120, value = 45, step = 0.1),\n           sliderInput(\"VO2_Start\", \"V̇O2_Start\", min = 0.0, max = 4.0, value = 0.8, step = 0.01),\n           sliderInput(\"VO2_Ruhe\", \"V̇O2_Ruhe\", min = 0, max = 1, value = 0.4, step = 0.1),\n           sliderInput(\"time_delay\", \"Zeitverzögerung_fast\", min = 0, max = 600, value = 0, step = 1),\n           sliderInput(\"VO2_slow\", \"V̇O2_slow\", min = 0.0, max = 1.0, value = 0.3, step = 0.01),\n           sliderInput(\"tau_slow\", \"Tau_slow\", min = 90, max = 600, value = 110, step = 0.1),\n           sliderInput(\"time_delay_slow\", \"Zeitverzögerung_slow\", min = 0, max = 1200, value = 160, step = 1),\n           conditionalPanel(\n             condition = \"output.showFitSlider\",\n             sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = 300, value = 300, step = 1)\n           ),\n           actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modellanpassung:\")),\n           actionButton(\"fit_fast\", \"1. Fit: Schnelle Komponente\"),br(),\n           actionButton(\"fit_slow\", \"2. Fit: Langsame Komponente & Verfeinerung\"),br(),\n           actionButton(\"fit_optimize\", \"3. Fit: Optimierung\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  current_data &lt;- reactiveVal(NULL)\n  current_r_squared &lt;- reactiveVal(NA)\n  \n  calculate_r_squared &lt;- function(observed, predicted) {\n    ss_res &lt;- sum((observed - predicted)^2, na.rm = TRUE)\n    ss_tot &lt;- sum((observed - mean(observed, na.rm = TRUE))^2, na.rm = TRUE)\n    return(1 - (ss_res / ss_tot))\n  }\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    if (show_data()) {\n      current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n    } else {\n      current_data(NULL)\n    }\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observe({\n    req(input$VO2_Start, input$VO2_Ruhe)\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  # Hilfsfunktion zur Bestimmung des nächstgelegenen VO2-Wertes\n  find_nearest_VO2 &lt;- function(data, t_delay) {\n    req(data, t_delay)\n    if (nrow(data) == 0) return(NA)\n    \n    index &lt;- which.min(abs(data$t_s - t_delay))\n    return(data$VO2_t[index])\n  }\n  \n  \n  observeEvent(input$fit_fast, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    t_delay &lt;- isolate(input$time_delay)\n    \n    # Bestimme den nächstgelegenen VO2-Wert als VO2_Start\n    VO2_Start &lt;- find_nearest_VO2(Beispieldaten, t_delay)\n    \n    # Aktualisiere den VO2_Start Slider\n    updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte innerhalb der Slider-Grenzen\n        VO2_start &lt;- runif(1, 0.5, 7.0)\n        tau_fast_start &lt;- runif(1, 10, 120)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = 0.5, tau_fast = 10),\n                         upper = c(VO2 = 7.0, tau_fast = 120),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"VO2\", value = params$VO2)\n      updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = 0)\n      updateSliderInput(session, \"tau_slow\", value = 0)\n      \n      predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 1 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    \n    # Setze VO2_slow und tau_slow auf die initialen Werte\n    VO2_slow &lt;- 0.4\n    tau_slow &lt;- 160\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Berechne die obere Grenze für t_delay_slow\n    t_delay_slow_upper &lt;- max(Beispieldaten$t_s)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    best_t_delay_slow &lt;- NULL\n    best_VO2_fast &lt;- VO2\n    best_tau_fast &lt;- tau_fast\n    best_VO2_slow &lt;- VO2_slow\n    best_tau_slow &lt;- tau_slow\n    \n    # Berechne die Anzahl der Iterationen für t_delay_slow\n    num_iterations &lt;- floor(t_delay_slow_upper - (tau_fast + t_delay)) + 1\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:num_iterations) {\n        t_delay_slow &lt;- tau_fast + t_delay + i - 1\n        \n        # Fit VO2_fast und tau_fast nach unten\n        current_VO2_fast &lt;- best_VO2_fast\n        current_tau_fast &lt;- best_tau_fast\n        current_VO2_slow &lt;- best_VO2_slow\n        current_tau_slow &lt;- best_tau_slow\n        \n        model &lt;- function(VO2_fast, tau_fast, VO2_slow, tau_slow, t_delay_slow) {\n          VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast)) + \n            VO2_slow * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow, 0)) / tau_slow)) + \n            VO2_Start\n        }\n        \n        current_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n        \n        # Optimiere VO2_fast und tau_fast\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_fast zu reduzieren\n          if (current_VO2_fast &gt; 0.1) {\n            new_VO2_fast &lt;- max(0.1, current_VO2_fast - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(new_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_fast &lt;- new_VO2_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_fast zu reduzieren\n          if (current_tau_fast &gt; 10) {\n            new_tau_fast &lt;- max(10, current_tau_fast - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, new_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_fast &lt;- new_tau_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Optimiere VO2_slow und tau_slow\n        # Zuerst nach unten\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu reduzieren\n          if (current_VO2_slow &gt; 0.05) {\n            new_VO2_slow &lt;- max(0.05, current_VO2_slow - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu reduzieren\n          if (current_tau_slow &gt; 90) {\n            new_tau_slow &lt;- max(90, current_tau_slow - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_slow &lt;- new_tau_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Dann nach oben\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu erhöhen\n          if (current_VO2_slow &lt; 1.0) {  # Angenommen, 1.0 ist die obere Grenze für VO2_slow\n            new_VO2_slow &lt;- min(1.0, current_VO2_slow + 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu erhöhen\n          new_tau_slow &lt;- current_tau_slow + 0.1\n          new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n          if (new_rss &lt; current_rss) {\n            current_tau_slow &lt;- new_tau_slow\n            current_rss &lt;- new_rss\n            improved &lt;- TRUE\n          }\n          \n          if (!improved) break\n        }\n        \n        if (current_rss &lt; best_rss) {\n          best_rss &lt;- current_rss\n          best_t_delay_slow &lt;- t_delay_slow\n          best_VO2_fast &lt;- current_VO2_fast\n          best_tau_fast &lt;- current_tau_fast\n          best_VO2_slow &lt;- current_VO2_slow\n          best_tau_slow &lt;- current_tau_slow\n        }\n        \n        incProgress(1 / num_iterations, detail = paste(\"Iteration\", i, \"von\", num_iterations))\n      }\n    })\n    \n    if (!is.null(best_t_delay_slow)) {\n      updateSliderInput(session, \"time_delay_slow\", value = best_t_delay_slow)\n      updateSliderInput(session, \"VO2\", value = best_VO2_fast)\n      updateSliderInput(session, \"tau_fast\", value = best_tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = best_VO2_slow)\n      updateSliderInput(session, \"tau_slow\", value = best_tau_slow)\n      \n      predicted &lt;- VO2_Start + best_VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / best_tau_fast)) +\n        best_VO2_slow * (1 - exp(-(pmax(data_subset$t_s - best_t_delay_slow, 0)) / best_tau_slow))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 2 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"Fit fehlgeschlagen\",\n        \"Die Anpassung für die langsame Komponente konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_optimize, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$time_delay_slow)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Werte aus Schritt 2\n    VO2_step2 &lt;- input$VO2\n    tau_fast_step2 &lt;- input$tau_fast\n    VO2_slow_step2 &lt;- input$VO2_slow\n    tau_slow_step2 &lt;- input$tau_slow\n    t_delay_slow_step2 &lt;- input$time_delay_slow\n    \n    # Berechne R² für Schritt 2\n    step2_predicted &lt;- VO2_Start + VO2_step2 * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast_step2)) +\n      VO2_slow_step2 * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow_step2, 0)) / tau_slow_step2))\n    step2_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step2_predicted)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Optimierung läuft', value = 0, {\n      for (i in 1:1000) {\n        # Randomisierte Startwerte innerhalb der festgelegten Grenzen\n        VO2_start &lt;- runif(1, VO2_step2 * 0.98, VO2_step2 * 1.02)\n        tau_fast_start &lt;- runif(1, max(10, tau_fast_step2 - 3), tau_fast_step2 + 3)\n        VO2_slow_start &lt;- runif(1, VO2_slow_step2 * 0.98, VO2_slow_step2 * 1.02)\n        tau_slow_start &lt;- runif(1, max(90, tau_slow_step2 - 3), tau_slow_step2 + 3)\n        t_delay_slow_start &lt;- runif(1, max(0, t_delay_slow_step2 - 5), t_delay_slow_step2 + 5)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start,\n          VO2_slow = VO2_slow_start,\n          tau_slow = tau_slow_start,\n          t_delay_slow = t_delay_slow_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + \n                           VO2_slow * (1 - exp(-(t_s - t_delay_slow) / tau_slow)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = VO2_step2 * 0.98, \n                                   tau_fast = max(10, tau_fast_step2 - 3), \n                                   VO2_slow = VO2_slow_step2 * 0.98, \n                                   tau_slow = max(90, tau_slow_step2 - 3), \n                                   t_delay_slow = max(0, t_delay_slow_step2 - 5)),\n                         upper = c(VO2 = VO2_step2 * 1.02, \n                                   tau_fast = tau_fast_step2 + 3, \n                                   VO2_slow = VO2_slow_step2 * 1.02, \n                                   tau_slow = tau_slow_step2 + 3, \n                                   t_delay_slow = t_delay_slow_step2 + 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/1000, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      step3_predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast)) +\n        params$VO2_slow * (1 - exp(-(pmax(data_subset$t_s - params$t_delay_slow, 0)) / params$tau_slow))\n      step3_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step3_predicted)\n      \n      if (step3_r_squared &gt; step2_r_squared) {\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n        updateSliderInput(session, \"VO2_slow\", value = params$VO2_slow)\n        updateSliderInput(session, \"tau_slow\", value = params$tau_slow)\n        updateSliderInput(session, \"time_delay_slow\", value = params$t_delay_slow)\n        \n        current_r_squared(step3_r_squared)\n        showNotification(sprintf(\"Optimierung erfolgreich. Neues R²: %.3f\", step3_r_squared), type = \"message\")\n      } else {\n        current_r_squared(step2_r_squared)\n        showNotification(sprintf(\"Kein besserer Fit gefunden. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n      }\n    } else {\n      current_r_squared(step2_r_squared)\n      showNotification(sprintf(\"Optimierung fehlgeschlagen. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    req(input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$VO2_Start, input$time_delay, input$time_delay_slow, input$VO2_Ruhe)\n    \n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    VO2_slow &lt;- input$VO2_slow\n    tau_slow &lt;- input$tau_slow\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    t_delay_slow &lt;- input$time_delay_slow\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    \n    model_function &lt;- function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast)) + \n        pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0) + \n        VO2_Start\n    }\n    \n    model_fast &lt;- function(t_s, VO2, tau_fast, t_delay) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast))\n    }\n    \n    model_slow &lt;- function(t_s, VO2_slow, tau_slow, t_delay_slow) {\n      pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0)\n    }\n    \n    Beispieldaten &lt;- current_data()\n    \n    max_t &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$t_s, na.rm = TRUE) else 300\n    max_x &lt;- max_t * 1.20\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    \n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow), NA)\n    fast_values &lt;- ifelse(t_s &gt;= t_delay, model_fast(t_s, VO2, tau_fast, t_delay), NA)\n    slow_values &lt;- ifelse(t_s &gt;= t_delay_slow, model_slow(t_s, VO2_slow, tau_slow, t_delay_slow), NA)\n    \n    max_y &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05 else max(model_values, na.rm = TRUE) * 1.05\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * (1 - e&lt;sup&gt;-(t - %.0f) / %.1f&lt;/sup&gt;) + %.2f * (1 - e&lt;sup&gt;-(t - %.1f) / %.0f&lt;/sup&gt;) + %.2f\",\n                       VO2, t_delay, tau_fast, VO2_slow, t_delay_slow, tau_slow, VO2_Start)\n    t_halb &lt;- tau_fast * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = t_delay_slow, x1 = t_delay_slow, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'V̇O2-Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~fast_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~slow_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      layout(title = \"Biexponentielle V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".1f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.3,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.2,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = t_delay_slow, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay_slow&lt;/sub&gt;: %.1f\", t_delay_slow), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               )\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data() && !is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) {\n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n      \n      model_values_at_data &lt;- model_function(data_subset$t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow)\n      \n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, model_values_at_data)\n      current_r_squared(r_squared)\n      \n      current_r_squared(r_squared)  # Aktualisieren Sie die reaktive Variable\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n      \n      p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                  list(\n                                    list(\n                                      x = max_x * 0.35,\n                                      y = max_y * 0.10,\n                                      text = sprintf(\"R²: %.3f\", current_r_squared()),\n                                      showarrow = FALSE,\n                                      xanchor = 'left',\n                                      yanchor = 'bottom',\n                                      font = list(\n                                        family = \"Arial, sans-serif\",\n                                        size = 10,\n                                        color = \"black\"\n                                      )\n                                    )\n                                  ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n      &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n      &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n        &lt;li&gt;Beispiel-VO2-Daten einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n        &lt;li&gt;Zeitverzögerung_fast festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n        &lt;li&gt;Schrittweise die Modellanpassung durchführen:\n          &lt;ol&gt;\n            &lt;li&gt;Fit: Schnelle Komponente&lt;/li&gt;\n            &lt;li&gt;Fit: Langsame Komponente Verfeinerung&lt;/li&gt;\n            &lt;li&gt;Fit: Optimierung&lt;/li&gt;\n          &lt;/ol&gt;\n        &lt;/li&gt;\n        &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n      &lt;/ol&gt;\n      &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n      &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n      &lt;/pre&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Schnelle Komponente (1. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast\nGrenzen:\n\nV̇O2_fast: 0.5 bis 7.0 l/min\ntau_fast: 10 bis 120 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n2. Langsame Komponente & Verfeinerung (2. Fit):\n\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nInitiale Werte (basierend auf Ozyener et al., 2001):\n\nV̇O2_slow: 0.4 l/min\ntau_slow: 160 s\n\nGrenzen:\n\nV̇O2_slow: 0.05 bis 1.0 l/min\ntau_slow: 90 bis Unendlich s\nt_delay_slow: tau_fast + t_delay bis max(t_s)\n\nProzess für t_delay_slow:\n\nBerechnung des Suchbereichs: von (tau_fast + t_delay) bis zum maximalen Zeitpunkt der Daten\nIteration durch jeden möglichen Wert in diesem Bereich (1-Sekunden-Schritte)\nFür jeden t_delay_slow-Wert:\n\nBerechnung der RSS mit festen Werten für V̇O2_slow (0.4 l/min) und tau_slow (160 s)\n\nAuswahl des t_delay_slow-Wertes mit der niedrigsten RSS\n\nOptimierung von V̇O2_fast und tau_fast:\n\nSchrittweise Reduzierung von V̇O2_fast (0.01 l/min) und tau_fast (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung bis keine Verbesserung mehr möglich\n\nOptimierung von V̇O2_slow und tau_slow:\n\nZunächst Reduzierung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nDann Erhöhung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung jeder Richtung bis keine Verbesserung mehr möglich\n\n\n3. Optimierung (3. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nGrenzen: Basierend auf den Ergebnissen von Schritt 2\n\nV̇O2_fast: ±2% des Wertes aus Schritt 2\ntau_fast: ±3 s des Wertes aus Schritt 2 (Minimum 10 s)\nV̇O2_slow: ±2% des Wertes aus Schritt 2\ntau_slow: ±3 s des Wertes aus Schritt 2 (Minimum 90 s)\nt_delay_slow: ±5 s des Wertes aus Schritt 2 (Minimum 0 s)\n\nProzess: 1000 Iterationen mit zufälligen Startwerten innerhalb der Grenzen\nOptimierung: Minimierung der RSS",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#umgang-mit-daten-in-dieser-arbeit-in-methodenteil",
    "href": "VO2.html#umgang-mit-daten-in-dieser-arbeit-in-methodenteil",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "In dieser Arbeit wurde der jeweilige Anstieg des \\(\\dot{V}O_{2}\\) nach Belastungsbeginn für jede Belastungsstufe wie folgt bearbeitet: Zunächst wurden aus den Atemzug-für-Atemzug \\(\\dot{V}O_{2}\\)-Daten die Ausreißer entfernt. Anschließend wurden die Daten durch einen gleitenden 3-Atemzug-Durchschnitt geglättet und der Kurvenanpassung unterzogen. Vor der Kurvenanpassung wurden die Daten bearbeitet, indem die Zeitverzögerung so gewählt wurde, dass die Phase-I-Daten der kardiorespiratorischen Antwort nicht in die Kurvenanpassung einbezogen wurden. Die Kurvenanpassung wurde dann mit Gleichung 3 an die jeweiligen Daten durchgeführt. Die Modellparameter der Kurvenanpassung wurden wie folgt gewählt:\n\n\n\n\n\n\nParameter - Kurvenanpassung:\n\n\n\n\n\n\nVerwendete Funktion: nlsLM\n\nMaximale Iterationen: 1024\nVerwendung des Levenberg-Marquardt-Algorithmus\n\nParameter: V̇O2 (Amplitude), Tau\nModell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start\nGrenzen:\n\nV̇O2: 0.5 bis 7.0 l/min\nTau: 5 bis 360 s\n\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n\n\n\n\n\nDiskussionen über die Ursache der langsamen Komponente haben ergeben, dass das Blutlaktatprofil zwar gut mit ihrer zeitlichen Entwicklung korreliert, die Beziehung jedoch eher zufällig als kausal ist. Der wahrscheinlichste Mechanismus ist die Rekrutierung von Muskelfasern [Gaesser und Poole 1996]. Billat (2000) definiert die kritische Geschwindigkeit, vcrit, als die höchste Geschwindigkeit, bei der V̇O2 einen verzögerten, submaximalen Steady State erreichen kann. Hill und Ferguson (1999) zeigten, dass “vcrit die Schwellenintensität ist, oberhalb derer Belastung von ausreichender Dauer zum Erreichen von V̇O2max führt”. Dies wird verwendet, um die untere Grenze für schwere Belastung als “knapp über vcrit, was die höchste Arbeitsrate ist, die über einen längeren Zeitraum aufrechterhalten werden kann und nicht V̇O2max hervorruft” zu definieren.\nDie V̇O2 langsame Komponente sollte nicht mit dem Phänomen der V̇O2-Drift verwechselt werden, einem langsamen Anstieg des V̇O2 während längerer, submaximaler Belastung mit konstanter Leistungsabgabe. Im Gegensatz zur langsamen Komponente wird die V̇O2-Drift bei Leistungen weit unterhalb der Laktatschwelle beobachtet, und das Ausmaß des V̇O2-Anstiegs ist viel geringer [Stirling2015].\n\nUntersuchungen haben gezeigt, dass der “Gain” (VI2/∆WR) oberhalb der Laktatschwelle höher ist als bei moderater Belastung [@BarstowMole1991; @Zoladz1995; @TschakovskyHughson1999], was auf einen höheren O2-“Verbrauch” pro Arbeitsrateninkrement hinweist.\nCerretelli (1987) zeigte, dass bei quadratischer Belastung eine anfängliche schnelle Komponente der V̇O2- und V̇CO2-Anschaltreaktionen existiert, die etwa 30% der gesamten Steady-State-Änderung ausmacht [@Cerretelli1987.315].\n\n-Aus @Barstow1994: Die vorherrschende Phase-2-Reaktion steigt weiterhin exponentiell an, mit etwa der gleichen Zeitkonstante wie bei moderater Belastung, und ihre Amplitude bleibt linear zur Belastungsintensität. Allerdings wird in der Regel auch ein zusätzlicher, sich langsam entwickelnder Anstieg des VO2 beobachtet, der etwa 100-200 Sekunden nach Beginn der Belastung einsetzt. Dieser zusätzliche VO2-Anstieg verzögert das Erreichen eines Steady-States, erhöht den gesamten Sauerstoff-“Bedarf” der Übung und steht in statistischem Zusammenhang mit der Geschwindigkeit und dem Ausmaß des Blutlaktatanstiegs.\n@Oezyner2001 fanden, dass der Wert von τStart für die Sauerstoffaufnahme im Durchschnitt bei 33 ± 16 s liegt, unabhängig von der Belastungshöhe. -Im Gegensatz dazu berichten andere Studien von einem Anstieg von τStart mit zunehmender Belastung (Linnarsson 1974). Wasserman et al. [@Wasserman1967] prognostizierten und fanden experimentell heraus, dass der Sauerstoffverbrauch bei schweren Arbeitsbelastungen länger ansteigt als bei moderaten Intensitäten. Henry und DeMoor [@Henry1956] stellten ebenfalls fest, dass die Zeit bis zum Erreichen eines stabilen Zustands der Sauerstoffaufnahme (VO2) mit steigender Arbeitslast zunimmt. Im Gegensatz dazu berichten Di Prampero et al. [@DiPrampero1970] und Margaria et al. [@Margaria1965], dass das Muster des VO2-Anstiegs zum stabilen Zustand unabhängig von der Arbeitsintensität gleich ist und dieser Anstieg durch einen einzigen exponentiellen Prozess beschrieben wird, wobei die Reaktionskonstante für alle Arbeitslasten gleich ist.\n\n\n\n\n\n\nAbbildung 3: Verlauf VO2 - leicht bis schwer (klein)",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#bi-exponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "href": "VO2.html#bi-exponentielle-modellfunktion-des-sauerstoffvolumenstroms-in-abhängigkeit-von-der-zeit-während-der-belastung",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "Phase 2 und 3 des 3-Phasen-Modells lassen sich mit Hilfe der Gleichung 3 modellieren:\n\\[\n\\dot{V}O_2(t) = \\dot{V}O_{2,\\text{fast}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay, fast}}{\\tau_\\text{fast}}}\\right) +\n\\dot{V}O_{2,\\text{slow}} \\cdot \\left(1 - e^{-\\frac{t_s - t_\\text{delay,slow}}{\\tau_\\text{slow}}}\\right) +\n\\dot{V}O_{2,\\text{Start}}\n\\tag{3}\\]\n\\(\\dot{V}O_{2,\\text{fast}}\\) repräsentiert die Amplitude der Hauptkomponente, während \\(\\dot{V}O_{2,\\text{slow}}\\) die Amplitude der slow component beschreibt. Die Zeitkonstanten \\(\\tau_\\text{fast}\\) und \\(\\tau_\\text{slow}\\) steuern die Geschwindigkeit der jeweiligen Reaktionsprozesse, wobei die Zeitverzögerungen \\(t_\\text{delay, fast}\\) und \\(t_\\text{delay, slow}\\) den Beginn dieser Prozesse bestimmen. \\(\\dot{V}O_{2,\\text{Start}}\\) beschreibt den Sauerstoffvolumenstrom zu Beginn der Belastung.\nIn der folgenden Shiny-App wird die Modellanpassung der Gleichung Gleichung 3 an Beispieldaten demonstriert. Eigene \\(\\dot{V}O_{2}\\)-Daten können hochgeladen und mittels nichtlinearer Regression an die Modellparameter angepasst werden.\n\n\n#| standalone: true\n#| viewerHeight: 900\n\nlibrary(shiny)\nlibrary(plotly)\nlibrary(minpack.lm)\nlibrary(dplyr)\nlibrary(shinyjs)\n\n# Beispieldaten\nt_data &lt;- c(0.0, 2.7, 5.3, 8.3, 11.5, 13.6, 15.4, 17.1, 19.8, 21.1, 22.3, 23.5, 24.9, 27.5, 30.9, 32.4, 35.0, 38.3, 39.7, 41.6, 43.7, 45.3, 46.8, 49.8, 52.0, 53.6, 55.5, 57.5, 59.0, 60.7, 62.4, 64.4, 66.6, 68.1, 69.8, 71.4, 73.3, 75.0, 76.7, 78.4, 80.0, 82.2, 83.9, 85.4, 87.3, 88.8, 90.6, 92.0, 93.6, 94.8, 96.3, 97.9, 99.5, 101.1, 102.7, 104.3, 106.0, 107.7, 109.3, 110.9, 112.5, 114.8, 116.4, 118.1, 119.7, 121.3, 122.8, 124.3, 125.9, 127.4, 128.9, 130.6, 132.1, 133.6, 135.6, 137.1, 138.6, 140.1, 141.6, 143.1, 144.4, 145.8, 147.2, 148.4, 149.9, 151.6, 153.1, 154.7, 156.1, 157.4, 158.7, 160.5, 161.9, 163.3, 164.7, 166.2, 167.6, 169.1, 172.6, 173.9, 175.4, 176.7, 178.1, 179.6, 181.0, 182.4, 183.8, 185.3, 186.7, 188.2, 189.6, 191.0, 192.4, 193.8, 195.2, 196.6, 198.0, 199.3, 200.7, 202.0, 203.3, 204.7, 206.1, 207.5, 208.8, 210.2, 211.6, 213.0, 214.3, 215.7, 217.1, 218.4, 219.8, 221.1, 222.4, 223.7, 225.0, 226.3, 227.7, 229.0, 230.5, 231.9, 233.1, 234.4)\nVO2_data &lt;- c(0.823, 0.898, 0.966, 1.122, 1.281, 1.313, 1.463, 1.537, 1.602, 1.595, 1.598, 1.674, 1.923, 2.168, 2.439, 2.670, 2.797, 2.712, 2.688, 2.968, 3.228, 3.371, 3.673, 3.938, 4.076, 3.959, 3.886, 3.880, 3.928, 3.962, 4.173, 4.381, 4.268, 4.208, 4.234, 4.132, 4.109, 4.192, 4.304, 4.493, 4.352, 4.349, 4.332, 4.346, 4.345, 4.373, 4.320, 4.286, 4.353, 4.346, 4.287, 4.322, 4.250, 4.332, 4.257, 4.161, 4.120, 4.144, 4.115, 4.158, 4.186, 4.206, 4.220, 4.259, 4.291, 4.279, 4.295, 4.339, 4.371, 4.425, 4.448, 4.474, 4.517, 4.536, 4.544, 4.528, 4.432, 4.371, 4.367, 4.430, 4.492, 4.535, 4.510, 4.433, 4.399, 4.305, 4.308, 4.304, 4.366, 4.434, 4.501, 4.535, 4.512, 4.463, 4.509, 4.529, 4.586, 4.624, 4.740, 4.769, 4.788, 4.794, 4.824, 4.830, 4.888, 4.887, 4.915, 4.924, 4.955, 4.965, 4.982, 4.992, 5.016, 5.024, 5.033, 5.066, 5.081, 5.053, 5.035, 4.997, 5.018, 5.038, 5.035, 5.039, 4.970, 4.970, 4.973, 4.964, 4.945, 4.953, 4.974, 4.984, 4.997, 4.995, 4.946, 4.997, 5.014, 5.092, 5.072, 5.111, 5.088, 5.065, 5.061, 5.038)\n\n# UI\nui &lt;- fluidPage(\n  useShinyjs(),\n  titlePanel(\"Bi-exponentielle V̇O2-Modellfunktion\"),\n  fluidRow(\n    column(3,\n           style = \"height: 90vh; overflow-y: auto;\",\n           \n           tags$h4(tags$strong(\"Modellparameter:\")),\n           sliderInput(\"VO2\", \"V̇O2_fast\", min = 0.0, max = 7.0, value = 3.7, step = 0.01),\n           sliderInput(\"tau_fast\", \"Tau_fast\", min = 10, max = 120, value = 45, step = 0.1),\n           sliderInput(\"VO2_Start\", \"V̇O2_Start\", min = 0.0, max = 4.0, value = 0.8, step = 0.01),\n           sliderInput(\"VO2_Ruhe\", \"V̇O2_Ruhe\", min = 0, max = 1, value = 0.4, step = 0.1),\n           sliderInput(\"time_delay\", \"Zeitverzögerung_fast\", min = 0, max = 600, value = 0, step = 1),\n           sliderInput(\"VO2_slow\", \"V̇O2_slow\", min = 0.0, max = 1.0, value = 0.3, step = 0.01),\n           sliderInput(\"tau_slow\", \"Tau_slow\", min = 90, max = 600, value = 110, step = 0.1),\n           sliderInput(\"time_delay_slow\", \"Zeitverzögerung_slow\", min = 0, max = 1200, value = 160, step = 1),\n           conditionalPanel(\n             condition = \"output.showFitSlider\",\n             sliderInput(\"nlsLM_end\", \"nlsLM Ende\", min = 10, max = 300, value = 300, step = 1)\n           ),\n           actionButton(\"toggle_data\", \"Beispieldaten einfügen\"),\n           br(), br(),\n           fileInput(\"file_upload\", \"CSV-Datei hochladen\", accept = \".csv\"),\n           tags$h4(tags$strong(\"Modellanpassung:\")),\n           actionButton(\"fit_fast\", \"1. Fit: Schnelle Komponente\"),br(),\n           actionButton(\"fit_slow\", \"2. Fit: Langsame Komponente & Verfeinerung\"),br(),\n           actionButton(\"fit_optimize\", \"3. Fit: Optimierung\")\n    ),\n    mainPanel(\n      width = 9,\n      plotlyOutput(\"plot\"),\n      uiOutput(\"instructions\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n  show_data &lt;- reactiveVal(FALSE)\n  uploaded_data &lt;- reactiveVal(NULL)\n  current_data &lt;- reactiveVal(NULL)\n  current_r_squared &lt;- reactiveVal(NA)\n  \n  calculate_r_squared &lt;- function(observed, predicted) {\n    ss_res &lt;- sum((observed - predicted)^2, na.rm = TRUE)\n    ss_tot &lt;- sum((observed - mean(observed, na.rm = TRUE))^2, na.rm = TRUE)\n    return(1 - (ss_res / ss_tot))\n  }\n  \n  observeEvent(input$toggle_data, {\n    show_data(!show_data())\n    if (show_data()) {\n      current_data(data.frame(t_s = t_data, VO2_t = VO2_data))\n    } else {\n      current_data(NULL)\n    }\n  })\n  \n  observeEvent(input$file_upload, {\n    req(input$file_upload)\n    df &lt;- read.csv(input$file_upload$datapath)\n    if (\"t_s\" %in% names(df) && \"VO2_t\" %in% names(df)) {\n      uploaded_data(df)\n      current_data(df)\n      show_data(TRUE)\n    } else {\n      showModal(modalDialog(\n        title = \"Invalid CSV\",\n        \"Die csv-Datei muss 't_s' und 'VO2_t' als Spaltennamen beinhalten.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observe({\n    req(input$VO2_Start, input$VO2_Ruhe)\n    if (input$VO2_Start &lt; input$VO2_Ruhe) {\n      updateSliderInput(session, \"VO2_Start\", value = input$VO2_Ruhe)\n    }\n  })\n  \n  # Hilfsfunktion zur Bestimmung des nächstgelegenen VO2-Wertes\n  find_nearest_VO2 &lt;- function(data, t_delay) {\n    req(data, t_delay)\n    if (nrow(data) == 0) return(NA)\n    \n    index &lt;- which.min(abs(data$t_s - t_delay))\n    return(data$VO2_t[index])\n  }\n  \n  \n  observeEvent(input$fit_fast, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    t_delay &lt;- isolate(input$time_delay)\n    \n    # Bestimme den nächstgelegenen VO2-Wert als VO2_Start\n    VO2_Start &lt;- find_nearest_VO2(Beispieldaten, t_delay)\n    \n    # Aktualisiere den VO2_Start Slider\n    updateSliderInput(session, \"VO2_Start\", value = VO2_Start)\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:100) {\n        # Randomisierte Startwerte innerhalb der Slider-Grenzen\n        VO2_start &lt;- runif(1, 0.5, 7.0)\n        tau_fast_start &lt;- runif(1, 10, 120)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = 0.5, tau_fast = 10),\n                         upper = c(VO2 = 7.0, tau_fast = 120),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/100, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      updateSliderInput(session, \"VO2\", value = params$VO2)\n      updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = 0)\n      updateSliderInput(session, \"tau_slow\", value = 0)\n      \n      predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 1 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"nlsLM fehlgeschlagen\",\n        \"Die nicht-lineare Regression mittels Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_slow, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    \n    # Setze VO2_slow und tau_slow auf die initialen Werte\n    VO2_slow &lt;- 0.4\n    tau_slow &lt;- 160\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Berechne die obere Grenze für t_delay_slow\n    t_delay_slow_upper &lt;- max(Beispieldaten$t_s)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    best_t_delay_slow &lt;- NULL\n    best_VO2_fast &lt;- VO2\n    best_tau_fast &lt;- tau_fast\n    best_VO2_slow &lt;- VO2_slow\n    best_tau_slow &lt;- tau_slow\n    \n    # Berechne die Anzahl der Iterationen für t_delay_slow\n    num_iterations &lt;- floor(t_delay_slow_upper - (tau_fast + t_delay)) + 1\n    \n    withProgress(message = 'Fitting in progress', value = 0, {\n      for (i in 1:num_iterations) {\n        t_delay_slow &lt;- tau_fast + t_delay + i - 1\n        \n        # Fit VO2_fast und tau_fast nach unten\n        current_VO2_fast &lt;- best_VO2_fast\n        current_tau_fast &lt;- best_tau_fast\n        current_VO2_slow &lt;- best_VO2_slow\n        current_tau_slow &lt;- best_tau_slow\n        \n        model &lt;- function(VO2_fast, tau_fast, VO2_slow, tau_slow, t_delay_slow) {\n          VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast)) + \n            VO2_slow * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow, 0)) / tau_slow)) + \n            VO2_Start\n        }\n        \n        current_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n        \n        # Optimiere VO2_fast und tau_fast\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_fast zu reduzieren\n          if (current_VO2_fast &gt; 0.1) {\n            new_VO2_fast &lt;- max(0.1, current_VO2_fast - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(new_VO2_fast, current_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_fast &lt;- new_VO2_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_fast zu reduzieren\n          if (current_tau_fast &gt; 10) {\n            new_tau_fast &lt;- max(10, current_tau_fast - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, new_tau_fast, current_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_fast &lt;- new_tau_fast\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Optimiere VO2_slow und tau_slow\n        # Zuerst nach unten\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu reduzieren\n          if (current_VO2_slow &gt; 0.05) {\n            new_VO2_slow &lt;- max(0.05, current_VO2_slow - 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu reduzieren\n          if (current_tau_slow &gt; 90) {\n            new_tau_slow &lt;- max(90, current_tau_slow - 0.1)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_tau_slow &lt;- new_tau_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          if (!improved) break\n        }\n        \n        # Dann nach oben\n        while (TRUE) {\n          improved &lt;- FALSE\n          \n          # Versuche VO2_slow zu erhöhen\n          if (current_VO2_slow &lt; 1.0) {  # Angenommen, 1.0 ist die obere Grenze für VO2_slow\n            new_VO2_slow &lt;- min(1.0, current_VO2_slow + 0.01)\n            new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, new_VO2_slow, current_tau_slow, t_delay_slow))^2)\n            if (new_rss &lt; current_rss) {\n              current_VO2_slow &lt;- new_VO2_slow\n              current_rss &lt;- new_rss\n              improved &lt;- TRUE\n            }\n          }\n          \n          # Versuche tau_slow zu erhöhen\n          new_tau_slow &lt;- current_tau_slow + 0.1\n          new_rss &lt;- sum((data_subset$VO2_t - model(current_VO2_fast, current_tau_fast, current_VO2_slow, new_tau_slow, t_delay_slow))^2)\n          if (new_rss &lt; current_rss) {\n            current_tau_slow &lt;- new_tau_slow\n            current_rss &lt;- new_rss\n            improved &lt;- TRUE\n          }\n          \n          if (!improved) break\n        }\n        \n        if (current_rss &lt; best_rss) {\n          best_rss &lt;- current_rss\n          best_t_delay_slow &lt;- t_delay_slow\n          best_VO2_fast &lt;- current_VO2_fast\n          best_tau_fast &lt;- current_tau_fast\n          best_VO2_slow &lt;- current_VO2_slow\n          best_tau_slow &lt;- current_tau_slow\n        }\n        \n        incProgress(1 / num_iterations, detail = paste(\"Iteration\", i, \"von\", num_iterations))\n      }\n    })\n    \n    if (!is.null(best_t_delay_slow)) {\n      updateSliderInput(session, \"time_delay_slow\", value = best_t_delay_slow)\n      updateSliderInput(session, \"VO2\", value = best_VO2_fast)\n      updateSliderInput(session, \"tau_fast\", value = best_tau_fast)\n      updateSliderInput(session, \"VO2_slow\", value = best_VO2_slow)\n      updateSliderInput(session, \"tau_slow\", value = best_tau_slow)\n      \n      predicted &lt;- VO2_Start + best_VO2_fast * (1 - exp(-(data_subset$t_s - t_delay) / best_tau_fast)) +\n        best_VO2_slow * (1 - exp(-(pmax(data_subset$t_s - best_t_delay_slow, 0)) / best_tau_slow))\n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, predicted)\n      current_r_squared(r_squared)\n      \n      showNotification(sprintf(\"Schritt 2 erfolgreich. R²: %.3f\", r_squared), type = \"message\")\n    } else {\n      showModal(modalDialog(\n        title = \"Fit fehlgeschlagen\",\n        \"Die Anpassung für die langsame Komponente konnte nicht erfolgreich durchgeführt werden.\",\n        easyClose = TRUE,\n        footer = NULL\n      ))\n    }\n  })\n  \n  observeEvent(input$fit_optimize, {\n    req(current_data())\n    Beispieldaten &lt;- current_data()\n    \n    req(input$time_delay, input$VO2_Start, input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$time_delay_slow)\n    \n    t_delay &lt;- input$time_delay\n    VO2_Start &lt;- input$VO2_Start\n    \n    data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n    \n    # Werte aus Schritt 2\n    VO2_step2 &lt;- input$VO2\n    tau_fast_step2 &lt;- input$tau_fast\n    VO2_slow_step2 &lt;- input$VO2_slow\n    tau_slow_step2 &lt;- input$tau_slow\n    t_delay_slow_step2 &lt;- input$time_delay_slow\n    \n    # Berechne R² für Schritt 2\n    step2_predicted &lt;- VO2_Start + VO2_step2 * (1 - exp(-(data_subset$t_s - t_delay) / tau_fast_step2)) +\n      VO2_slow_step2 * (1 - exp(-(pmax(data_subset$t_s - t_delay_slow_step2, 0)) / tau_slow_step2))\n    step2_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step2_predicted)\n    \n    best_fit &lt;- NULL\n    best_rss &lt;- Inf\n    \n    withProgress(message = 'Optimierung läuft', value = 0, {\n      for (i in 1:1000) {\n        # Randomisierte Startwerte innerhalb der festgelegten Grenzen\n        VO2_start &lt;- runif(1, VO2_step2 * 0.98, VO2_step2 * 1.02)\n        tau_fast_start &lt;- runif(1, max(10, tau_fast_step2 - 3), tau_fast_step2 + 3)\n        VO2_slow_start &lt;- runif(1, VO2_slow_step2 * 0.98, VO2_slow_step2 * 1.02)\n        tau_slow_start &lt;- runif(1, max(90, tau_slow_step2 - 3), tau_slow_step2 + 3)\n        t_delay_slow_start &lt;- runif(1, max(0, t_delay_slow_step2 - 5), t_delay_slow_step2 + 5)\n        \n        start_values &lt;- list(\n          VO2 = VO2_start,\n          tau_fast = tau_fast_start,\n          VO2_slow = VO2_slow_start,\n          tau_slow = tau_slow_start,\n          t_delay_slow = t_delay_slow_start\n        )\n        \n        fit &lt;- try(nlsLM(VO2_t ~ VO2 * (1 - exp(-(t_s - t_delay) / tau_fast)) + \n                           VO2_slow * (1 - exp(-(t_s - t_delay_slow) / tau_slow)) + VO2_Start,\n                         data = data_subset,\n                         start = start_values,\n                         lower = c(VO2 = VO2_step2 * 0.98, \n                                   tau_fast = max(10, tau_fast_step2 - 3), \n                                   VO2_slow = VO2_slow_step2 * 0.98, \n                                   tau_slow = max(90, tau_slow_step2 - 3), \n                                   t_delay_slow = max(0, t_delay_slow_step2 - 5)),\n                         upper = c(VO2 = VO2_step2 * 1.02, \n                                   tau_fast = tau_fast_step2 + 3, \n                                   VO2_slow = VO2_slow_step2 * 1.02, \n                                   tau_slow = tau_slow_step2 + 3, \n                                   t_delay_slow = t_delay_slow_step2 + 5),\n                         control = nls.control(maxiter = 1024)), silent = TRUE)\n        \n        if (!inherits(fit, \"try-error\")) {\n          rss &lt;- sum(residuals(fit)^2)\n          if (rss &lt; best_rss) {\n            best_rss &lt;- rss\n            best_fit &lt;- fit\n          }\n        }\n        \n        incProgress(1/1000, detail = paste(\"Iteration\", i))\n      }\n    })\n    \n    if (!is.null(best_fit)) {\n      params &lt;- as.list(coef(best_fit))\n      step3_predicted &lt;- VO2_Start + params$VO2 * (1 - exp(-(data_subset$t_s - t_delay) / params$tau_fast)) +\n        params$VO2_slow * (1 - exp(-(pmax(data_subset$t_s - params$t_delay_slow, 0)) / params$tau_slow))\n      step3_r_squared &lt;- calculate_r_squared(data_subset$VO2_t, step3_predicted)\n      \n      if (step3_r_squared &gt; step2_r_squared) {\n        updateSliderInput(session, \"VO2\", value = params$VO2)\n        updateSliderInput(session, \"tau_fast\", value = params$tau_fast)\n        updateSliderInput(session, \"VO2_slow\", value = params$VO2_slow)\n        updateSliderInput(session, \"tau_slow\", value = params$tau_slow)\n        updateSliderInput(session, \"time_delay_slow\", value = params$t_delay_slow)\n        \n        current_r_squared(step3_r_squared)\n        showNotification(sprintf(\"Optimierung erfolgreich. Neues R²: %.3f\", step3_r_squared), type = \"message\")\n      } else {\n        current_r_squared(step2_r_squared)\n        showNotification(sprintf(\"Kein besserer Fit gefunden. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n      }\n    } else {\n      current_r_squared(step2_r_squared)\n      showNotification(sprintf(\"Optimierung fehlgeschlagen. Ergebnisse von Schritt 2 beibehalten. R²: %.3f\", step2_r_squared), type = \"warning\")\n    }\n  })\n  \n  output$plot &lt;- renderPlotly({\n    req(input$VO2, input$tau_fast, input$VO2_slow, input$tau_slow, input$VO2_Start, input$time_delay, input$time_delay_slow, input$VO2_Ruhe)\n    \n    VO2 &lt;- input$VO2\n    tau_fast &lt;- input$tau_fast\n    VO2_slow &lt;- input$VO2_slow\n    tau_slow &lt;- input$tau_slow\n    VO2_Start &lt;- input$VO2_Start\n    t_delay &lt;- input$time_delay\n    t_delay_slow &lt;- input$time_delay_slow\n    VO2_Ruhe &lt;- input$VO2_Ruhe\n    \n    model_function &lt;- function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast)) + \n        pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0) + \n        VO2_Start\n    }\n    \n    model_fast &lt;- function(t_s, VO2, tau_fast, t_delay) {\n      VO2 * (1 - exp(-(pmax(t_s - t_delay, 0)) / tau_fast))\n    }\n    \n    model_slow &lt;- function(t_s, VO2_slow, tau_slow, t_delay_slow) {\n      pmax(VO2_slow * (1 - exp(-(pmax(t_s - t_delay_slow, 0)) / tau_slow)), 0)\n    }\n    \n    Beispieldaten &lt;- current_data()\n    \n    max_t &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$t_s, na.rm = TRUE) else 300\n    max_x &lt;- max_t * 1.20\n    t_s &lt;- seq(0, max_x * 1.20, by = 1)\n    \n    model_values &lt;- ifelse(t_s &gt;= t_delay, model_function(t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow), NA)\n    fast_values &lt;- ifelse(t_s &gt;= t_delay, model_fast(t_s, VO2, tau_fast, t_delay), NA)\n    slow_values &lt;- ifelse(t_s &gt;= t_delay_slow, model_slow(t_s, VO2_slow, tau_slow, t_delay_slow), NA)\n    \n    max_y &lt;- if (!is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) max(Beispieldaten$VO2_t, na.rm = TRUE) * 1.05 else max(model_values, na.rm = TRUE) * 1.05\n    \n    eq_text &lt;- sprintf(\"V̇O₂ = %.2f * (1 - e&lt;sup&gt;-(t - %.0f) / %.1f&lt;/sup&gt;) + %.2f * (1 - e&lt;sup&gt;-(t - %.1f) / %.0f&lt;/sup&gt;) + %.2f\",\n                       VO2, t_delay, tau_fast, VO2_slow, t_delay_slow, tau_slow, VO2_Start)\n    t_halb &lt;- tau_fast * log(2)\n    \n    shapes &lt;- list(\n      list(\n        type = \"line\", x0 = t_delay, x1 = t_delay, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      ),\n      list(\n        type = \"line\", x0 = t_delay_slow, x1 = t_delay_slow, y0 = 0, y1 = max_y * 1.2,\n        line = list(color = \"gray\", width = 1, dash = \"dash\")\n      )\n    )\n    \n    p &lt;- plot_ly() %&gt;%\n      add_trace(x = ~t_s, y = ~model_values, type = 'scatter', mode = 'lines',\n                name = 'V̇O2-Modellfunktion', line = list(color = '#EF6F6A')) %&gt;%\n      add_trace(x = ~t_s, y = ~fast_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;fast&lt;/sub&gt;', line = list(color = '#42BA97')) %&gt;%\n      add_trace(x = ~t_s, y = ~slow_values, type = 'scatter', mode = 'lines', \n                name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;&lt;sub&gt;slow&lt;/sub&gt;', line = list(color = '#BB7693')) %&gt;%\n      layout(title = \"Bi-exponentielle V̇O&lt;sub&gt;2&lt;/sub&gt;-Modellfunktion\",\n             margin = list(t = 40),\n             xaxis = list(title = \"t [s]\", range = c(0, max_x)),\n             yaxis = list(title = \"V̇O&lt;sub&gt;2&lt;/sub&gt; [l·min&lt;sup&gt;-1&lt;/sup&gt;]\", tickformat = \".1f\"),\n             shapes = shapes,\n             annotations = list(\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.3,\n                 text = eq_text,\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = max_x * 0.35,\n                 y = max_y * 0.2,\n                 text = paste(\"T&lt;sub&gt;1/2&lt;/sub&gt;:\", round(t_halb, 1)),\n                 showarrow = FALSE,\n                 xanchor = 'left',\n                 yanchor = 'bottom',\n                 font = list(\n                   family = \"Arial, sans-serif\",\n                   size = 10,\n                   color = \"black\"\n                 )\n               ),\n               list(\n                 x = t_delay, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay&lt;/sub&gt;: %.1f\", t_delay), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               ),\n               list(\n                 x = t_delay_slow, y = max_y * 0.9, text = sprintf(\"t&lt;sub&gt;delay_slow&lt;/sub&gt;: %.1f\", t_delay_slow), showarrow = FALSE, xanchor = \"left\", yanchor = \"bottom\",\n                 textangle = -90, font = list(size = 11)\n               )\n             )) %&gt;%\n      add_trace(x = ~t_s, y = ~rep(VO2_Ruhe, length(t_s)), type = 'scatter', mode = 'lines',\n                name = 'V̇O&lt;sub&gt;2, Ruhe&lt;/sub&gt;', line = list(color = '#1CADE4'))\n    \n    if (show_data() && !is.null(Beispieldaten) && nrow(Beispieldaten) &gt; 0) {\n      data_subset &lt;- Beispieldaten[Beispieldaten$t_s &gt;= t_delay, ]\n      \n      model_values_at_data &lt;- model_function(data_subset$t_s, VO2, tau_fast, VO2_slow, tau_slow, VO2_Start, t_delay, t_delay_slow)\n      \n      r_squared &lt;- calculate_r_squared(data_subset$VO2_t, model_values_at_data)\n      current_r_squared(r_squared)\n      \n      current_r_squared(r_squared)  # Aktualisieren Sie die reaktive Variable\n      \n      p &lt;- p %&gt;%\n        add_trace(data = Beispieldaten, x = ~t_s, y = ~VO2_t, type = 'scatter', mode = 'markers+lines',\n                  name = 'V̇O&lt;sub&gt;2&lt;/sub&gt;', \n                  marker = list(color = 'rgba(38, 131, 198, 0.9)', size = 5.0),\n                  line = list(color = 'rgba(38, 131, 198, 1.0)', width = 0.65, dash = '4 4'))\n      \n      p$x$layout$annotations &lt;- c(p$x$layout$annotations,\n                                  list(\n                                    list(\n                                      x = max_x * 0.35,\n                                      y = max_y * 0.10,\n                                      text = sprintf(\"R²: %.3f\", current_r_squared()),\n                                      showarrow = FALSE,\n                                      xanchor = 'left',\n                                      yanchor = 'bottom',\n                                      font = list(\n                                        family = \"Arial, sans-serif\",\n                                        size = 10,\n                                        color = \"black\"\n                                      )\n                                    )\n                                  ))\n    }\n    \n    p\n  })\n  output$instructions &lt;- renderUI({\n    HTML(\n      \"&lt;div style='margin-top: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\n      &lt;h4 style='color: #333;'&gt;&lt;strong&gt;Anleitung - Modellanpassung:&lt;/strong&gt;&lt;/h4&gt;\n      &lt;ol style='color: #555; list-style-position: outside; padding-left: 20px;'&gt;\n        &lt;li&gt;Beispiel-VO2-Daten einfügen oder eigene VO2-Daten als CSV-Datei hochladen.&lt;/li&gt;\n        &lt;li&gt;Zeitverzögerung_fast festlegen, um den Startpunkt der Modellanpassung zu bestimmen.&lt;/li&gt;\n        &lt;li&gt;Schrittweise die Modellanpassung durchführen:\n          &lt;ol&gt;\n            &lt;li&gt;Fit: Schnelle Komponente&lt;/li&gt;\n            &lt;li&gt;Fit: Langsame Komponente Verfeinerung&lt;/li&gt;\n            &lt;li&gt;Fit: Optimierung&lt;/li&gt;\n          &lt;/ol&gt;\n        &lt;/li&gt;\n        &lt;li&gt;Alternative: Manuelle Anpassung der Modellparameter über die Schieberegler.&lt;/li&gt;\n      &lt;/ol&gt;\n      &lt;div style='margin-top: 20px;'&gt;&lt;/div&gt;\n      &lt;pre style='background-color: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 5px; width: fit-content;'&gt;\nVO2-Daten können als CSV-Datei im folgenden Format hochgeladen werden:\nt_s,VO2_t\n0.0,0.479\n1.0,0.459\n2.3,0.488\n…\n      &lt;/pre&gt;\n    &lt;/div&gt;\"\n    )\n  })\n}\n\n# App ausführen\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nModellanpassung - Details:\n\n\n\n\n\n1. Schnelle Komponente (1. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast\nGrenzen:\n\nV̇O2_fast: 0.5 bis 7.0 l/min\ntau_fast: 10 bis 120 s\n\nProzess: 100 Iterationen mit zufälligen Startwerten\nOptimierung: Minimierung der Residuenquadratsumme (RSS)\n\n2. Langsame Komponente & Verfeinerung (2. Fit):\n\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nInitiale Werte (basierend auf Ozyener et al., 2001):\n\nV̇O2_slow: 0.4 l/min\ntau_slow: 160 s\n\nGrenzen:\n\nV̇O2_slow: 0.05 bis 1.0 l/min\ntau_slow: 90 bis Unendlich s\nt_delay_slow: tau_fast + t_delay bis max(t_s)\n\nProzess für t_delay_slow:\n\nBerechnung des Suchbereichs: von (tau_fast + t_delay) bis zum maximalen Zeitpunkt der Daten\nIteration durch jeden möglichen Wert in diesem Bereich (1-Sekunden-Schritte)\nFür jeden t_delay_slow-Wert:\n\nBerechnung der RSS mit festen Werten für V̇O2_slow (0.4 l/min) und tau_slow (160 s)\n\nAuswahl des t_delay_slow-Wertes mit der niedrigsten RSS\n\nOptimierung von V̇O2_fast und tau_fast:\n\nSchrittweise Reduzierung von V̇O2_fast (0.01 l/min) und tau_fast (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung bis keine Verbesserung mehr möglich\n\nOptimierung von V̇O2_slow und tau_slow:\n\nZunächst Reduzierung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nDann Erhöhung: V̇O2_slow (0.01 l/min) und tau_slow (0.1 s)\nBei jeder Änderung: Berechnung der neuen RSS\nAkzeptanz der Änderung nur bei Verbesserung der RSS\nWiederholung jeder Richtung bis keine Verbesserung mehr möglich\n\n\n3. Optimierung (3. Fit):\n\nVerwendete Funktion: nlsLM\nParameter: V̇O2_fast, tau_fast, V̇O2_slow, tau_slow, t_delay_slow\nGrenzen: Basierend auf den Ergebnissen von Schritt 2\n\nV̇O2_fast: ±2% des Wertes aus Schritt 2\ntau_fast: ±3 s des Wertes aus Schritt 2 (Minimum 10 s)\nV̇O2_slow: ±2% des Wertes aus Schritt 2\ntau_slow: ±3 s des Wertes aus Schritt 2 (Minimum 90 s)\nt_delay_slow: ±5 s des Wertes aus Schritt 2 (Minimum 0 s)\n\nProzess: 1000 Iterationen mit zufälligen Startwerten innerhalb der Grenzen\nOptimierung: Minimierung der RSS",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "VO2.html#methodenteil-umgang-mit-daten-in-dieser-arbeit",
    "href": "VO2.html#methodenteil-umgang-mit-daten-in-dieser-arbeit",
    "title": "VO2-Modellfunktion während der Belastung",
    "section": "",
    "text": "In dieser Arbeit wurde der Anstieg des \\(\\dot{V}O_{2}\\) nach Belastungsbeginn für jede Belastungsstufe wie folgt analysiert: Zunächst wurden aus den Atemzug-für-Atemzug \\(\\dot{V}O_{2}\\)-Daten die Ausreißer entfernt. Danach erfolgte eine Glättung der Daten mittels eines gleitenden 3-Atemzug-Durchschnitts, gefolgt von der Kurvenanpassung.\nVor der Kurvenanpassung wurde die Zeitverzögerung der Hauptkomponente des \\(\\dot{V}O_{2}\\) grafisch so bestimmt, dass die Phase-I-Daten der kardiorespiratorischen Antwort nicht einbezogen wurden. Dies entsprach in der Regel dem von [@Bearden2000; @Stirling2005] beschriebenen Zeitraum von 10-25 Sekunden für Phase 1. Die Kurvenanpassung wurde anschließend mit Gleichung 3 an die jeweiligen Daten durchgeführt. Die Modellparameter der Kurvenanpassung wurden wie folgt gewählt: ::: {.callout-note icon=false collapse=true appearance=“simple”} ### Parameter - Kurvenanpassung: - Verwendete Funktion: nlsLM * Maximale Iterationen: 1024 * Verwendung des Levenberg-Marquardt-Algorithmus - Parameter: V̇O2 (Amplitude), Tau - Modell: V̇O2_t ~ V̇O2 · (1 - exp(-(t_s - t_delay) / Tau)) + V̇O2_Start - Grenzen: * V̇O2: 0.5 bis 7.0 l/min * Tau: 5 bis 360 s - Optimierung: Minimierung der Residuenquadratsumme (RSS) :::\n\n\nCode\n### Dauer der Zeitkonstante bei verschiedenen Intensitäten unterschiedlich\n# @Oezyner2001 fanden, dass der Wert von τ~Start~ für die Sauerstoffaufnahme im Durchschnitt bei 33 ± 16 s liegt, unabhängig von der Belastungshöhe. \n# -Im Gegensatz dazu berichten andere Studien von einem Anstieg von τ~Start~ mit zunehmender Belastung (Linnarsson 1974).\n# Wasserman et al. [@Wasserman1967] prognostizierten und fanden experimentell heraus, dass der Sauerstoffverbrauch bei schweren Arbeitsbelastungen länger ansteigt als bei moderaten Intensitäten. Henry und DeMoor [@Henry1956] stellten ebenfalls fest, dass die Zeit bis zum Erreichen eines stabilen Zustands der Sauerstoffaufnahme (VO2) mit steigender Arbeitslast zunimmt. Im Gegensatz dazu berichten Di Prampero et al. [@DiPrampero1970] und Margaria et al. [@Margaria1965], dass das Muster des VO2-Anstiegs zum stabilen Zustand unabhängig von der Arbeitsintensität gleich ist und dieser Anstieg durch einen einzigen exponentiellen Prozess beschrieben wird, wobei die Reaktionskonstante für alle Arbeitslasten gleich ist.\n# \n# **Moderate Intensität:**\n# Die pulmonale V̇O~2~steigt monoexponentiell und erreicht innerhalb von etwa 3 Minuten einen Steady State [@Whipp1982; @Hughson1988; @Whipp1994]. Die V̇O~2~ erhöht sich linear zur Arbeitsrate um etwa 10 ml·min^-1·W^-1. Sobald der Steady State erreicht ist, sind ATP-Resynthese und oxidative Phosphorylierung im Gleichgewicht [@Kindermann1979; @Faude2009].\n# \n# **Schwere Intensität:**\n# Die schwere Intensität liegt zwischen der maximalen Leistungsfähigkeit (GXT) und der kritischen Leistung (CP) [@Hill1993]. Bei schwerer Belastung ist der oxidative Bedarf höher, und der Steady State verzögert sich durch die V̇O~2~ Slow Component. Die O~2~-Kosten steigen auf etwa 13 ml·min^-1·W^-1 [@WhippWasserman1972; @PearceMilhorn1977; @WhippMahler1980; @BarstowMole1991]. Die arterielle Laktatkonzentration steigt über die Ausgangswerte, erreicht aber ein erhöhtes Gleichgewicht [@Billat2003].\n# \n# **Schwere Intensität:**\n# In der Forschung ist umstritten, ob die primäre V̇O~2~-Kinetik bei schwerer Belastung langsamer ist als bei moderater. Dies könnte auf eine größere Zeitkonstante oder eine zusätzliche Slow Component in V̇O~2~ hindeuten, die einen verzögerten Steady State über dem vorhergesagten Niveau erreicht [@PatersonWhipp1991; @BarstowMole1991].\n# \n# **Sehr schwere Intensität:**\n# Bei sehr schwerer Intensität, oberhalb des maximalen Laktat-Steady-State oder der kritischen Leistung, erreichen weder V̇O~2~ noch arterielle Laktatkonzentration einen Steady State [@GaesserPoole1996]. Beide steigen unaufhaltsam, bis Ermüdung eintritt und maximale V̇O~2~-Werte erreicht werden [@WassermanWhipp1975; @GaesserPoole1996].",
    "crumbs": [
      "VO2-Modellfunktion"
    ]
  },
  {
    "objectID": "Ergebnisse.html",
    "href": "Ergebnisse.html",
    "title": "EPOC-Modellfunktion",
    "section": "",
    "text": "1 Darstellung und Auswertung des Energieumsatzes und Wirkungsgrads unter verschiedenen Bedingungen und Intensitäten\n#| standalone: true\n#| viewerHeight: 1200\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(plotly)\nlibrary(htmltools)\nlibrary(DT) \nlibrary(shiny)\nlibrary(ggstatsplot)\n\nBedingungen_data &lt;- data.frame(\n  Proband = factor(rep(c(1, 6, 10, 13, 14, 15, 17, 18, 19), each = 6)),\n  Bedingung = rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9),\n  Intensität = rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9),\n  WirkPhysio = c(0.236, 0.246, 0.242, 0.229, 0.232, 0.239, 0.235, 0.241, 0.248, 0.239, 0.240, 0.243, 0.253, 0.268, 0.246, 0.243, 0.237, 0.239, 0.246, 0.260, 0.237, 0.256, 0.245, 0.236, 0.256, 0.230, 0.251, 0.238, 0.236, 0.257, 0.229, 0.250, 0.239, 0.226, 0.230, 0.224, 0.267, 0.254, 0.247, 0.250, 0.239, 0.241, 0.253, 0.256, 0.262, 0.257, 0.240, 0.255, 0.236, 0.269, 0.260, 0.237, 0.243, 0.259),\n  WAerob_kJ = c(364.789, 341.630, 380.176, 397.986, 434.292, 433.605, 324.974, 328.244, 338.783, 345.676, 364.681, 257.548, 373.643, 359.054, 449.591, 437.034, 472.355, 502.399, 358.838, 352.868, 394.753, 386.920, 414.584, 422.975, 336.737, 327.041, 374.941, 376.055, 407.569, 413.170, 301.002, 268.617, 293.783, 323.273, 338.096, 356.148, 301.109, 280.951, 322.983, 336.779, 374.988, 386.658, 266.533, 251.790, 278.169, 296.280, 322.403, 294.594, 228.956, 211.733, 242.183, 251.874, 269.031, 263.981),\n  WPCR_kJ = c(24.990, 32.078, 29.980, 41.372, 32.638, 31.531, 36.043, 30.172, 32.921, 37.818, 39.501, 28.280, 26.361, 43.004, 44.844, 47.735, 57.011, 41.969, 33.885, 39.927, 47.648, 43.936, 53.680, 50.565, 29.216, 27.530, 35.164, 28.986, 47.232, 36.751, 26.606, 20.363, 30.392, 26.097, 32.816, 35.505, 26.571, 18.819, 26.123, 31.549, 24.554, 32.396, 18.144, 19.103, 15.287, 14.856, 29.950, 33.898, 19.655, 11.905, 16.782, 20.699, 25.292, 21.067),\n  WBLC_kJ = c(10.331, 11.611, 15.658, 12.815, 20.331, 7.660, 10.576, 10.736, 15.179, 19.020, 24.804, 17.400, 6.874, 5.614, 18.402, 10.604, 15.802, 23.444, 7.487, 10.041, 9.859, 9.539, 15.336, 13.647, 6.432, 8.576, 8.576, 11.804, 7.468, 17.874, 6.891, 7.499, 11.084, 12.980, 17.018, 18.007, 6.655, 10.143, 11.106, 8.317, 17.902, 13.236, 6.610, 6.086, 10.863, 13.388, 20.296, 15.275, 4.766, 4.184, 7.303, 10.460, 13.388, 11.525),\n  WTOT_kJ = c(400.111, 385.318, 425.813, 452.173, 487.261, 472.796, 371.593, 369.153, 386.883, 402.514, 428.986, 303.228, 406.879, 407.672, 512.836, 495.373, 545.169, 567.812, 400.210, 402.837, 452.260, 440.395, 483.600, 487.187, 372.385, 363.147, 418.681, 416.845, 462.268, 467.795, 334.499, 296.479, 335.259, 362.350, 387.929, 409.659, 334.335, 309.913, 360.213, 376.645, 417.444, 432.290, 291.287, 276.979, 304.319, 324.524, 372.649, 343.767, 253.376, 227.822, 266.267, 283.032, 307.712, 296.572),\n  P_Tot = c(315.088, 315.356, 343.250, 345.622, 376.014, 377.269, 291.341, 296.009, 319.564, 320.346, 342.797, 334.697, 342.780, 364.604, 419.800, 400.468, 431.054, 452.464, 328.689, 348.476, 357.036, 375.551, 395.659, 383.032, 317.382, 278.361, 350.890, 330.104, 363.619, 400.224, 255.678, 247.500, 267.481, 272.461, 297.603, 306.493, 297.678, 262.465, 297.034, 313.722, 332.282, 347.560, 245.195, 236.218, 265.627, 278.280, 297.955, 291.810, 199.167, 204.304, 230.540, 223.281, 248.864, 255.967),\n  P_mean = structure(c(286.197, 279.856, 308.058, 316.423, 340.826, 347.288, 277.240, 271.455, 304.467, 298.231, 325.413, 309.695, 323.151, 316.844, 371.964, 380.656, 411.775, 405.479, 300.612, 294.276, 330.975, 323.263, 347.878, 356.524, 264.043, 264.046, 296.596, 312.821, 338.375, 340.656, 222.299, 217.725, 237.150, 238.511, 268.300, 270.268, 259.610, 246.985, 281.341, 276.153, 316.925, 309.070, 220.908, 221.312, 250.936, 254.072, 274.367, 276.738, 175.467, 173.182, 199.048, 199.115, 224.703, 224.227),\n                     names = paste0(rep(c(\"01\", \"06\", \"10\", \"13\", \"14\", \"15\", \"17\", \"18\", \"19\"), each = 6), \"_\", rep(1:6, 9), \"_\", rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9), \"_\", rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9), \"_final.xlsm\")),\n  P_Int = c(28.891, 35.500, 35.191, 29.199, 35.188, 29.981, 14.101, 24.553, 15.096, 22.115, 17.384, 25.002, 19.629, 47.760, 47.836, 19.812, 19.280, 46.985, 28.078, 54.200, 26.061, 52.288, 47.782, 26.508, 53.339, 14.315, 54.294, 17.283, 25.244, 59.568, 33.379, 29.774, 30.332, 33.951, 29.303, 36.225, 38.068, 15.480, 15.693, 37.570, 15.358, 38.490, 24.288, 14.906, 14.691, 24.208, 23.588, 15.072, 23.700, 31.122, 31.492, 24.167, 24.161, 31.740),\n  nD = c(76.656, 86.401, 86.152, 76.970, 86.149, 77.755, 59.670, 79.341, 59.012, 78.632, 58.578, 74.838, 64.403, 93.431, 93.480, 64.651, 63.923, 92.926, 76.179, 100.726, 76.497, 100.707, 101.494, 76.290, 94.922, 67.303, 95.691, 67.756, 68.909, 97.233, 82.316, 85.115, 84.987, 82.412, 85.664, 82.543, 88.353, 59.284, 59.646, 87.968, 59.075, 88.675, 86.174, 65.943, 65.511, 86.081, 85.349, 66.273, 75.210, 87.711, 88.053, 75.796, 75.789, 88.282),\n  Efficiency = structure(c(66.420, 80.670, 85.600, 72.950, 87.650, 78.670, 80.040, 86.410, 86.780, 88.630, 88.240, 92.410, 73.990, 73.770, 81.110, 85.390, 91.790, 84.470, 72.050, 72.340, 79.170, 76.950, 79.780, 85.170, 66.520, 69.930, 72.410, 82.580, 87.010, 79.530, 65.430, 72.540, 77.020, 70.470, 80.770, 78.760, 64.470, 62.050, 68.400, 71.350, 77.440, 75.100, 81.990, 82.220, 91.470, 89.760, 92.560, 97.110, 50.580, 59.590, 65.120, 56.310, 63.190, 72.060),\n                         names = paste0(rep(c(\"01\", \"06\", \"10\", \"13\", \"14\", \"15\", \"17\", \"18\", \"19\"), each = 6), \"_\", rep(1:6, 9), \"_\", rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9), \"_\", rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9), \"_final.xlsm\")),\n  Pedal_Smoothness = structure(c(39.710, 50.818, 52.443, 40.206, 53.679, 41.045, 47.915, 51.534, 49.217, 51.139, 48.034, 52.822, 47.930, 51.948, 54.061, 50.656, 52.634, 54.273, 43.084, 49.064, 44.663, 50.294, 51.290, 46.464, 48.329, 44.259, 52.672, 47.444, 48.247, 57.974, 42.430, 50.291, 52.357, 42.713, 52.269, 44.794, 46.357, 38.358, 39.662, 49.311, 42.188, 51.480, 54.435, 49.538, 51.844, 57.505, 57.678, 52.618, 32.376, 42.067, 44.898, 34.164, 36.544, 47.313),\n                               names = paste0(rep(c(\"01\", \"06\", \"10\", \"13\", \"14\", \"15\", \"17\", \"18\", \"19\"), each = 6), \"_\", rep(1:6, 9), \"_\", rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9), \"_\", rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9), \"_final.xlsm\")),\n  P_max = structure(c(720.714, 550.698, 587.417, 787.012, 634.932, 846.119, 578.610, 526.754, 618.616, 583.178, 677.468, 586.295, 674.211, 609.931, 688.050, 751.453, 782.343, 747.115, 697.739, 599.784, 741.044, 642.751, 678.261, 767.314, 546.343, 596.592, 563.099, 659.349, 701.336, 587.603, 523.918, 432.933, 452.948, 558.406, 513.310, 603.362, 560.027, 643.901, 709.354, 560.028, 751.219, 600.372, 405.819, 446.750, 484.018, 441.824, 475.692, 525.937, 541.967, 411.679, 443.334, 582.826, 614.878, 473.924),\n                    names = paste0(rep(c(\"01\", \"06\", \"10\", \"13\", \"14\", \"15\", \"17\", \"18\", \"19\"), each = 6), \"_\", rep(1:6, 9), \"_\", rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9), \"_\", rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9), \"_final.xlsm\")),\n  HR_percent = c(87.370, 85.070, 88.400, 90.930, 93.120, 93.780, 88.050, 88.160, 92.210, 91.970, 95.390, 93.580, 84.410, 84.650, 88.640, 89.980, 91.120, 94.040, 89.190, 89.260, 92.250, 92.320, 93.980, 94.900, 86.650, 87.880, 89.950, 91.140, 93.960, 94.270, 90.900, 86.550, 87.590, 91.620, 91.130, 95.120, 86.770, 87.490, 90.800, 89.740, 93.350, 94.180, 80.640, 81.030, 84.870, 88.210, 91.540, 92.470, 91.920, 88.360, 90.080, 92.490, 93.580, 93.310),\n  VO2_percent = c(71.270, 66.600, 72.840, 76.050, 83.970, 83.100, 73.170, 73.360, 75.130, 76.760, 82.170, 80.020, 65.960, 64.110, 76.980, 75.530, 81.190, 87.700, 77.060, 75.210, 82.910, 81.140, 86.200, 88.050, 69.580, 67.180, 76.090, 77.010, 83.240, 82.990, 68.970, 61.940, 67.210, 72.610, 75.890, 79.960, 59.980, 55.950, 63.850, 65.630, 72.700, 75.690, 74.640, 71.070, 77.240, 82.440, 89.640, 82.880, 64.160, 59.830, 66.380, 68.750, 72.980, 72.620),\n  ΔBLC = c(2.144, 2.410, 3.250, 2.660, 4.220, 1.590, 2.285, 2.320, 3.280, 4.110, 5.360, 3.760, 1.322, 1.080, 3.540, 2.040, 3.040, 4.510, 1.640, 2.200, 2.160, 2.090, 3.360, 2.990, 1.335, 1.780, 1.780, 2.450, 1.550, 3.710, 1.672, 1.820, 2.690, 3.150, 4.130, 4.370, 1.312, 2.000, 2.190, 1.640, 3.530, 2.610, 2.172, 2.000, 3.570, 4.400, 6.670, 5.020, 1.253, 1.100, 1.920, 2.750, 3.520, 3.030)\n)\n\n# UI (User Interface) Definition:\nui &lt;- fluidPage(\n  titlePanel(\"Gestapeltes Balkendiagramm für Energieumsatz\"),\n  sidebarLayout(\n    sidebarPanel(\n      width = 2,  # Etwas breitere Sidebar\n      checkboxGroupInput(\"selectedBedingung\", \"Bedingungen:\",\n                         unique(Bedingungen_data$Bedingung),\n                         selected = c(\"sitzen\", \"stehen\")),\n      checkboxGroupInput(\"selectedIntensität\", \"Intensitäten:\",\n                         unique(Bedingungen_data$Intensität),\n                         selected = NULL),\n      checkboxGroupInput(\"selectedProband\", \"Probanden:\",\n                         unique(Bedingungen_data$Proband),\n                         selected = unique(Bedingungen_data$Proband))\n    ),\n    mainPanel(\n      width = 10,  # Entsprechend angepasster Hauptbereich\n      plotlyOutput(\"barplot\", height = \"calc(65vh - 150px)\"),  # Etwa 75% der vorherigen Höhe\n      DTOutput(\"summaryTable\"),\n      br(), br(),  # Fügt zwei Zeilenumbrüche für mehr Abstand hinzu\n      plotOutput(\"ggbetweenstatsPlot\", height = \"800px\"),  # Erhöht die Höhe der ANOVA-Abbildung\n      br(), br(),  # Fügt zwei Zeilenumbrüche für mehr Abstand hinzu\n      h4(\"ANOVA-Ergebnisse für WirkPhysio\"),\n      verbatimTextOutput(\"anovaResults\"),\n      br(), br()  # Fügt zwei Zeilenumbrüche am Ende für mehr Abstand hinzu\n    )\n  )\n)\n\nsort_with_leicht_sitzen_first &lt;- function(x) {\n  leicht_sitzen &lt;- \"leicht_sitzen\"\n  if (leicht_sitzen %in% x) {\n    return(c(leicht_sitzen, setdiff(x, leicht_sitzen)))\n  }\n  return(x)\n}\n\nserver &lt;- function(input, output) {\n  print(head(Bedingungen_data))\n  \n  generatePlot &lt;- reactive({\n    # Datenfilterung je nach Auswahl\n    filtered_data &lt;- filter(Bedingungen_data, \n                            Proband %in% input$selectedProband,\n                            Bedingung %in% input$selectedBedingung,\n                            Intensität %in% input$selectedIntensität)\n    print(nrow(filtered_data))\n    \n    # Prüfen, ob Bedingungen oder Intensitäten ausgewählt wurden\n    bedingungen_ausgewaehlt &lt;- length(input$selectedBedingung) &gt; 0\n    intensitaeten_ausgewaehlt &lt;- length(input$selectedIntensität) &gt; 0\n    \n    if (bedingungen_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Bedingung %in% input$selectedBedingung)\n    }\n    \n    if (intensitaeten_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Intensität %in% input$selectedIntensität)\n    }\n    \n    # Gruppierung und Berechnung basierend auf der Auswahl\n    if (bedingungen_ausgewaehlt && intensitaeten_ausgewaehlt) {\n      group_vars &lt;- c(\"Bedingung\", \"Intensität\")\n    } else if (bedingungen_ausgewaehlt) {\n      group_vars &lt;- \"Bedingung\"\n    } else if (intensitaeten_ausgewaehlt) {\n      group_vars &lt;- \"Intensität\"\n    } else {\n      # Wenn weder Bedingungen noch Intensitäten ausgewählt sind\n      return(NULL)\n    }\n    \n    # Berechnen des durchschnittlichen Wirkungsgrads\n    avg_efficiency_data &lt;- filtered_data %&gt;%\n      group_by(across(all_of(group_vars))) %&gt;%\n      summarize(AvgWirkungsgrad = mean(WirkPhysio, na.rm = TRUE))\n    \n    # Berechnen der durchschnittlichen Leistung\n    avg_power_data &lt;- filtered_data %&gt;%\n      group_by(across(all_of(group_vars))) %&gt;%\n      summarize(AvgPTOT = mean(`P_Tot`, na.rm = TRUE)) \n    \n    # Daten umwandeln und Durchschnittswerte berechnen\n    avg_energy_data &lt;- filtered_data %&gt;%\n      gather(Energiequelle, Wert, WAerob_kJ, WPCR_kJ, WBLC_kJ) %&gt;%\n      group_by(across(all_of(c(group_vars, \"Energiequelle\")))) %&gt;%\n      summarize(AvgWert = mean(Wert, na.rm = TRUE),\n                AvgWTOT = mean(WTOT_kJ, na.rm = TRUE),\n                Prozentsatz = (AvgWert / AvgWTOT) * 100)\n    \n    # X-Achsen-Variable festlegen\n    if (length(group_vars) &gt; 1) {\n      x_var &lt;- ~interaction(Intensität, Bedingung, sep = \"_\")\n      x_title &lt;- \"Intensität_Bedingung\"\n    } else {\n      x_var &lt;- as.formula(paste0(\"~\", group_vars))\n      x_title &lt;- group_vars\n    }\n    \n    p &lt;- plot_ly(data = avg_energy_data, \n                 x = x_var, \n                 y = ~AvgWert, \n                 color = ~Energiequelle, \n                 type = 'bar',\n                 marker = list(line = list(color = 'black', width = 0.75)),\n                 colors = c(\"#42BA97\",\"#F4737A\", \"#1CADE4\"),\n                 text = ~sprintf(\"%.1f%%\", Prozentsatz),\n                 textposition = \"auto\",\n                 textfont = list(color = \"black\")\n    ) %&gt;%\n      layout(\n        title = 'Durchschnittlicher Energieverbrauch der ausgewählten Probanden',\n        xaxis = list(title = htmltools::HTML(paste0('&lt;b&gt;', x_title, '&lt;/b&gt;')),\n                     showgrid = TRUE,\n                     gridcolor = \"lightgray\",\n                     gridwidth = 0.05),\n        yaxis = list(title = htmltools::HTML('&lt;b&gt;Durchschnittliche Energie [kJ]&lt;/b&gt;'), tickformat = \",.0f\",\n                     showgrid = TRUE,\n                     gridcolor = \"lightgray\",\n                     gridwidth = 0.05),\n        barmode = 'stack',\n        bargap = 0.4\n      )\n    \n    # Wirkungsgradbeschriftung \n    for(i in 1:nrow(avg_efficiency_data)) {\n      x_val &lt;- if (length(group_vars) &gt; 1) {\n        interaction(avg_efficiency_data$Intensität[i], avg_efficiency_data$Bedingung[i], sep = \"_\")\n      } else {\n        avg_efficiency_data[[group_vars]][i]\n      }\n      \n      y_val &lt;- sum(avg_energy_data$AvgWert[\n        if (length(group_vars) &gt; 1) {\n          avg_energy_data$Intensität == avg_efficiency_data$Intensität[i] & \n            avg_energy_data$Bedingung == avg_efficiency_data$Bedingung[i]\n        } else {\n          avg_energy_data[[group_vars]] == avg_efficiency_data[[group_vars]][i]\n        }\n      ]) + 15\n      \n      p &lt;- add_annotations(p,\n                           x = x_val,\n                           y = y_val,\n                           text = sprintf(\"η = %.3f\", avg_efficiency_data$AvgWirkungsgrad[i]),\n                           showarrow = FALSE,\n                           yshift = 25,\n                           bgcolor = \"white\",\n                           bordercolor = \"black\",\n                           borderpad = 4\n      )\n    }\n    \n    # Durchschnittliche Leistung beschriften\n    for(i in 1:nrow(avg_power_data)) {\n      x_val &lt;- if (length(group_vars) &gt; 1) {\n        interaction(avg_power_data$Intensität[i], avg_power_data$Bedingung[i], sep = \"_\")\n      } else {\n        avg_power_data[[group_vars]][i]\n      }\n      \n      p &lt;- add_annotations(p,\n                           x = x_val,\n                           y = 0,\n                           text = sprintf(\"P&lt;sub&gt;TOT&lt;/sub&gt; = %.1fW\", avg_power_data$AvgPTOT[i]),\n                           showarrow = FALSE,\n                           yshift = 12,\n                           xanchor = \"center\",\n                           font = list(color = \"black\", size = 10)\n      )\n    }\n    \n    return(p)\n  })\n  \n output$barplot &lt;- renderPlotly({\n  print(\"Debugging barplot\")\n  \n  # Datenfilterung je nach Auswahl\n  filtered_data &lt;- Bedingungen_data %&gt;%\n    filter(Proband %in% input$selectedProband)\n  \n  # Prüfen, ob Bedingungen oder Intensitäten ausgewählt wurden\n  bedingungen_ausgewaehlt &lt;- length(input$selectedBedingung) &gt; 0\n  intensitaeten_ausgewaehlt &lt;- length(input$selectedIntensität) &gt; 0\n  \n  if (bedingungen_ausgewaehlt) {\n    filtered_data &lt;- filtered_data %&gt;% \n      filter(Bedingung %in% input$selectedBedingung)\n  }\n  \n  if (intensitaeten_ausgewaehlt) {\n    filtered_data &lt;- filtered_data %&gt;% \n      filter(Intensität %in% input$selectedIntensität)\n  }\n  \n  print(\"Filtered data:\")\n  print(head(filtered_data))\n  \n  # Gruppierung und Berechnung basierend auf der Auswahl\n  if (bedingungen_ausgewaehlt && intensitaeten_ausgewaehlt) {\n    group_vars &lt;- c(\"Bedingung\", \"Intensität\")\n  } else if (bedingungen_ausgewaehlt) {\n    group_vars &lt;- \"Bedingung\"\n  } else if (intensitaeten_ausgewaehlt) {\n    group_vars &lt;- \"Intensität\"\n  } else {\n    # Wenn weder Bedingungen noch Intensitäten ausgewählt sind\n    print(\"Keine Bedingungen oder Intensitäten ausgewählt\")\n    return(NULL)\n  }\n  \n  print(\"Group variables:\")\n  print(group_vars)\n  \n  # Berechnen des durchschnittlichen Wirkungsgrads\n  avg_efficiency_data &lt;- filtered_data %&gt;%\n    group_by(across(all_of(group_vars))) %&gt;%\n    summarize(AvgWirkungsgrad = mean(WirkPhysio, na.rm = TRUE))\n  \n  print(\"Average efficiency data:\")\n  print(head(avg_efficiency_data))\n  \n  # Berechnen der durchschnittlichen Leistung\n  avg_power_data &lt;- filtered_data %&gt;%\n    group_by(across(all_of(group_vars))) %&gt;%\n    summarize(AvgPTOT = mean(`P_Tot`, na.rm = TRUE)) \n  \n  print(\"Average power data:\")\n  print(head(avg_power_data))\n  \n  # Daten umwandeln und Durchschnittswerte berechnen\n  avg_energy_data &lt;- filtered_data %&gt;%\n    gather(Energiequelle, Wert, WAerob_kJ, WPCR_kJ, WBLC_kJ) %&gt;%\n    group_by(across(all_of(c(group_vars, \"Energiequelle\")))) %&gt;%\n    summarize(AvgWert = mean(Wert, na.rm = TRUE),\n              AvgWTOT = mean(WTOT_kJ, na.rm = TRUE),\n              Prozentsatz = (AvgWert / AvgWTOT) * 100)\n  \n  print(\"Average energy data:\")\n  print(head(avg_energy_data))\n  \n  # X-Achsen-Variable festlegen\n  if (length(group_vars) &gt; 1) {\n    x_var &lt;- ~interaction(Intensität, Bedingung, sep = \"_\")\n    x_title &lt;- \"Intensität_Bedingung\"\n  } else {\n    x_var &lt;- as.formula(paste0(\"~\", group_vars))\n    x_title &lt;- group_vars\n  }\n  \n  print(\"X variable:\")\n  print(x_var)\n  print(\"X title:\")\n  print(x_title)\n  \n  p &lt;- plot_ly(data = avg_energy_data, \n               x = x_var, \n               y = ~AvgWert, \n               color = ~Energiequelle, \n               type = 'bar',\n               marker = list(line = list(color = 'black', width = 0.75)),\n               colors = c(\"#42BA97\",\"#F4737A\", \"#1CADE4\"),\n               text = ~sprintf(\"%.1f%%\", Prozentsatz),\n               textposition = \"auto\",\n               textfont = list(color = \"black\")\n  ) %&gt;%\n    layout(\n      title = 'Durchschnittlicher Energieverbrauch der ausgewählten Probanden',\n      xaxis = list(title = htmltools::HTML(paste0('&lt;b&gt;', x_title, '&lt;/b&gt;')),\n                   showgrid = TRUE,\n                   gridcolor = \"lightgray\",\n                   gridwidth = 0.05),\n      yaxis = list(title = htmltools::HTML('&lt;b&gt;Durchschnittliche Energie [kJ]&lt;/b&gt;'), tickformat = \",.0f\",\n                   showgrid = TRUE,\n                   gridcolor = \"lightgray\",\n                   gridwidth = 0.05),\n      barmode = 'stack',\n      bargap = 0.4\n    )\n  \n  # Wirkungsgradbeschriftung \n  for(i in 1:nrow(avg_efficiency_data)) {\n    x_val &lt;- if (length(group_vars) &gt; 1) {\n      interaction(avg_efficiency_data$Intensität[i], avg_efficiency_data$Bedingung[i], sep = \"_\")\n    } else {\n      avg_efficiency_data[[group_vars]][i]\n    }\n    \n    y_val &lt;- sum(avg_energy_data$AvgWert[\n      if (length(group_vars) &gt; 1) {\n        avg_energy_data$Intensität == avg_efficiency_data$Intensität[i] & \n          avg_energy_data$Bedingung == avg_efficiency_data$Bedingung[i]\n      } else {\n        avg_energy_data[[group_vars]] == avg_efficiency_data[[group_vars]][i]\n      }\n    ]) + 15\n    \n    p &lt;- add_annotations(p,\n                         x = x_val,\n                         y = y_val,\n                         text = sprintf(\"η = %.3f\", avg_efficiency_data$AvgWirkungsgrad[i]),\n                         showarrow = FALSE,\n                         yshift = 25,\n                         bgcolor = \"white\",\n                         bordercolor = \"black\",\n                         borderpad = 4\n    )\n  }\n  \n  # Durchschnittliche Leistung beschriften\n  for(i in 1:nrow(avg_power_data)) {\n    x_val &lt;- if (length(group_vars) &gt; 1) {\n      interaction(avg_power_data$Intensität[i], avg_power_data$Bedingung[i], sep = \"_\")\n    } else {\n      avg_power_data[[group_vars]][i]\n    }\n    \n    p &lt;- add_annotations(p,\n                         x = x_val,\n                         y = 0,\n                         text = sprintf(\"P&lt;sub&gt;TOT&lt;/sub&gt; = %.1fW\", avg_power_data$AvgPTOT[i]),\n                         showarrow = FALSE,\n                         yshift = 12,\n                         xanchor = \"center\",\n                         font = list(color = \"black\", size = 10)\n    )\n  }\n  \n  print(\"Plot object created\")\n  return(p)\n})\n  \n  output$summaryTable &lt;- renderDT({\n    # Datenfilterung je nach Auswahl\n    filtered_data &lt;- filter(Bedingungen_data, \n                            Proband %in% input$selectedProband)\n    \n    # Prüfen, ob Bedingungen oder Intensitäten ausgewählt wurden\n    bedingungen_ausgewaehlt &lt;- length(input$selectedBedingung) &gt; 0\n    intensitaeten_ausgewaehlt &lt;- length(input$selectedIntensität) &gt; 0\n    \n    if (bedingungen_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Bedingung %in% input$selectedBedingung)\n    }\n    \n    if (intensitaeten_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Intensität %in% input$selectedIntensität)\n    }\n    \n    # Gruppierung basierend auf der Auswahl\n    if (bedingungen_ausgewaehlt && intensitaeten_ausgewaehlt) {\n      group_vars &lt;- c(\"Bedingung\", \"Intensität\")\n    } else if (bedingungen_ausgewaehlt) {\n      group_vars &lt;- \"Bedingung\"\n    } else if (intensitaeten_ausgewaehlt) {\n      group_vars &lt;- \"Intensität\"\n    } else {\n      # Wenn weder Bedingungen noch Intensitäten ausgewählt sind\n      return(NULL)\n    }\n    \n    # Daten umwandeln und Durchschnittswerte berechnen für die Energiequellen\n    avg_energy_data &lt;- filtered_data %&gt;%\n      group_by(across(all_of(group_vars))) %&gt;%\n      summarise(\n        W_aerob = sprintf(\"%.1f kJ\", round(mean(WAerob_kJ, na.rm = TRUE), 1)),\n        W_BLC = sprintf(\"%.1f kJ\", round(mean(WBLC_kJ, na.rm = TRUE), 1)),\n        W_PCR = sprintf(\"%.1f kJ\", round(mean(WPCR_kJ, na.rm = TRUE), 1)),\n        P_mean = sprintf(\"%.1f Watt\", round(mean(P_mean, na.rm = TRUE), 1)),\n        P_Int = sprintf(\"%.1f Watt\", round(mean(P_Int, na.rm = TRUE), 1)),\n        Drehzahl = sprintf(\"%.1f rpm\", mean(nD, na.rm = TRUE)),\n        Wirkungsgrad = sprintf(\"%.2f%%\", 100 * mean(WirkPhysio, na.rm = TRUE)),\n        Efficiency = sprintf(\"%.2f%%\", mean(Efficiency, na.rm = TRUE)),\n        `Pedal Smoothness` = sprintf(\"%.2f%%\", mean(Pedal_Smoothness, na.rm = TRUE)),\n        `P_max` = sprintf(\"%.1f Watt\", mean(P_max, na.rm = TRUE)),\n        `HR%` = sprintf(\"%.1f%%\", mean(HR_percent, na.rm = TRUE)),\n        `VO2%` = sprintf(\"%.1f%%\", mean(VO2_percent, na.rm = TRUE)),\n        `ΔBLC` = sprintf(\"%.1f mmol/L\", mean(`ΔBLC`, na.rm = TRUE))\n      ) %&gt;% \n      ungroup()\n    \n    # Anzeigen der Zusammenfassung in der Tabelle\n    datatable(avg_energy_data)\n  })\n  \n  output$ggbetweenstatsPlot &lt;- renderPlot({\n    # Datenfilterung je nach Auswahl\n    filtered_data &lt;- filter(Bedingungen_data, \n                            Proband %in% input$selectedProband)\n    \n    # Prüfen, ob Bedingungen oder Intensitäten ausgewählt wurden\n    bedingungen_ausgewaehlt &lt;- length(input$selectedBedingung) &gt; 0\n    intensitaeten_ausgewaehlt &lt;- length(input$selectedIntensität) &gt; 0\n    \n    if (bedingungen_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Bedingung %in% input$selectedBedingung)\n    }\n    \n    if (intensitaeten_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Intensität %in% input$selectedIntensität)\n    }\n    \n    # Wenn weder Bedingungen noch Intensitäten ausgewählt sind\n    if (!bedingungen_ausgewaehlt && !intensitaeten_ausgewaehlt) {\n      return(NULL)\n    }\n    \n    # Erstellen des Plots mit angepasster Textgröße\n    if (bedingungen_ausgewaehlt && intensitaeten_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;%\n        mutate(Intensität_Bedingung = interaction(Intensität, Bedingung, sep = \"_\"))\n      \n      plt &lt;- ggbetweenstats(\n        data = filtered_data,\n        x = Intensität_Bedingung,\n        y = WirkPhysio,\n        type = \"parametric\",\n        var.equal = TRUE,\n        plot.type = \"box\",\n        pairwise.comparisons = TRUE,\n        pairwise.display = \"all\",\n        p.adjust.method = \"bonferroni\",\n        centrality.plotting = TRUE,\n        bf.message = FALSE,\n        title = \"WirkPhysio nach Intensität und Bedingung\",\n        xlab = \"Intensität_Bedingung\",\n        ylab = \"WirkPhysio\",\n        ggtheme = ggplot2::theme_light() +\n          theme(\n            plot.title = element_text(size = 18, face = \"bold\"),\n            axis.title.x = element_text(size = 16),\n            axis.title.y = element_text(size = 16),\n            axis.text.x = element_text(size = 12, angle = 45, hjust = 1),\n            axis.text.y = element_text(size = 12)\n          )\n      ) +\n        ggplot2::theme(\n          text = element_text(size = 14),  # Erhöht die Größe des gesamten Textes\n          plot.subtitle = element_text(size = 16),  # Erhöht die Größe des Untertitels (einschließlich p-Werte)\n          axis.title = element_text(size = 16),\n          axis.text = element_text(size = 14)\n        )\n    } else if (bedingungen_ausgewaehlt) {\n      plt &lt;- ggbetweenstats(\n        data = filtered_data,\n        x = Bedingung,\n        y = WirkPhysio,\n        type = \"parametric\",\n        var.equal = TRUE,\n        plot.type = \"box\",\n        pairwise.comparisons = TRUE,\n        pairwise.display = \"all\",\n        p.adjust.method = \"bonferroni\",\n        centrality.plotting = TRUE,\n        bf.message = FALSE,\n        title = \"WirkPhysio nach Bedingung\",\n        xlab = \"Bedingung\",\n        ylab = \"WirkPhysio\",\n        ggtheme = ggplot2::theme_light() +\n          theme(\n            plot.title = element_text(size = 16, face = \"bold\"),\n            axis.title.x = element_text(size = 14),\n            axis.title.y = element_text(size = 14),\n            axis.text.x = element_text(size = 12),\n            axis.text.y = element_text(size = 12)\n          )\n      )\n    } else if (intensitaeten_ausgewaehlt) {\n      plt &lt;- ggbetweenstats(\n        data = filtered_data,\n        x = Intensität,\n        y = WirkPhysio,\n        type = \"parametric\",\n        var.equal = TRUE,\n        plot.type = \"box\",\n        pairwise.comparisons = TRUE,\n        pairwise.display = \"all\",\n        p.adjust.method = \"bonferroni\",\n        centrality.plotting = TRUE,\n        bf.message = FALSE,\n        title = \"WirkPhysio nach Intensität\",\n        xlab = \"Intensität\",\n        ylab = \"WirkPhysio\",\n        ggtheme = ggplot2::theme_light() +\n          theme(\n            plot.title = element_text(size = 16, face = \"bold\"),\n            axis.title.x = element_text(size = 14),\n            axis.title.y = element_text(size = 14),\n            axis.text.x = element_text(size = 12),\n            axis.text.y = element_text(size = 12)\n          )\n      )\n    }\n    \n    print(plt)\n  })\n  \n  output$anovaResults &lt;- renderPrint({\n    # Datenfilterung je nach Auswahl\n    filtered_data &lt;- filter(Bedingungen_data, \n                            Proband %in% input$selectedProband)\n    \n    # Prüfen, ob Bedingungen oder Intensitäten ausgewählt wurden\n    bedingungen_ausgewaehlt &lt;- length(input$selectedBedingung) &gt; 0\n    intensitaeten_ausgewaehlt &lt;- length(input$selectedIntensität) &gt; 0\n    \n    if (bedingungen_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Bedingung %in% input$selectedBedingung)\n    }\n    \n    if (intensitaeten_ausgewaehlt) {\n      filtered_data &lt;- filtered_data %&gt;% \n        filter(Intensität %in% input$selectedIntensität)\n    }\n    \n    # Wenn weder Bedingungen noch Intensitäten ausgewählt sind\n    if (!bedingungen_ausgewaehlt && !intensitaeten_ausgewaehlt) {\n      return(\"Bitte wählen Sie mindestens eine Bedingung oder Intensität aus.\")\n    }\n    \n    # Kombinierte Gruppe erstellen\n    filtered_data &lt;- filtered_data %&gt;%\n      mutate(Kombinierte_Gruppe = interaction(Bedingung, Intensität, sep = \"_\"))\n    \n    # ANOVA für WirkPhysio durchführen\n    anova_model &lt;- aov(WirkPhysio ~ Kombinierte_Gruppe, data = filtered_data)\n    \n    # ANOVA-Ergebnisse ausgeben\n    cat(\"ANOVA-Ergebnisse für WirkPhysio:\\n\\n\")\n    print(summary(anova_model))\n    \n    # Zusätzliche statistische Werte\n    cat(\"\\nZusätzliche statistische Werte:\\n\")\n    cat(\"Mittelwert WirkPhysio:\", mean(filtered_data$WirkPhysio, na.rm = TRUE), \"\\n\")\n    cat(\"Standardabweichung WirkPhysio:\", sd(filtered_data$WirkPhysio, na.rm = TRUE), \"\\n\")\n    cat(\"Median WirkPhysio:\", median(filtered_data$WirkPhysio, na.rm = TRUE), \"\\n\")\n    cat(\"Minimum WirkPhysio:\", min(filtered_data$WirkPhysio, na.rm = TRUE), \"\\n\")\n    cat(\"Maximum WirkPhysio:\", max(filtered_data$WirkPhysio, na.rm = TRUE), \"\\n\")\n    \n    # Post-hoc Test (Tukey HSD), wenn mindestens 3 Kombinationen vorhanden sind\n    if (length(unique(filtered_data$Kombinierte_Gruppe)) &gt;= 3) {\n      cat(\"\\nTukey HSD Post-hoc Test:\\n\")\n      tukey_result &lt;- TukeyHSD(anova_model)\n      print(tukey_result)\n    } else {\n      cat(\"\\nKein Post-hoc Test durchgeführt, da weniger als 3 Kombinationen ausgewählt wurden.\\n\")\n    }\n  })\n}\n\n# Starte ShinyApp\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Ergebnisse und Statistik"
    ]
  },
  {
    "objectID": "Ergebnisse_test.html",
    "href": "Ergebnisse_test.html",
    "title": "EPOC-Modellfunktion",
    "section": "",
    "text": "1 Darstellung und Auswertung des Energieumsatzes und Wirkungsgrads unter verschiedenen Bedingungen und Intensitäten\n#| standalone: true\n#| viewerHeight: 1200\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(plotly)\n\n# Erweiterter Datensatz mit angepassten Spaltennamen\nBedingungen_data &lt;- data.frame(\n  Proband = factor(rep(c(1, 6, 10, 13, 14, 15, 17, 18, 19), each = 6)),\n  Bedingung = rep(c(\"stehen\", \"sitzen\", \"sitzen\", \"stehen\", \"sitzen\", \"stehen\"), 9),\n  Intensität = rep(c(\"leicht\", \"leicht\", \"moderat\", \"moderat\", \"schwer\", \"schwer\"), 9),\n  WirkPhysio = runif(54, 0.22, 0.27),\n  WAerob_kJ = runif(54, 200, 500),\n  WPCR_kJ = runif(54, 10, 50),\n  WBLC_kJ = runif(54, 5, 25),\n  WTOT_kJ = runif(54, 250, 600),\n  P_Tot = runif(54, 200, 450),\n  P_mean = runif(54, 175, 400),\n  P_Int = runif(54, 14, 60),\n  nD = runif(54, 59, 101),\n  Efficiency = runif(54, 50, 97),\n  Pedal_Smoothness = runif(54, 32, 58),\n  P_max = runif(54, 400, 850),\n  HR_percent = runif(54, 80, 96),\n  VO2_percent = runif(54, 59, 90),\n  ΔBLC = runif(54, 1, 7)\n)\n\nui &lt;- fluidPage(\n  titlePanel(\"Energieumsatz unter verschiedenen Bedingungen\"),\n  sidebarLayout(\n    sidebarPanel(\n      checkboxGroupInput(\"selectedBedingung\", \"Bedingungen:\",\n                         choices = unique(Bedingungen_data$Bedingung),\n                         selected = unique(Bedingungen_data$Bedingung)),\n      checkboxGroupInput(\"selectedIntensität\", \"Intensitäten:\",\n                         choices = unique(Bedingungen_data$Intensität),\n                         selected = unique(Bedingungen_data$Intensität)),\n      checkboxGroupInput(\"selectedProband\", \"Probanden:\",\n                         choices = unique(Bedingungen_data$Proband),\n                         selected = unique(Bedingungen_data$Proband))\n    ),\n    mainPanel(\n      plotlyOutput(\"barplot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$barplot &lt;- renderPlotly({\n    filtered_data &lt;- Bedingungen_data %&gt;%\n      filter(Proband %in% input$selectedProband,\n             Bedingung %in% input$selectedBedingung,\n             Intensität %in% input$selectedIntensität)\n    \n    avg_energy_data &lt;- filtered_data %&gt;%\n      gather(Energiequelle, Wert, WAerob_kJ, WPCR_kJ, WBLC_kJ) %&gt;%\n      group_by(Bedingung, Intensität, Energiequelle) %&gt;%\n      summarize(AvgWert = mean(Wert, na.rm = TRUE),\n                AvgWTOT = mean(WTOT_kJ, na.rm = TRUE),\n                Prozentsatz = (AvgWert / AvgWTOT) * 100)\n    \n    avg_efficiency_data &lt;- filtered_data %&gt;%\n      group_by(Bedingung, Intensität) %&gt;%\n      summarize(AvgWirkungsgrad = mean(WirkPhysio, na.rm = TRUE))\n    \n    avg_power_data &lt;- filtered_data %&gt;%\n      group_by(Bedingung, Intensität) %&gt;%\n      summarize(AvgPTOT = mean(P_Tot, na.rm = TRUE))\n    \n    p &lt;- plot_ly(data = avg_energy_data, \n                 x = ~interaction(Intensität, Bedingung), \n                 y = ~AvgWert, \n                 color = ~Energiequelle, \n                 type = 'bar',\n                 marker = list(line = list(color = 'black', width = 0.75)),\n                 colors = c(\"#42BA97\",\"#F4737A\", \"#1CADE4\"),\n                 text = ~sprintf(\"%.1f%%\", Prozentsatz),\n                 textposition = \"auto\",\n                 textfont = list(color = \"black\")) %&gt;%\n      layout(\n        title = 'Durchschnittlicher Energieverbrauch der ausgewählten Probanden',\n        xaxis = list(title = 'Intensität_Bedingung',\n                     showgrid = TRUE,\n                     gridcolor = \"lightgray\",\n                     gridwidth = 0.05),\n        yaxis = list(title = 'Durchschnittliche Energie [kJ]', tickformat = \",.0f\",\n                     showgrid = TRUE,\n                     gridcolor = \"lightgray\",\n                     gridwidth = 0.05),\n        barmode = 'stack',\n        bargap = 0.4\n      )\n    \n    for(i in 1:nrow(avg_efficiency_data)) {\n      p &lt;- add_annotations(p,\n                           x = interaction(avg_efficiency_data$Intensität[i], avg_efficiency_data$Bedingung[i]),\n                           y = sum(avg_energy_data$AvgWert[avg_energy_data$Intensität == avg_efficiency_data$Intensität[i] & \n                                                             avg_energy_data$Bedingung == avg_efficiency_data$Bedingung[i]]) + 15,\n                           text = sprintf(\"η = %.3f\", avg_efficiency_data$AvgWirkungsgrad[i]),\n                           showarrow = FALSE,\n                           yshift = 25,\n                           bgcolor = \"white\",\n                           bordercolor = \"black\",\n                           borderpad = 4\n      )\n    }\n    \n    for(i in 1:nrow(avg_power_data)) {\n      p &lt;- add_annotations(p,\n                           x = interaction(avg_power_data$Intensität[i], avg_power_data$Bedingung[i]),\n                           y = 0,\n                           text = sprintf(\"P&lt;sub&gt;TOT&lt;/sub&gt; = %.1fW\", avg_power_data$AvgPTOT[i]),\n                           showarrow = FALSE,\n                           yshift = 12,\n                           xanchor = \"center\",\n                           font = list(color = \"black\", size = 10)\n      )\n    }\n    \n    p\n  })\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n2 Test",
    "crumbs": [
      "Ergebnisse und Statistik - Test"
    ]
  }
]