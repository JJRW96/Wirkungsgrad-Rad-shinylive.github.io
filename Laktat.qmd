---
title: "Laktat-Modellfunktionen"
format:
  html:
    resources: 
      - shinylive-sw.js

filters:
  - webr
  - shinylive
---


# Blutlaktat-Modellfunktion: Exponentieller Abfall nach dem Belastungsende

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)
library(minpack.lm)

# Define data
t_s <- c(23, 127, 261, 422.5, 549.8, 664.5, 795.8, 1254.9)
BLC_t <- c(10.04, 7.49, 5.18, 3.9, 2.67, 2.18, 1.64, 0.98)

# New model function: A * exp(-k * (t - delay)) + BLC0
laktat_model_function <- function(t, A, k, BLC0, delay) {
  A * exp(-k * (t - delay)) + BLC0
}

# User interface (UI)
ui <- fluidPage(
  titlePanel("Exponentielles Laktat-Abbaumodell"),
  sidebarLayout(
    sidebarPanel(
      width = 3,
      sliderInput("A", "A [mmol/l]", min = 0.0, max = 15.0, value = 8.0, step = 0.1),
      sliderInput("k", "k [s^-1]", min = 0.0001, max = 0.02, value = 0.005, step = 0.0001),
      sliderInput("BLC0", "BLC0 [mmol/l]", min = 0.0, max = 5.0, value = 1.0, step = 0.01),
      sliderInput("delay", "Delay [s]", min = 0, max = 3600, value = 0, step = 0.1),
      actionButton("set_delay", "Delay auf BLC_1"),
      br(), 
      actionButton("optimize", "Anpassen: nlsLM"),
      fileInput("file_upload", "CSV-Datei hochladen", accept = ".csv")
    ),
    mainPanel(
      plotlyOutput("plot")
    )
  )
)

# Server logic
server <- function(input, output, session) {
  # Reactive value for uploaded data
  uploaded_data <- reactiveVal(NULL)
  
  # Observer for CSV upload
  observeEvent(input$file_upload, {
    req(input$file_upload)
    df <- read.csv(input$file_upload$datapath)
    
    if ("t_s" %in% names(df) && "BLC_t" %in% names(df)) {
      uploaded_data(df)
    } else {
      showModal(modalDialog(
        title = "Ungültige CSV",
        "Die CSV-Datei muss 't_s' und 'BLC_t' als Spaltennamen enthalten.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  # Observer for setting delay to first time point
  observeEvent(input$set_delay, {
    data <- if (is.null(uploaded_data())) {
      data.frame(t_s = t_s, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    updateSliderInput(session, "delay", value = min(data$t_s))
  })
  
  observeEvent(input$optimize, {
    data <- if (is.null(uploaded_data())) {
      data.frame(t_s = t_s, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    delay <- input$delay
    
    # Filter data points after the delay
    data_filtered <- data[data$t_s > delay, ]
    
    if (nrow(data_filtered) < 3) {
      showNotification("Nicht genügend Datenpunkte nach dem Delay für den Fitting-Prozess.", type = "error")
      return()
    }
    
    best_fit <- NULL
    best_rss <- Inf
    
    withProgress(message = 'Fitting in progress', value = 0, {
      for (i in 1:100) {
        # Randomized starting values
        A_start <- runif(1, 0, 15)
        k_start <- runif(1, 0.0001, 0.02)
        BLC0_start <- runif(1, 0, 5)
        
        start_values <- list(A = A_start, k = k_start, BLC0 = BLC0_start)
        
        model_equation <- BLC_t ~ A * exp(-k * (t_s - delay)) + BLC0
        
        fit <- try(nlsLM(model_equation,
                         data = data_filtered,
                         start = start_values,
                         lower = c(A = 0, k = 0.0001, BLC0 = 0),
                         upper = c(A = 15, k = 0.02, BLC0 = 5),
                         control = nls.control(maxiter = 1024)), silent = TRUE)
        
        if (!inherits(fit, "try-error")) {
          rss <- sum(residuals(fit)^2)
          if (rss < best_rss) {
            best_rss <- rss
            best_fit <- fit
          }
        }
        
        incProgress(1/100, detail = paste("Iteration", i))
      }
    })
    
    if (!is.null(best_fit)) {
      params <- as.list(coef(best_fit))
      updateSliderInput(session, "A", value = params$A)
      updateSliderInput(session, "k", value = params$k)
      updateSliderInput(session, "BLC0", value = params$BLC0)
      
      showNotification("Fitting completed successfully!", type = "message")
    } else {
      showModal(modalDialog(
        title = "nlsLM fehlgeschlagen",
        "Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  output$plot <- renderPlotly({
    A <- input$A
    k <- input$k
    BLC0 <- input$BLC0
    delay <- input$delay
    
    data <- if (is.null(uploaded_data())) {
      data.frame(t_s = t_s, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    max_x <- max(data$t_s) * 1.66
    min_x <- max(delay - 360, 0)
    
    t_s_modell <- seq(min_x, max_x, length.out = 1000)
    BLC_t_modell <- laktat_model_function(t_s_modell, A, k, BLC0, delay)
    
    max_y <- max(max(BLC_t_modell) * 1.1, max(data$BLC_t) * 1.1)
    
    # Create equation text
    eq_text <- sprintf("BLC(t) = %.2f * e<sup>-%.4f*(t-%.2f)</sup> + %.3f", A, k, delay, BLC0)
    
    # Calculate R²
    data_filtered <- data[data$t_s > delay, ]
    BLC_t_modell_at_data <- laktat_model_function(data_filtered$t_s, A, k, BLC0, delay)
    ss_res <- sum((data_filtered$BLC_t - BLC_t_modell_at_data)^2)
    ss_tot <- sum((data_filtered$BLC_t - mean(data_filtered$BLC_t))^2)
    r_squared <- 1 - (ss_res / ss_tot)
    
    # Plotly plot
    p <- plot_ly() %>%
      add_trace(x = t_s_modell[t_s_modell >= delay], y = BLC_t_modell[t_s_modell >= delay], 
                type = 'scatter', mode = 'lines', 
                name = 'Modellfunktion', line = list(color = '#EF6F6A')) %>%
      add_trace(x = t_s_modell[t_s_modell < delay], y = BLC_t_modell[t_s_modell < delay], 
                type = 'scatter', mode = 'lines', 
                name = 'Modellfunktion (vor Delay)', line = list(color = '#EF6F6A', dash = 'dash')) %>%
      add_trace(x = data$t_s, y = data$BLC_t, type = 'scatter', mode = 'markers', 
                name = 'Gemessene BLC-Werte', marker = list(color = '#42BA97', size = 10, symbol = 'x')) %>%
      add_segments(x = delay, xend = delay, y = 0, yend = max_y, 
                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), 
                   showlegend = FALSE, opacity = 0.75) %>%
      layout(title = "Exponentielles Laktat-Abbaumodell",
             margin = list(t = 40),
             xaxis = list(title = "Zeit [s]", range = c(min_x, max_x)),
             yaxis = list(title = "Laktat [mmol/l]", range = c(0, max_y)),
             annotations = list(
               list(
                 x = max_x * 0.5, 
                 y = max_y * 0.95,
                 text = eq_text,
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.5,
                 y = max_y * 0.90,
                 text = sprintf("R²: %.4f", r_squared),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               )
             ))
    
    p
  })
}

# Start the app
shinyApp(ui = ui, server = server)
```

# Blutlaktat-Bateman-Modellfunktion: Während und nach dem Belastungszeitraum

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)
library(minpack.lm)

# Definiere Daten
t_min <- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)
BLC_t <- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)

# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist
if (min(t_min) > 0.0) {
  t_min <- t_min - min(t_min)
}

# Bateman-Funktion für Laktatwerte (in Minuten) mit BLC0
bateman_function <- function(t, a, k1, k2, BLC0) {
  BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t) - exp(-k2 * t))
}

# Invasions- und Eliminationsfunktionen
invasion_function <- function(t, a, k1, BLC0) {
  BLC0 + a * (1 - exp(-k1 * t))
}

elimination_function <- function(t, a, k2, BLC0) {
  BLC0 + a * exp(-k2 * t)
}

# Benutzeroberfläche (UI)
ui <- fluidPage(
  titlePanel("Bateman-Funktion für Laktat-Modellierung"),
  sidebarLayout(
    sidebarPanel(
      width = 3,
      sliderInput("a", "a [mmol/l]", min = 0.0, max = 30.0, value = 15.0, step = 0.01),
      sliderInput("k1", "k1 [min^-1]", min = 0.1, max = 3.5, value = 0.5, step = 0.001),
      sliderInput("k2", "k2 [min^-1]", min = 0.020, max = 0.200, value = 0.10, step = 0.001),
      sliderInput("BLC0", "BLC0 [mmol/l]", min = 0.0, max = 5.0, value = 1.0, step = 0.01),
      actionButton("optimize", "Anpassen: nlsLM"),
      fileInput("file_upload", "CSV-Datei hochladen", accept = ".csv")
    ),
    mainPanel(
      plotlyOutput("plot")
    )
  )
)

# Server-Logik
server <- function(input, output, session) {
  
  # Reaktiver Wert für hochgeladene Daten
  uploaded_data <- reactiveVal(NULL)
  
  # Beobachter für CSV-Upload
  observeEvent(input$file_upload, {
    req(input$file_upload)
    df <- read.csv(input$file_upload$datapath)
    
    if ("t_min" %in% names(df) && "BLC_t" %in% names(df)) {
      if (df$t_min[1] != 0.0) {
        df$t_min <- df$t_min - df$t_min[1]
      }
      
      uploaded_data(df)
    } else {
      showModal(modalDialog(
        title = "Ungültige CSV",
        "Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  observeEvent(input$optimize, {
    data <- if (is.null(uploaded_data())) {
      data.frame(t_min = t_min, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    # Setze BLC0 Grenzen basierend auf dem ersten BLC_t Wert
    BLC0_lower <- max(0, data$BLC_t[1] * 0.9)
    BLC0_upper <- min(5, data$BLC_t[1] * 1.1)
    
    best_fit <- NULL
    best_rss <- Inf
    
    withProgress(message = 'Fitting in progress', value = 0, {
      for (i in 1:100) {
        # Randomisierte Startwerte
        a_start <- runif(1, 0, 30)
        k1_start <- runif(1, 0.1, 3.5)
        k2_start <- runif(1, 0.020, 0.200)
        BLC0_start <- runif(1, BLC0_lower, BLC0_upper)
        
        start_values <- list(a = a_start, k1 = k1_start, k2 = k2_start, BLC0 = BLC0_start)
        
        model_equation <- BLC_t ~ BLC0 + (a * k1 / (k2 - k1)) * (exp(-k1 * t_min) - exp(-k2 * t_min))
        
        fit <- try(nlsLM(model_equation,
                         data = data,
                         start = start_values,
                         lower = c(a = 0.0, k1 = 0.1, k2 = 0.020, BLC0 = BLC0_lower),
                         upper = c(a = 30.0, k1 = 3.5, k2 = 0.200, BLC0 = BLC0_upper),
                         control = nls.control(maxiter = 1024)), silent = TRUE)
        
        if (!inherits(fit, "try-error")) {
          rss <- sum(residuals(fit)^2)
          if (rss < best_rss) {
            best_rss <- rss
            best_fit <- fit
          }
        }
        
        incProgress(1/100, detail = paste("Iteration", i))
      }
    })
    
    if (!is.null(best_fit)) {
      params <- as.list(coef(best_fit))
      updateSliderInput(session, "a", value = params$a)
      updateSliderInput(session, "k1", value = params$k1)
      updateSliderInput(session, "k2", value = params$k2)
      updateSliderInput(session, "BLC0", value = params$BLC0)
      
      showNotification("Fitting completed successfully!", type = "message")
    } else {
      showModal(modalDialog(
        title = "nlsLM fehlgeschlagen",
        "Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  output$plot <- renderPlotly({
    a <- input$a
    k1 <- input$k1
    k2 <- input$k2
    BLC0 <- input$BLC0
    
    data <- if (is.null(uploaded_data())) {
      data.frame(t_min = t_min, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    max_x <- max(data$t_min) * 1.66
    
    t_min_modell <- seq(0, max_x, length.out = 1000)
    BLC_t_modell <- bateman_function(t_min_modell, a, k1, k2, BLC0)
    invasion_modell <- invasion_function(t_min_modell, a, k1, BLC0)
    elimination_modell <- elimination_function(t_min_modell, a, k2, BLC0)
    
    max_y <- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2, max(invasion_modell) * 1.2, max(elimination_modell) * 1.2)
    
    # Berechne tmax und Lamax
    tmax <- log(k1/k2) / (k1 - k2)
    Lamax <- bateman_function(tmax, a, k1, k2, BLC0)
    
    # Erstelle Gleichungstext
    eq_text <- sprintf("[La]<sub>b(t)</sub> = %.2f + (%.2f * %.3f / (%.3f - %.3f)) * (e<sup>-%.3f*t</sup> - e<sup>-%.3f*t</sup>)", 
                       BLC0, a, k1, k2, k1, k1, k2)
    
    # Berechne R²
    BLC_t_modell_at_data <- bateman_function(data$t_min, a, k1, k2, BLC0)
    ss_res <- sum((data$BLC_t - BLC_t_modell_at_data)^2)
    ss_tot <- sum((data$BLC_t - mean(data$BLC_t))^2)
    r_squared <- 1 - (ss_res / ss_tot)
    
    # Plotly-Plot
    p <- plot_ly() %>%
      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', 
                name = 'Bateman-Funktion', line = list(color = '#EF5350')) %>%
      add_trace(x = t_min_modell, y = invasion_modell, type = 'scatter', mode = 'lines', 
                name = 'Invasion', line = list(color = "#9C85C0", width = 2, dash = '8 5'),
                opacity = 0.65) %>%
      add_trace(x = t_min_modell, y = elimination_modell, type = 'scatter', mode = 'lines', 
                name = 'Elimination', line = list(color = '#2683C6', width = 2, dash = '8 5'),
                opacity = 0.65) %>%
      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', 
                name = 'Gemessene BLC-Werte', marker = list(color = "#42BA97", size = 9, symbol = 'x')) %>%
      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, 
                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), 
                   showlegend = FALSE, opacity = 0.5) %>%
      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, 
                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), 
                   showlegend = FALSE, opacity = 0.5) %>%
      layout(title = "Bateman-Funktion für Laktat-Modellierung",
             margin = list(t = 40),
             xaxis = list(title = "Zeit [min]", range = c(0, max_x)),
             yaxis = list(title = "Laktat [mmol/l]", range = c(0, max_y)),
             annotations = list(
               list(
                 x = max_x * 0.5, 
                 y = max_y * 0.95,
                 text = eq_text,
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.5,
                 y = max_y * 0.90,
                 text = sprintf("R²: %.4f", r_squared),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.5,
                 y = max_y * 0.85,
                 text = sprintf("BLC<sub>max</sub>: %.2f mmol/l, TBLC<sub>max</sub>: %.2f min", Lamax, tmax),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               )
             ))
    
    p
  })
}

# Starte die App
shinyApp(ui = ui, server = server)
```

# Blutlaktat-Kompartmentmodell-Modellfunktion (nach Freund et al. 1986): Während und nach dem Belastungszeitraum

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)
library(minpack.lm)

# Definiere Daten
t_min <- c(0.4, 3.3, 6.5, 8.4, 10.2, 12.5, 14.9, 16.7, 19.3)
BLC_t <- c(0.82, 4.53, 6.97, 7.52, 7.73, 7.28, 6.37, 5.41, 4.71)

# Normalisiere t_min, wenn der kleinste Wert größer als 0.0 ist
if (min(t_min) > 0.0) {
  t_min <- t_min - min(t_min)
}

# Freund et al. Kompartmentmodell-Funktion
freund_model <- function(t, A1, A2, gamma1, gamma2, La0) {
  La0 + A1 * (1 - exp(-gamma1 * t)) + A2 * (1 - exp(-gamma2 * t))
}

# Berechne tmax und Lamax
calculate_tmax_lamax <- function(A1, A2, gamma1, gamma2, La0) {
  f <- function(t) freund_model(t, A1, A2, gamma1, gamma2, La0)
  tmax <- optimize(f, c(0, 100), maximum = TRUE)$maximum
  Lamax <- f(tmax)
  list(tmax = tmax, Lamax = Lamax)
}

# Benutzeroberfläche (UI)
ui <- fluidPage(
  titlePanel("Kompartmentmodell für Laktat-Modellierung"),
  sidebarLayout(
    sidebarPanel(
      width = 3,
      sliderInput("A1", "A1 [mmol/l]", min = 0.0, max = 100.0, value = 20.0, step = 0.1),
      sliderInput("A2", "A2 [mmol/l]", min = -100.0, max = 0.0, value = -20.0, step = 0.1),
      sliderInput("gamma1", "γ1 [min^-1]", min = 0.05, max = 2.0, value = 0.1, step = 0.001),
      sliderInput("gamma2", "γ2 [min^-1]", min = 0.01, max = 0.5, value = 0.05, step = 0.001),
      sliderInput("La0", "La0 [mmol/l]", min = 0.0, max = 5.0, value = 1.0, step = 0.01),
      actionButton("optimize", "Anpassen: nlsLM"),
      fileInput("file_upload", "CSV-Datei hochladen", accept = ".csv")
    ),
    mainPanel(
      plotlyOutput("plot")
    )
  )
)

# Server-Logik
server <- function(input, output, session) {
  
  # Reaktiver Wert für hochgeladene Daten
  uploaded_data <- reactiveVal(NULL)
  
  # Beobachter für CSV-Upload
  observeEvent(input$file_upload, {
    req(input$file_upload)
    df <- read.csv(input$file_upload$datapath)
    
    if ("t_min" %in% names(df) && "BLC_t" %in% names(df)) {
      if (df$t_min[1] != 0.0) {
        df$t_min <- df$t_min - df$t_min[1]
      }
      
      uploaded_data(df)
    } else {
      showModal(modalDialog(
        title = "Ungültige CSV",
        "Die CSV-Datei muss 't_min' und 'BLC_t' als Spaltennamen enthalten.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  observeEvent(input$optimize, {
    data <- if (is.null(uploaded_data())) {
      data.frame(t_min = t_min, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    # Setze La0 Grenzen basierend auf dem ersten BLC_t Wert
    La0_lower <- max(0, data$BLC_t[1] * 0.9)
    La0_upper <- min(5, data$BLC_t[1] * 1.1)
    
    best_fit <- NULL
    best_rss <- Inf
    
    withProgress(message = 'Fitting in progress', value = 0, {
      for (i in 1:100) {
        # Randomisierte Startwerte
        A1_start <- runif(1, 0, 100)
        A2_start <- runif(1, -100, 0)
        gamma1_start <- runif(1, 0.05, 2)
        gamma2_start <- runif(1, 0.01, 0.5)
        La0_start <- runif(1, La0_lower, La0_upper)
        
        start_values <- list(A1 = A1_start, A2 = A2_start, gamma1 = gamma1_start, gamma2 = gamma2_start, La0 = La0_start)
        
        model_equation <- BLC_t ~ La0 + A1 * (1 - exp(-gamma1 * t_min)) + A2 * (1 - exp(-gamma2 * t_min))
        
        fit <- try(nlsLM(model_equation,
                         data = data,
                         start = start_values,
                         lower = c(A1 = 0.0, A2 = -100.0, gamma1 = 0.05, gamma2 = 0.01, La0 = La0_lower),
                         upper = c(A1 = 100.0, A2 = 0.0, gamma1 = 2.0, gamma2 = 0.5, La0 = La0_upper),
                         control = nls.control(maxiter = 1024)), silent = TRUE)
        
        if (!inherits(fit, "try-error")) {
          rss <- sum(residuals(fit)^2)
          if (rss < best_rss) {
            best_rss <- rss
            best_fit <- fit
          }
        }
        
        incProgress(1/100, detail = paste("Iteration", i))
      }
    })
    
    if (!is.null(best_fit)) {
      params <- as.list(coef(best_fit))
      updateSliderInput(session, "A1", value = params$A1)
      updateSliderInput(session, "A2", value = params$A2)
      updateSliderInput(session, "gamma1", value = params$gamma1)
      updateSliderInput(session, "gamma2", value = params$gamma2)
      updateSliderInput(session, "La0", value = params$La0)
      
      showNotification("Fitting completed successfully!", type = "message")
    } else {
      showModal(modalDialog(
        title = "nlsLM fehlgeschlagen",
        "Die nicht-lineare Regression mit dem Levenberg-Marquardt-Algorithmus konnte nicht erfolgreich durchgeführt werden.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  output$plot <- renderPlotly({
    A1 <- input$A1
    A2 <- input$A2
    gamma1 <- input$gamma1
    gamma2 <- input$gamma2
    La0 <- input$La0
    
    data <- if (is.null(uploaded_data())) {
      data.frame(t_min = t_min, BLC_t = BLC_t)
    } else {
      uploaded_data()
    }
    
    max_x <- max(data$t_min) * 1.66
    
    t_min_modell <- seq(0, max_x, length.out = 1000)
    BLC_t_modell <- freund_model(t_min_modell, A1, A2, gamma1, gamma2, La0)
    
    max_y <- max(max(BLC_t_modell) * 1.2, max(data$BLC_t) * 1.2)
    
    # Berechne tmax und Lamax
    results <- calculate_tmax_lamax(A1, A2, gamma1, gamma2, La0)
    tmax <- results$tmax
    Lamax <- results$Lamax
    
    # Erstelle Gleichungstext
    eq_text <- sprintf("[La]<sub>b(t)</sub> = %.2f + %.1f * (1 - e<sup>-%.3f*t</sup>) + %.1f * (1 - e<sup>-%.3f*t</sup>)", 
                       La0, A1, gamma1, A2, gamma2)
    
    # Berechne R²
    BLC_t_modell_at_data <- freund_model(data$t_min, A1, A2, gamma1, gamma2, La0)
    ss_res <- sum((data$BLC_t - BLC_t_modell_at_data)^2)
    ss_tot <- sum((data$BLC_t - mean(data$BLC_t))^2)
    r_squared <- 1 - (ss_res / ss_tot)
    
    # Plotly-Plot
    p <- plot_ly() %>%
      add_trace(x = t_min_modell, y = BLC_t_modell, type = 'scatter', mode = 'lines', 
                name = 'Modellgleichung', line = list(color = '#EF5350')) %>%
      add_trace(x = data$t_min, y = data$BLC_t, type = 'scatter', mode = 'markers', 
                name = 'Gemessene BLC-Werte', marker = list(color = "#42BA97", size = 9, symbol = 'x')) %>%
      add_segments(x = tmax, xend = tmax, y = 0, yend = max_y, 
                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), 
                   showlegend = FALSE, opacity = 0.5) %>%
      add_segments(x = 0, xend = max_x, y = Lamax, yend = Lamax, 
                   line = list(color = 'darkgrey', width = 1, dash = 'dash'), 
                   showlegend = FALSE, opacity = 0.5) %>%
      layout(title = "Freund et al. Kompartmentmodell für Laktat-Modellierung",
             margin = list(t = 40),
             xaxis = list(title = "Zeit [min]", range = c(0, max_x)),
             yaxis = list(title = "Laktat [mmol/l]", range = c(0, max_y)),
             annotations = list(
               list(
                 x = max_x * 0.5, 
                 y = max_y * 0.95,
                 text = eq_text,
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.5,
                 y = max_y * 0.90,
                 text = sprintf("R²: %.4f", r_squared),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               ),
               list(
                 x = max_x * 0.5,
                 y = max_y * 0.85,
                 text = sprintf("BLC<sub>max</sub>: %.2f mmol/l, TBLC<sub>max</sub>: %.2f min", Lamax, tmax),
                 showarrow = FALSE,
                 xanchor = 'left',
                 yanchor = 'bottom',
                 font = list(
                   size = 12,
                   color = "black"
                 )
               )
             ))
    
    p
  })
}

# Starte die App
shinyApp(ui = ui, server = server)
```


# Laktat-Leistungs-Beziehung

```{shinylive-r}
#| standalone: true
#| viewerHeight: 900
library(shiny)
library(plotly)

# UI
ui <- fluidPage(
  titlePanel("Laktat-Leistungs-Modell"),
  sidebarLayout(
    sidebarPanel(
      numericInput("num_rows", "Anzahl der Datenpunkte", 4, min = 1, max = 20),
      uiOutput("input_fields"),
      width = 2  
    ),
    mainPanel(
      plotlyOutput("plot"),
      width = 10  
    )
  )
)

# Server
server <- function(input, output, session) {
  # Initialwerte für die Leistung und ΔBLC
  initial_values <- list(
    list(Leistung = 100, DeltaBLC = 0.3),
    list(Leistung = 200, DeltaBLC = 1.0),
    list(Leistung = 300, DeltaBLC = 2.8),
    list(Leistung = 400, DeltaBLC = 8.0)
  )
  
  # Dynamisch Input-Felder erzeugen
  output$input_fields <- renderUI({
    num_rows <- input$num_rows
    
    lapply(1:num_rows, function(i) {
      initial_value <- if (i <= length(initial_values)) initial_values[[i]] else list(Leistung = 0, DeltaBLC = 0)
      tagList(
        numericInput(paste0("leistung_", i), paste("Leistung", i), value = initial_value$Leistung, step = 10),
        numericInput(paste0("deltaBLC_", i), paste("ΔBLC", i), value = initial_value$DeltaBLC, step = 0.1)
      )
    })
  })
  
  # Reaktive Datenframe basierend auf Eingabewerten
  input_data <- reactive({
    num_rows <- input$num_rows
    if (is.null(num_rows)) return(NULL)
    
    data <- data.frame(Leistung = numeric(num_rows), ΔBLC = numeric(num_rows))
    
    for (i in 1:num_rows) {
      leistung_val <- input[[paste0("leistung_", i)]]
      deltaBLC_val <- input[[paste0("deltaBLC_", i)]]
      
      if (is.null(leistung_val) || is.null(deltaBLC_val)) {
        data$Leistung[i] <- if (i <= length(initial_values)) initial_values[[i]]$Leistung else 0
        data$ΔBLC[i] <- if (i <= length(initial_values)) initial_values[[i]]$DeltaBLC else 0
      } else {
        data$Leistung[i] <- leistung_val
        data$ΔBLC[i] <- deltaBLC_val
      }
    }
    
    data
  })
  
  # Initiale Werte setzen
  observe({
    for (i in 1:length(initial_values)) {
      updateNumericInput(session, paste0("leistung_", i), value = initial_values[[i]]$Leistung)
      updateNumericInput(session, paste0("deltaBLC_", i), value = initial_values[[i]]$DeltaBLC)
    }
  })
  
  # Modell anpassen und Plot aktualisieren
  output$plot <- renderPlotly({
    df_proband <- input_data()
    
    if (is.null(df_proband)) return(NULL)
    
    # Anpassung des Exponentialmodells
    model <- nls(ΔBLC ~ a * exp(b * Leistung), data = df_proband, start = list(a = 1, b = 0.01))
    coef_exponential_model <- coef(model)
    
    # Vorhersagen und Sequenz für den Plot
    x_seq <- seq(min(df_proband$Leistung), max(df_proband$Leistung), length.out = 100)
    y_pred <- predict(model, newdata = data.frame(Leistung = x_seq))
    
    # Plotly-Diagramm
    plot_ly() %>%
      add_trace(data = df_proband, x = ~Leistung, y = ~ΔBLC, type = 'scatter', mode = 'markers',
                name = "ΔBLC",
                marker = list(color = "#2683C6", size = 7.0)) %>%
      add_trace(x = ~x_seq, y = ~y_pred, type = 'scatter', mode = 'lines', 
                name = 'Laktat-Modellfunktion', 
                line = list(color = '#62A39F', width = 3)) %>%
      add_annotations(text = sprintf("ΔBLC = %.5f \u00B7 e<sup>%.5f \u00B7 Leistung</sup>", 
                                     coef_exponential_model['a'], coef_exponential_model['b']),
                      x = min(df_proband$Leistung), y = max(y_pred), showarrow = FALSE,
                      xanchor = 'left', yanchor = 'bottom',
                      font = list(family = "Arial, sans-serif", size = 12, color = "black")) %>%
      layout(
        title = "Laktat-Leistungs-Modell",
        margin = list(t = 40),
        xaxis = list(title = "Leistung [Watt]"),
        yaxis = list(title = "ΔBLC [mmol \u00B7 l<sup>-1</sup>]")
      )
  })
}

# App starten
shinyApp(ui = ui, server = server)
```

